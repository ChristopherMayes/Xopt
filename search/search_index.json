{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#xopt","title":"Xopt","text":"<p>Flexible optimization of arbitrary problems in Python.</p> <p>The goal of this package is to provide advanced algorithmic support for arbitrary  simulations/control systems with minimal required coding. Users can easily connect  arbitrary evaluation functions to advanced algorithms with minimal coding with  support for multi-threaded or MPI-enabled execution.</p> <p>Currenty Xopt provides:</p> <ul> <li>optimization algorithms:<ul> <li><code>cnsga</code> Continuous NSGA-II with constraints.</li> <li><code>upper_confidence_bound</code> Single objective Bayesian optimization (w/ or w/o     constraints, serial or parallel).</li> <li><code>mobo</code> Multi-objective Bayesian optimization (w/ or w/o constraints, serial or parallel).</li> <li><code>bayesian_exploration</code> Bayesian exploration.</li> </ul> </li> <li>sampling algorithms:<ul> <li><code>random sampler</code></li> </ul> </li> <li>Convenient YAML/JSON based input format.</li> <li>Driver programs:<ul> <li><code>xopt.mpi.run</code> Parallel MPI execution using this input format.</li> </ul> </li> </ul> <p>Xopt does not provide:  - your custom simulation via an <code>evaluate</code> function.</p> <p>Rather, Xopt asks you to define this function.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Xopt Overview PDF gives an overview of Xopt's design and  usage.</p> <p>Xopt Built-In Generators provides a list of available algorithms  implemented in the Xopt <code>Generator</code> framework.</p> <p>Simple Bayesian Optimization Example shows  Xopt usage for a simple optimization problem.</p>"},{"location":"#configuring-an-xopt-run","title":"Configuring an Xopt run","text":"<p>Xopt runs are specified via a dictionary that can be directly imported from a YAML  file.</p> <pre><code>xopt:\nmax_evaluations: 6400\n\ngenerator:\nname: cnsga\npopulation_size: 64\npopulation_file: test.csv\noutput_path: .\n\nevaluator:\nfunction: xopt.resources.test_functions.tnk.evaluate_TNK\nfunction_kwargs:\nraise_probability: 0.1\n\nvocs:\nvariables:\nx1: [0, 3.14159]\nx2: [0, 3.14159]\nobjectives: {y1: MINIMIZE, y2: MINIMIZE}\nconstraints:\nc1: [GREATER_THAN, 0]\nc2: [LESS_THAN, 0.5]\nconstants: {a: dummy_constant}\n</code></pre>"},{"location":"#defining-evaluation-function","title":"Defining evaluation function","text":"<p>Xopt can interface with arbitrary evaluate functions (defined in Python) with the  following form: <pre><code>evaluate(inputs: dict) -&gt; dict\n</code></pre> Evaluate functions must accept a dictionary object that at least has the keys  specified in <code>variables, constants, linked_variables</code> and returns a dictionary  containing at least the  keys contained in <code>objectives, constraints</code>. Extra dictionary keys are tracked and  used in the evaluate function but are not modified by xopt.</p>"},{"location":"#using-mpi","title":"Using MPI","text":"<p>Example MPI run, with <code>xopt.yaml</code> as the only user-defined file: <pre><code>mpirun -n 64 python -m mpi4py.futures -m xopt.mpi.run xopt.yaml\n</code></pre></p>"},{"location":"algorithms/","title":"Pre-Configured Generators in Xopt","text":"<p>A number of algorithms are implemented in Xopt using the <code>Generator</code> class for  off-the-shelf usage.  Below is a  description of the different generators that are available in Xopt and their target  use cases.</p>"},{"location":"algorithms/#randomgenerator","title":"RandomGenerator","text":"<p>Generates random points in the input space according to <code>VOCS</code>.</p>"},{"location":"algorithms/#bayesian-generators","title":"Bayesian Generators","text":"<p>All of the generators here use Bayesian optimization (BO) type methods to solve single  objective, multi objective and characterization problems. Bayesian generators  incorperate unknown constrianing functions into optimization based on what is  specified in <code>VOCS</code></p> <ul> <li><code>ExpectedImprovementGenerator</code>: implements Expected Improvement single    objective BO. Automatically balances trade-offs between exploration and    exploitation and is thus useful for general purpose optimization. </li> <li><code>UpperConfidenceBoundGenerator</code>: implements Upper Confidence Bound single    objective BO. Requires a hyperparameter <code>beta</code> that explicitly sets the tradeoff    between exploration and exploitation. Default value of <code>beta=2</code> is a good    starting point. Increase $\\beta$ to prioritize exploration and decrease <code>beta</code> to    prioritize exploitation.</li> <li><code>BayesianExplorationGenerator</code>: implements the Bayesian Exploration algorithm    for function characterization. This algorithm selects observation points that    maximize model uncertainty, thus picking points that maximize the information gain    about the target function at each iteration. If the target function is found to be    more sensative to one parameter this generator will adjust sampling frequency to    adapt. Note: specifying <code>vocs.objective[1]</code>   to <code>MAXIMIZE</code> or <code>MINIMIZE</code> does not change the behavior of this generator.</li> <li><code>MOBOGenerator</code>: implements Multi-Objective BO using the    Expected Hypervolume Improvement (EHVI) acquisition function. This is an ideal    general purpose multi-objective optimizer when objective evaluations cannot be    massively parallelized (&lt; 10 parallel evaluations).</li> <li><code>MGGPOGenerator</code>: implements Multi-Generation Gaussian Process Optimization using    the    Expected Hypervolume Improvement (EHVI) acquisition function. This is an ideal    general purpose multi-objective optimizer when objective evaluations can be    massively parallelized (&gt; 10 parallel evaluations) .</li> <li><code>MultiFidelityGenerator</code>: implements Multi-Fidelity BO which can take    advantage of lower fidelity evaluations of objectives and constraints to reduce    the computational cost of solving single or multi-objective optimization problems    in sequential or small scale parallel (&lt; 10 parallel evaluations)    contexts. </li> </ul>"},{"location":"algorithms/#evolutionary-generators","title":"Evolutionary Generators","text":"<ul> <li><code>CNSGAGenerator</code>: implements Continuous Non-dominated Sorted Genetic Algorithm    which as a good general purpose evolutionary algorithm used for solving    multi-objective optimization problems where evaluating the objective is relatively    cheap and massively parallelizable (above 5-10 parallel evaluations).</li> </ul>"},{"location":"algorithms/#extremum-seeking-generators","title":"Extremum Seeking Generators","text":"<ul> <li><code>ExtremumSeekingGenerator</code>: implements the Extremum Seeking algorithm which is    ideal for solving optimization problems that are suceptable to drifts.</li> </ul>"},{"location":"algorithms/#scipy-generators","title":"Scipy Generators","text":"<p>These generators serve as wrappers for algorithms implemented in scipy. - <code>NelderMeadGenerator</code>: implements Nelder-Mead (simplex) optimization.</p>"},{"location":"algorithms/#rcds-generators","title":"RCDS Generators","text":"<ul> <li><code>RCDSGenerator</code>: implements the RCDS algorithm. RCDS could be applied in noisy   online optimization scenarios</li> </ul>"},{"location":"algorithms/#custom-generators","title":"Custom Generators","text":"<p>Any general algorithm can be implemented by subclassing the abstract <code>Generator</code> class and used in the Xopt framework. If you implement a generator for your use case please consider opening a pull request so that we can add it to Xopt!</p>"},{"location":"installation/","title":"Installing Xopt","text":"<p>Installing <code>xopt</code> from the <code>conda-forge</code> channel can be achieved by adding <code>conda-forge</code> to your channels with:</p> <pre><code>conda config --add channels conda-forge\n</code></pre> <p>Once the <code>conda-forge</code> channel has been enabled, <code>xopt</code> can be installed with:</p> <pre><code>conda install xopt\n</code></pre> <p>It is possible to list all of the versions of <code>xopt</code> available on your platform with:</p> <pre><code>conda search xopt --channel conda-forge\n</code></pre>"},{"location":"installation/#developers","title":"Developers","text":"<p>Clone this repository: <pre><code>git clone https://github.com/ChristopherMayes/Xopt.git\n</code></pre></p> <p>Create an environment <code>xopt-dev</code> with all the dependencies: <pre><code>conda env create -f environment.yml\n</code></pre></p> <p>Install as editable: <pre><code>conda activate xopt-dev\npip install --no-dependencies -e .\n</code></pre></p>"},{"location":"installation/#cori-nersc-setup","title":"Cori (NERSC) setup","text":"<p><pre><code>conda install -c conda-forge xopt\n</code></pre> Follow instructions to build mpi4py: https://docs.nersc.gov/programming/high-level-environments/python/ Note that there is a bug in Jupyterhub terminals. Type: <pre><code>module swap PrgEnv-gnu PrgEnv-gnu\n</code></pre> to get the C compiler activated. </p>"},{"location":"api/evaluator/","title":"Evaluator","text":"<p>             Bases: <code>XoptBaseModel</code></p> <p>Xopt Evaluator for handling the parallel execution of an evaluate function.</p>"},{"location":"api/evaluator/#xopt.evaluator.Evaluator--parameters","title":"Parameters","text":"<p>function : Callable     Function to evaluate. function_kwargs : dict, default={}     Any kwargs to pass on to this function. max_workers : int, default=1     Maximum number of workers. executor : NormalExecutor     NormalExecutor or any instantiated Executor object vectorized : bool, default=False     If true,</p> Source code in <code>xopt/evaluator.py</code> <pre><code>class Evaluator(XoptBaseModel):\n\"\"\"\n    Xopt Evaluator for handling the parallel execution of an evaluate function.\n\n    Parameters\n    ----------\n    function : Callable\n        Function to evaluate.\n    function_kwargs : dict, default={}\n        Any kwargs to pass on to this function.\n    max_workers : int, default=1\n        Maximum number of workers.\n    executor : NormalExecutor\n        NormalExecutor or any instantiated Executor object\n    vectorized : bool, default=False\n        If true,\n    \"\"\"\n\n    function: Callable\n    max_workers: int = Field(1, ge=1)\n    executor: NormalExecutor = Field(exclude=True)  # Do not serialize\n    function_kwargs: dict = Field({})\n    vectorized: bool = Field(False)\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    @model_validator(mode='before')\n    def validate_all(cls, values):\n        f = get_function(values[\"function\"])\n        kwargs = values.get(\"function_kwargs\", {})\n        kwargs = {**get_function_defaults(f), **kwargs}\n        values[\"function\"] = f\n        values[\"function_kwargs\"] = kwargs\n\n        max_workers = values.pop(\"max_workers\", 1)\n\n        executor = values.pop(\"executor\", None)\n        if not executor:\n            if max_workers &gt; 1:\n                executor = ProcessPoolExecutor(max_workers=max_workers)\n            else:\n                executor = DummyExecutor()\n\n        # Cast as a NormalExecutor\n        values[\"executor\"] = NormalExecutor[type(executor)](executor=executor)\n        values[\"max_workers\"] = max_workers\n\n        return values\n\n    def evaluate(self, input: Dict, **kwargs):\n\"\"\"\n        Evaluate a single input dict using Evaluator.function with\n        Evaluator.function_kwargs.\n\n        Further kwargs are passed to the function.\n\n        Inputs:\n            inputs: dict of inputs to be evaluated\n            **kwargs: additional kwargs to pass to the function\n\n        Returns:\n            function(input, **function_kwargs_updated)\n\n        \"\"\"\n        return self.safe_function(input, **{**self.function_kwargs, **kwargs})\n\n    def evaluate_data(\n        self,\n        input_data: Union[\n            pd.DataFrame,\n            List[Dict[str, float]],\n            Dict[str, List[float]],\n            Dict[str, float],\n        ],\n    ) -&gt; pd.DataFrame:\n\"\"\"evaluate dataframe of inputs\"\"\"\n        if self.vectorized:\n            output_data = self.safe_function(input_data, **self.function_kwargs)\n        else:\n            # This construction is needed to avoid a pickle error\n            # translate input data into pandas dataframes\n            if not isinstance(input_data, DataFrame):\n                try:\n                    input_data = DataFrame(input_data)\n                except ValueError:\n                    input_data = DataFrame(input_data, index=[0])\n\n            inputs = input_data.to_dict(\"records\")\n\n            funcs = [self.function] * len(inputs)\n            kwargs = [self.function_kwargs] * len(inputs)\n\n            output_data = self.executor.map(\n                safe_function1_for_map,\n                funcs,\n                inputs,\n                kwargs,\n            )\n\n        return DataFrame(output_data, index=input_data.index)\n\n    def safe_function(self, *args, **kwargs):\n\"\"\"\n        Safely call the function, handling exceptions.\n\n        Note that this should not be submitted to fuu\n        \"\"\"\n        return safe_function(self.function, *args, **kwargs)\n\n    def submit(self, input: Dict):\n\"\"\"submit a single input to the executor\n\n        Parameters\n        ----------\n        input : dict\n\n        Returns\n        -------\n        Future  : Future object\n        \"\"\"\n        if not isinstance(input, dict):\n            raise ValueError(\"input must be a dictionary\")\n        # return self.executor.submit(self.function, input, **self.function_kwargs)\n        # Must call a function outside of the classs\n        # See: https://stackoverflow.com/questions/44144584/typeerror-cant-pickle-thread-lock-objects\n        return self.executor.submit(\n            safe_function, self.function, input, **self.function_kwargs\n        )\n\n    def submit_data(self, input_data: pd.DataFrame):\n\"\"\"submit dataframe of inputs to executor\"\"\"\n        input_data = pd.DataFrame(input_data)  # cast to dataframe for consistency\n\n        if self.vectorized:\n            # Single submission, cast to numpy array\n            inputs = input_data.to_dict(orient=\"list\")\n            for key, value in inputs.items():\n                inputs[key] = np.array(value)\n            futures = [self.submit(inputs)]  # Single item\n        else:\n            # Do not use iterrows or itertuples.\n            futures = [self.submit(inputs) for inputs in input_data.to_dict(\"records\")]\n\n        return futures\n</code></pre>"},{"location":"api/evaluator/#xopt.evaluator.Evaluator.evaluate","title":"<code>evaluate(input, **kwargs)</code>","text":"<p>Evaluate a single input dict using Evaluator.function with Evaluator.function_kwargs.</p> <p>Further kwargs are passed to the function.</p> Inputs <p>inputs: dict of inputs to be evaluated **kwargs: additional kwargs to pass to the function</p> <p>Returns:</p> Type Description <p>function(input, **function_kwargs_updated)</p> Source code in <code>xopt/evaluator.py</code> <pre><code>def evaluate(self, input: Dict, **kwargs):\n\"\"\"\n    Evaluate a single input dict using Evaluator.function with\n    Evaluator.function_kwargs.\n\n    Further kwargs are passed to the function.\n\n    Inputs:\n        inputs: dict of inputs to be evaluated\n        **kwargs: additional kwargs to pass to the function\n\n    Returns:\n        function(input, **function_kwargs_updated)\n\n    \"\"\"\n    return self.safe_function(input, **{**self.function_kwargs, **kwargs})\n</code></pre>"},{"location":"api/evaluator/#xopt.evaluator.Evaluator.evaluate_data","title":"<code>evaluate_data(input_data)</code>","text":"<p>evaluate dataframe of inputs</p> Source code in <code>xopt/evaluator.py</code> <pre><code>def evaluate_data(\n    self,\n    input_data: Union[\n        pd.DataFrame,\n        List[Dict[str, float]],\n        Dict[str, List[float]],\n        Dict[str, float],\n    ],\n) -&gt; pd.DataFrame:\n\"\"\"evaluate dataframe of inputs\"\"\"\n    if self.vectorized:\n        output_data = self.safe_function(input_data, **self.function_kwargs)\n    else:\n        # This construction is needed to avoid a pickle error\n        # translate input data into pandas dataframes\n        if not isinstance(input_data, DataFrame):\n            try:\n                input_data = DataFrame(input_data)\n            except ValueError:\n                input_data = DataFrame(input_data, index=[0])\n\n        inputs = input_data.to_dict(\"records\")\n\n        funcs = [self.function] * len(inputs)\n        kwargs = [self.function_kwargs] * len(inputs)\n\n        output_data = self.executor.map(\n            safe_function1_for_map,\n            funcs,\n            inputs,\n            kwargs,\n        )\n\n    return DataFrame(output_data, index=input_data.index)\n</code></pre>"},{"location":"api/evaluator/#xopt.evaluator.Evaluator.safe_function","title":"<code>safe_function(*args, **kwargs)</code>","text":"<p>Safely call the function, handling exceptions.</p> <p>Note that this should not be submitted to fuu</p> Source code in <code>xopt/evaluator.py</code> <pre><code>def safe_function(self, *args, **kwargs):\n\"\"\"\n    Safely call the function, handling exceptions.\n\n    Note that this should not be submitted to fuu\n    \"\"\"\n    return safe_function(self.function, *args, **kwargs)\n</code></pre>"},{"location":"api/evaluator/#xopt.evaluator.Evaluator.submit","title":"<code>submit(input)</code>","text":"<p>submit a single input to the executor</p>"},{"location":"api/evaluator/#xopt.evaluator.Evaluator.submit--parameters","title":"Parameters","text":"<p>input : dict</p>"},{"location":"api/evaluator/#xopt.evaluator.Evaluator.submit--returns","title":"Returns","text":"<p>Future  : Future object</p> Source code in <code>xopt/evaluator.py</code> <pre><code>def submit(self, input: Dict):\n\"\"\"submit a single input to the executor\n\n    Parameters\n    ----------\n    input : dict\n\n    Returns\n    -------\n    Future  : Future object\n    \"\"\"\n    if not isinstance(input, dict):\n        raise ValueError(\"input must be a dictionary\")\n    # return self.executor.submit(self.function, input, **self.function_kwargs)\n    # Must call a function outside of the classs\n    # See: https://stackoverflow.com/questions/44144584/typeerror-cant-pickle-thread-lock-objects\n    return self.executor.submit(\n        safe_function, self.function, input, **self.function_kwargs\n    )\n</code></pre>"},{"location":"api/evaluator/#xopt.evaluator.Evaluator.submit_data","title":"<code>submit_data(input_data)</code>","text":"<p>submit dataframe of inputs to executor</p> Source code in <code>xopt/evaluator.py</code> <pre><code>def submit_data(self, input_data: pd.DataFrame):\n\"\"\"submit dataframe of inputs to executor\"\"\"\n    input_data = pd.DataFrame(input_data)  # cast to dataframe for consistency\n\n    if self.vectorized:\n        # Single submission, cast to numpy array\n        inputs = input_data.to_dict(orient=\"list\")\n        for key, value in inputs.items():\n            inputs[key] = np.array(value)\n        futures = [self.submit(inputs)]  # Single item\n    else:\n        # Do not use iterrows or itertuples.\n        futures = [self.submit(inputs) for inputs in input_data.to_dict(\"records\")]\n\n    return futures\n</code></pre>"},{"location":"api/generators/","title":"Base generator class","text":""},{"location":"api/generators/#xopt.generator.Generator","title":"<code>Generator</code>","text":"<p>             Bases: <code>XoptBaseModel</code>, <code>ABC</code></p> Source code in <code>xopt/generator.py</code> <pre><code>class Generator(XoptBaseModel, ABC):\n    name: ClassVar[str] = Field(description=\"generator name\")\n    vocs: VOCS = Field(description=\"generator VOCS\", exclude=True)\n    data: Optional[pd.DataFrame] = Field(None, description=\"generator data\", exclude=True)\n    supports_batch_generation: ClassVar[bool] = Field(\n        default=False,\n        description=\"flag that describes if this \"\n        \"generator can generate \"\n        \"batches of points\",\n    )\n    supports_multi_objective: ClassVar[bool] = Field(\n        default=False,\n        description=\"flag that describes if this generator can solve multi-objective \"\n        \"problems\",\n    )\n\n    model_config = ConfigDict(validate_assignment=True)\n\n    _is_done = False\n\n    @field_validator(\"data\", mode='before')\n    def validate_data(cls, v):\n        if isinstance(v, dict):\n            try:\n                v = pd.DataFrame(v)\n            except IndexError:\n                v = pd.DataFrame(v, index=[0])\n        return v\n\n    def __init__(self, **kwargs):\n\"\"\"\n        Initialize the generator.\n\n        Args:\n            vocs: The vocs to use.\n            options: The options to use.\n        \"\"\"\n        super().__init__(**kwargs)\n        _check_vocs(self.vocs, self.supports_multi_objective)\n        logger.info(f\"Initialized generator {self.name}\")\n\n    @property\n    def is_done(self):\n        return self._is_done\n\n    @abstractmethod\n    def generate(self, n_candidates) -&gt; list[dict]:\n\"\"\"\n        generate `n_candidates` candidates\n\n        \"\"\"\n        pass\n\n    def add_data(self, new_data: pd.DataFrame):\n\"\"\"\n        update dataframe with results from new evaluations.\n\n        This is intended for generators that maintain their own data.\n\n        \"\"\"\n        if self.data is not None:\n            self.data = pd.concat([self.data, new_data], axis=0)\n        else:\n            self.data = new_data\n</code></pre>"},{"location":"api/generators/#xopt.generator.Generator.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize the generator.</p> <p>Parameters:</p> Name Type Description Default <code>vocs</code> <p>The vocs to use.</p> required <code>options</code> <p>The options to use.</p> required Source code in <code>xopt/generator.py</code> <pre><code>def __init__(self, **kwargs):\n\"\"\"\n    Initialize the generator.\n\n    Args:\n        vocs: The vocs to use.\n        options: The options to use.\n    \"\"\"\n    super().__init__(**kwargs)\n    _check_vocs(self.vocs, self.supports_multi_objective)\n    logger.info(f\"Initialized generator {self.name}\")\n</code></pre>"},{"location":"api/generators/#xopt.generator.Generator.add_data","title":"<code>add_data(new_data)</code>","text":"<p>update dataframe with results from new evaluations.</p> <p>This is intended for generators that maintain their own data.</p> Source code in <code>xopt/generator.py</code> <pre><code>def add_data(self, new_data: pd.DataFrame):\n\"\"\"\n    update dataframe with results from new evaluations.\n\n    This is intended for generators that maintain their own data.\n\n    \"\"\"\n    if self.data is not None:\n        self.data = pd.concat([self.data, new_data], axis=0)\n    else:\n        self.data = new_data\n</code></pre>"},{"location":"api/generators/#xopt.generator.Generator.generate","title":"<code>generate(n_candidates)</code>  <code>abstractmethod</code>","text":"<p>generate <code>n_candidates</code> candidates</p> Source code in <code>xopt/generator.py</code> <pre><code>@abstractmethod\ndef generate(self, n_candidates) -&gt; list[dict]:\n\"\"\"\n    generate `n_candidates` candidates\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/vocs/","title":"Vocs","text":"<p>             Bases: <code>XoptBaseModel</code></p> <p>Variables, Objectives, Constraints, and other Settings (VOCS) data structure to describe optimization problems.</p> Source code in <code>xopt/vocs.py</code> <pre><code>class VOCS(XoptBaseModel):\n\"\"\"\n    Variables, Objectives, Constraints, and other Settings (VOCS) data structure\n    to describe optimization problems.\n    \"\"\"\n\n    variables: Dict[str, conlist(float, min_length=2, max_length=2)] = Field(\n        default={},\n        description=\"input variable names with a list of minimum and maximum values\",\n    )\n    constraints: Dict[\n        str, conlist(Union[float, ConstraintEnum], min_length=2, max_length=2)\n    ] = Field(\n        default={},\n        description=\"constraint names with a list of constraint type and value\",\n    )\n    objectives: Dict[str, ObjectiveEnum] = Field(\n        default={}, description=\"objective names with type of objective\"\n    )\n    constants: Dict[str, Any] = Field(\n        default={}, description=\"constant names and values passed to evaluate function\"\n    )\n    observables: List[str] = Field(\n        default=[],\n        description=\"observation names tracked alongside objectives and constraints\",\n    )\n\n    model_config = ConfigDict(validate_assignment=True, use_enum_values=True)\n\n    @classmethod\n    def from_yaml(cls, yaml_text):\n        loaded = yaml.safe_load(yaml_text)\n        return cls(**loaded)\n\n    def as_yaml(self):\n        return yaml.dump(self.model_dump(), default_flow_style=None, sort_keys=False)\n\n    @property\n    def bounds(self):\n\"\"\"\n        Returns a bounds array (mins, maxs) of shape (2, n_variables)\n        Arrays of lower and upper bounds can be extracted by:\n            mins, maxs = vocs.bounds\n        \"\"\"\n        return np.array([v for _, v in sorted(self.variables.items())]).T\n\n    @property\n    def variable_names(self):\n\"\"\"Returns a sorted list of variable names\"\"\"\n        return list(sorted(self.variables.keys()))\n\n    @property\n    def objective_names(self):\n\"\"\"Returns a sorted list of objective names\"\"\"\n        return list(sorted(self.objectives.keys()))\n\n    @property\n    def constraint_names(self):\n\"\"\"Returns a sorted list of constraint names\"\"\"\n        if self.constraints is None:\n            return []\n        return list(sorted(self.constraints.keys()))\n\n    @property\n    def observable_names(self):\n        return sorted(self.observables)\n\n    @property\n    def output_names(self):\n\"\"\"\n        Returns a list of expected output keys:\n            (objectives + constraints + observables)\n        Each sub-list is sorted.\n        \"\"\"\n        full_list = self.objective_names\n        for ele in self.constraint_names:\n            if ele not in full_list:\n                full_list += [ele]\n\n        for ele in self.observable_names:\n            if ele not in full_list:\n                full_list += [ele]\n\n        return full_list\n\n    @property\n    def constant_names(self):\n\"\"\"Returns a sorted list of constraint names\"\"\"\n        if self.constants is None:\n            return []\n        return list(sorted(self.constants.keys()))\n\n    @property\n    def all_names(self):\n\"\"\"Returns all vocs names (variables, constants, objectives, constraints)\"\"\"\n        return self.variable_names + self.constant_names + self.output_names\n\n    @property\n    def n_variables(self):\n\"\"\"Returns the number of variables\"\"\"\n        return len(self.variables)\n\n    @property\n    def n_constants(self):\n\"\"\"Returns the number of constants\"\"\"\n        return len(self.constants)\n\n    @property\n    def n_inputs(self):\n\"\"\"Returns the number of inputs (variables and constants)\"\"\"\n        return self.n_variables + self.n_constants\n\n    @property\n    def n_objectives(self):\n\"\"\"Returns the number of objectives\"\"\"\n        return len(self.objectives)\n\n    @property\n    def n_constraints(self):\n\"\"\"Returns the number of constraints\"\"\"\n        return len(self.constraints)\n\n    @property\n    def n_observables(self):\n\"\"\"Returns the number of constraints\"\"\"\n        return len(self.observables)\n\n    @property\n    def n_outputs(self):\n\"\"\"\n        Returns the number of outputs\n            len(objectives + constraints + observables)\n        \"\"\"\n        return len(self.output_names)\n\n    def random_inputs(\n        self,\n        n: int = None,\n        custom_bounds: dict = None,\n        include_constants: bool = True,\n        seed: int = None,\n    ) -&gt; list[dict]:\n\"\"\"\n        Uniform sampling of the variables.\n\n        Returns a dict of inputs.\n\n        If include_constants, the vocs.constants are added to the dict.\n\n        Optional:\n            n (integer) to make arrays of inputs, of size n.\n            seed (integer) to initialize the random number generator\n\n        \"\"\"\n        inputs = {}\n        if seed is None:\n            rng_sample_function = np.random.random\n        else:\n            rng = np.random.default_rng(seed=seed)\n            rng_sample_function = rng.random\n\n        # get bounds\n        # if custom_bounds is specified then they will be clipped inside\n        # vocs variable bounds\n        if custom_bounds is None:\n            bounds = self.variables\n        else:\n            variable_bounds = pd.DataFrame(self.variables)\n            custom_bounds = pd.DataFrame(custom_bounds)\n            custom_bounds = custom_bounds.clip(\n                variable_bounds.iloc[0], variable_bounds.iloc[1], axis=1\n            )\n            bounds = custom_bounds.to_dict()\n            for k in bounds.keys():\n                bounds[k] = [bounds[k][i] for i in range(2)]\n\n        for key, val in bounds.items():  # No need to sort here\n            a, b = val\n            n = n if n is not None else 1\n            x = rng_sample_function(n)\n            inputs[key] = x * a + (1 - x) * b\n\n        # Constants\n        if include_constants and self.constants is not None:\n            inputs.update(self.constants)\n\n        if n == 1:\n            return [inputs]\n        else:\n            return pd.DataFrame(inputs).to_dict(\"records\")\n\n    def convert_dataframe_to_inputs(\n        self, data: pd.DataFrame, include_constants=True\n    ) -&gt; pd.DataFrame:\n\"\"\"\n        Extracts only inputs from a dataframe.\n        This will add constants if `include_constants` is true.\n        \"\"\"\n        # make sure that the df keys only contain vocs variables\n        if not set(self.variable_names) == set(data.keys()):\n            raise ValueError(\n                \"input dataframe column set must equal set of vocs variables\"\n            )\n\n        # only keep the variables\n        inner_copy = data.copy()\n\n        # append constants if requested\n        if include_constants:\n            constants = self.constants\n            if constants is not None:\n                for name, val in constants.items():\n                    inner_copy[name] = val\n\n        return inner_copy\n\n    def convert_numpy_to_inputs(\n        self, inputs: np.ndarray, include_constants=True\n    ) -&gt; pd.DataFrame:\n\"\"\"\n        convert 2D numpy array to list of dicts (inputs) for evaluation\n        Assumes that the columns of the array match correspond to\n        `sorted(self.vocs.variables.keys())\n\n        \"\"\"\n        df = pd.DataFrame(inputs, columns=self.variable_names)\n        return self.convert_dataframe_to_inputs(df, include_constants)\n\n    # Extract optimization data (in correct column order)\n    def variable_data(\n        self,\n        data: Union[pd.DataFrame, List[Dict], List[Dict]],\n        prefix: str = \"variable_\",\n    ) -&gt; pd.DataFrame:\n\"\"\"\n        Returns a dataframe containing variables according to `vocs.variables` in sorted\n        order\n\n        Args:\n            data: Data to be processed.\n            prefix: Prefix added to column names.\n\n        Returns:\n            result: processed Dataframe\n        \"\"\"\n        return form_variable_data(self.variables, data, prefix=prefix)\n\n    def objective_data(\n        self,\n        data: Union[pd.DataFrame, List[Dict], List[Dict]],\n        prefix: str = \"objective_\",\n        return_raw=False,\n    ) -&gt; pd.DataFrame:\n\"\"\"\n        Returns a dataframe containing objective data transformed according to\n        `vocs.objectives` such that we always assume minimization.\n\n        Args:\n            data: data to be processed.\n            prefix: prefix added to column names.\n\n        Returns:\n            result: processed Dataframe\n        \"\"\"\n        return form_objective_data(self.objectives, data, prefix, return_raw)\n\n    def constraint_data(\n        self,\n        data: Union[pd.DataFrame, List[Dict], List[Dict]],\n        prefix: str = \"constraint_\",\n    ) -&gt; pd.DataFrame:\n\"\"\"\n        Returns a dataframe containing constraint data transformed according to\n        `vocs.constraints` such that values that satisfy each constraint are negative.\n\n        Args:\n            data: data to be processed.\n            prefix: prefix added to column names.\n\n        Returns:\n            result: processed Dataframe\n        \"\"\"\n        return form_constraint_data(self.constraints, data, prefix)\n\n    def observable_data(\n        self,\n        data: Union[pd.DataFrame, List[Dict], List[Dict]],\n        prefix: str = \"observable_\",\n    ) -&gt; pd.DataFrame:\n\"\"\"\n        Returns a dataframe containing observable data\n\n        Args:\n            data: data to be processed.\n            prefix: prefix added to column names.\n\n        Returns:\n            result: processed Dataframe\n        \"\"\"\n        return form_observable_data(self.observable_names, data, prefix)\n\n    def feasibility_data(\n        self,\n        data: Union[pd.DataFrame, List[Dict], List[Dict]],\n        prefix: str = \"feasible_\",\n    ) -&gt; pd.DataFrame:\n\"\"\"\n        Returns a dataframe containing booleans denoting if a constraint is satisfied or\n        not. Returned dataframe also contains a column `feasible` which denotes if\n        all constraints are satisfied.\n\n        Args:\n            data: data to be processed.\n            prefix: prefix added to column names.\n\n        Returns:\n            result: processed Dataframe\n        \"\"\"\n        return form_feasibility_data(self.constraints, data, prefix)\n\n    def validate_input_data(self, input_points: pd.DataFrame) -&gt; None:\n\"\"\"\n        Validates input data. Raises an error if the input data does not satisfy\n        requirements given by vocs.\n\n        Args:\n            input_points: input data to be validated.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: if input data does not satisfy requirements.\n        \"\"\"\n        validate_input_data(self, input_points)\n\n    def extract_data(self, data: pd.DataFrame, return_raw=False):\n\"\"\"\n        split dataframe into seperate dataframes for variables, objectives and\n        constraints based on vocs - objective data is transformed based on\n        `vocs.objectives` properties\n\n        Args:\n            data: dataframe to be split\n            return_raw: if True, return untransformed objective data\n\n        Returns:\n            variable_data: dataframe containing variable data\n            objective_data: dataframe containing objective data\n            constraint_data: dataframe containing constraint data\n        \"\"\"\n        variable_data = self.variable_data(data, \"\")\n        objective_data = self.objective_data(data, \"\", return_raw)\n        constraint_data = self.constraint_data(data, \"\")\n        return variable_data, objective_data, constraint_data\n</code></pre>"},{"location":"api/vocs/#xopt.vocs.VOCS.all_names","title":"<code>all_names</code>  <code>property</code>","text":"<p>Returns all vocs names (variables, constants, objectives, constraints)</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.bounds","title":"<code>bounds</code>  <code>property</code>","text":"<p>Returns a bounds array (mins, maxs) of shape (2, n_variables) Arrays of lower and upper bounds can be extracted by:     mins, maxs = vocs.bounds</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.constant_names","title":"<code>constant_names</code>  <code>property</code>","text":"<p>Returns a sorted list of constraint names</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.constraint_names","title":"<code>constraint_names</code>  <code>property</code>","text":"<p>Returns a sorted list of constraint names</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.n_constants","title":"<code>n_constants</code>  <code>property</code>","text":"<p>Returns the number of constants</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.n_constraints","title":"<code>n_constraints</code>  <code>property</code>","text":"<p>Returns the number of constraints</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.n_inputs","title":"<code>n_inputs</code>  <code>property</code>","text":"<p>Returns the number of inputs (variables and constants)</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.n_objectives","title":"<code>n_objectives</code>  <code>property</code>","text":"<p>Returns the number of objectives</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.n_observables","title":"<code>n_observables</code>  <code>property</code>","text":"<p>Returns the number of constraints</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.n_outputs","title":"<code>n_outputs</code>  <code>property</code>","text":"<p>Returns the number of outputs     len(objectives + constraints + observables)</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.n_variables","title":"<code>n_variables</code>  <code>property</code>","text":"<p>Returns the number of variables</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.objective_names","title":"<code>objective_names</code>  <code>property</code>","text":"<p>Returns a sorted list of objective names</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.output_names","title":"<code>output_names</code>  <code>property</code>","text":"Returns a list of expected output keys <p>(objectives + constraints + observables)</p> <p>Each sub-list is sorted.</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.variable_names","title":"<code>variable_names</code>  <code>property</code>","text":"<p>Returns a sorted list of variable names</p>"},{"location":"api/vocs/#xopt.vocs.VOCS.constraint_data","title":"<code>constraint_data(data, prefix='constraint_')</code>","text":"<p>Returns a dataframe containing constraint data transformed according to <code>vocs.constraints</code> such that values that satisfy each constraint are negative.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[DataFrame, List[Dict], List[Dict]]</code> <p>data to be processed.</p> required <code>prefix</code> <code>str</code> <p>prefix added to column names.</p> <code>'constraint_'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>DataFrame</code> <p>processed Dataframe</p> Source code in <code>xopt/vocs.py</code> <pre><code>def constraint_data(\n    self,\n    data: Union[pd.DataFrame, List[Dict], List[Dict]],\n    prefix: str = \"constraint_\",\n) -&gt; pd.DataFrame:\n\"\"\"\n    Returns a dataframe containing constraint data transformed according to\n    `vocs.constraints` such that values that satisfy each constraint are negative.\n\n    Args:\n        data: data to be processed.\n        prefix: prefix added to column names.\n\n    Returns:\n        result: processed Dataframe\n    \"\"\"\n    return form_constraint_data(self.constraints, data, prefix)\n</code></pre>"},{"location":"api/vocs/#xopt.vocs.VOCS.convert_dataframe_to_inputs","title":"<code>convert_dataframe_to_inputs(data, include_constants=True)</code>","text":"<p>Extracts only inputs from a dataframe. This will add constants if <code>include_constants</code> is true.</p> Source code in <code>xopt/vocs.py</code> <pre><code>def convert_dataframe_to_inputs(\n    self, data: pd.DataFrame, include_constants=True\n) -&gt; pd.DataFrame:\n\"\"\"\n    Extracts only inputs from a dataframe.\n    This will add constants if `include_constants` is true.\n    \"\"\"\n    # make sure that the df keys only contain vocs variables\n    if not set(self.variable_names) == set(data.keys()):\n        raise ValueError(\n            \"input dataframe column set must equal set of vocs variables\"\n        )\n\n    # only keep the variables\n    inner_copy = data.copy()\n\n    # append constants if requested\n    if include_constants:\n        constants = self.constants\n        if constants is not None:\n            for name, val in constants.items():\n                inner_copy[name] = val\n\n    return inner_copy\n</code></pre>"},{"location":"api/vocs/#xopt.vocs.VOCS.convert_numpy_to_inputs","title":"<code>convert_numpy_to_inputs(inputs, include_constants=True)</code>","text":"<p>convert 2D numpy array to list of dicts (inputs) for evaluation Assumes that the columns of the array match correspond to `sorted(self.vocs.variables.keys())</p> Source code in <code>xopt/vocs.py</code> <pre><code>def convert_numpy_to_inputs(\n    self, inputs: np.ndarray, include_constants=True\n) -&gt; pd.DataFrame:\n\"\"\"\n    convert 2D numpy array to list of dicts (inputs) for evaluation\n    Assumes that the columns of the array match correspond to\n    `sorted(self.vocs.variables.keys())\n\n    \"\"\"\n    df = pd.DataFrame(inputs, columns=self.variable_names)\n    return self.convert_dataframe_to_inputs(df, include_constants)\n</code></pre>"},{"location":"api/vocs/#xopt.vocs.VOCS.extract_data","title":"<code>extract_data(data, return_raw=False)</code>","text":"<p>split dataframe into seperate dataframes for variables, objectives and constraints based on vocs - objective data is transformed based on <code>vocs.objectives</code> properties</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>dataframe to be split</p> required <code>return_raw</code> <p>if True, return untransformed objective data</p> <code>False</code> <p>Returns:</p> Name Type Description <code>variable_data</code> <p>dataframe containing variable data</p> <code>objective_data</code> <p>dataframe containing objective data</p> <code>constraint_data</code> <p>dataframe containing constraint data</p> Source code in <code>xopt/vocs.py</code> <pre><code>def extract_data(self, data: pd.DataFrame, return_raw=False):\n\"\"\"\n    split dataframe into seperate dataframes for variables, objectives and\n    constraints based on vocs - objective data is transformed based on\n    `vocs.objectives` properties\n\n    Args:\n        data: dataframe to be split\n        return_raw: if True, return untransformed objective data\n\n    Returns:\n        variable_data: dataframe containing variable data\n        objective_data: dataframe containing objective data\n        constraint_data: dataframe containing constraint data\n    \"\"\"\n    variable_data = self.variable_data(data, \"\")\n    objective_data = self.objective_data(data, \"\", return_raw)\n    constraint_data = self.constraint_data(data, \"\")\n    return variable_data, objective_data, constraint_data\n</code></pre>"},{"location":"api/vocs/#xopt.vocs.VOCS.feasibility_data","title":"<code>feasibility_data(data, prefix='feasible_')</code>","text":"<p>Returns a dataframe containing booleans denoting if a constraint is satisfied or not. Returned dataframe also contains a column <code>feasible</code> which denotes if all constraints are satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[DataFrame, List[Dict], List[Dict]]</code> <p>data to be processed.</p> required <code>prefix</code> <code>str</code> <p>prefix added to column names.</p> <code>'feasible_'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>DataFrame</code> <p>processed Dataframe</p> Source code in <code>xopt/vocs.py</code> <pre><code>def feasibility_data(\n    self,\n    data: Union[pd.DataFrame, List[Dict], List[Dict]],\n    prefix: str = \"feasible_\",\n) -&gt; pd.DataFrame:\n\"\"\"\n    Returns a dataframe containing booleans denoting if a constraint is satisfied or\n    not. Returned dataframe also contains a column `feasible` which denotes if\n    all constraints are satisfied.\n\n    Args:\n        data: data to be processed.\n        prefix: prefix added to column names.\n\n    Returns:\n        result: processed Dataframe\n    \"\"\"\n    return form_feasibility_data(self.constraints, data, prefix)\n</code></pre>"},{"location":"api/vocs/#xopt.vocs.VOCS.objective_data","title":"<code>objective_data(data, prefix='objective_', return_raw=False)</code>","text":"<p>Returns a dataframe containing objective data transformed according to <code>vocs.objectives</code> such that we always assume minimization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[DataFrame, List[Dict], List[Dict]]</code> <p>data to be processed.</p> required <code>prefix</code> <code>str</code> <p>prefix added to column names.</p> <code>'objective_'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>DataFrame</code> <p>processed Dataframe</p> Source code in <code>xopt/vocs.py</code> <pre><code>def objective_data(\n    self,\n    data: Union[pd.DataFrame, List[Dict], List[Dict]],\n    prefix: str = \"objective_\",\n    return_raw=False,\n) -&gt; pd.DataFrame:\n\"\"\"\n    Returns a dataframe containing objective data transformed according to\n    `vocs.objectives` such that we always assume minimization.\n\n    Args:\n        data: data to be processed.\n        prefix: prefix added to column names.\n\n    Returns:\n        result: processed Dataframe\n    \"\"\"\n    return form_objective_data(self.objectives, data, prefix, return_raw)\n</code></pre>"},{"location":"api/vocs/#xopt.vocs.VOCS.observable_data","title":"<code>observable_data(data, prefix='observable_')</code>","text":"<p>Returns a dataframe containing observable data</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[DataFrame, List[Dict], List[Dict]]</code> <p>data to be processed.</p> required <code>prefix</code> <code>str</code> <p>prefix added to column names.</p> <code>'observable_'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>DataFrame</code> <p>processed Dataframe</p> Source code in <code>xopt/vocs.py</code> <pre><code>def observable_data(\n    self,\n    data: Union[pd.DataFrame, List[Dict], List[Dict]],\n    prefix: str = \"observable_\",\n) -&gt; pd.DataFrame:\n\"\"\"\n    Returns a dataframe containing observable data\n\n    Args:\n        data: data to be processed.\n        prefix: prefix added to column names.\n\n    Returns:\n        result: processed Dataframe\n    \"\"\"\n    return form_observable_data(self.observable_names, data, prefix)\n</code></pre>"},{"location":"api/vocs/#xopt.vocs.VOCS.random_inputs","title":"<code>random_inputs(n=None, custom_bounds=None, include_constants=True, seed=None)</code>","text":"<p>Uniform sampling of the variables.</p> <p>Returns a dict of inputs.</p> <p>If include_constants, the vocs.constants are added to the dict.</p> Optional <p>n (integer) to make arrays of inputs, of size n. seed (integer) to initialize the random number generator</p> Source code in <code>xopt/vocs.py</code> <pre><code>def random_inputs(\n    self,\n    n: int = None,\n    custom_bounds: dict = None,\n    include_constants: bool = True,\n    seed: int = None,\n) -&gt; list[dict]:\n\"\"\"\n    Uniform sampling of the variables.\n\n    Returns a dict of inputs.\n\n    If include_constants, the vocs.constants are added to the dict.\n\n    Optional:\n        n (integer) to make arrays of inputs, of size n.\n        seed (integer) to initialize the random number generator\n\n    \"\"\"\n    inputs = {}\n    if seed is None:\n        rng_sample_function = np.random.random\n    else:\n        rng = np.random.default_rng(seed=seed)\n        rng_sample_function = rng.random\n\n    # get bounds\n    # if custom_bounds is specified then they will be clipped inside\n    # vocs variable bounds\n    if custom_bounds is None:\n        bounds = self.variables\n    else:\n        variable_bounds = pd.DataFrame(self.variables)\n        custom_bounds = pd.DataFrame(custom_bounds)\n        custom_bounds = custom_bounds.clip(\n            variable_bounds.iloc[0], variable_bounds.iloc[1], axis=1\n        )\n        bounds = custom_bounds.to_dict()\n        for k in bounds.keys():\n            bounds[k] = [bounds[k][i] for i in range(2)]\n\n    for key, val in bounds.items():  # No need to sort here\n        a, b = val\n        n = n if n is not None else 1\n        x = rng_sample_function(n)\n        inputs[key] = x * a + (1 - x) * b\n\n    # Constants\n    if include_constants and self.constants is not None:\n        inputs.update(self.constants)\n\n    if n == 1:\n        return [inputs]\n    else:\n        return pd.DataFrame(inputs).to_dict(\"records\")\n</code></pre>"},{"location":"api/vocs/#xopt.vocs.VOCS.validate_input_data","title":"<code>validate_input_data(input_points)</code>","text":"<p>Validates input data. Raises an error if the input data does not satisfy requirements given by vocs.</p> <p>Parameters:</p> Name Type Description Default <code>input_points</code> <code>DataFrame</code> <p>input data to be validated.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if input data does not satisfy requirements.</p> Source code in <code>xopt/vocs.py</code> <pre><code>def validate_input_data(self, input_points: pd.DataFrame) -&gt; None:\n\"\"\"\n    Validates input data. Raises an error if the input data does not satisfy\n    requirements given by vocs.\n\n    Args:\n        input_points: input data to be validated.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: if input data does not satisfy requirements.\n    \"\"\"\n    validate_input_data(self, input_points)\n</code></pre>"},{"location":"api/vocs/#xopt.vocs.VOCS.variable_data","title":"<code>variable_data(data, prefix='variable_')</code>","text":"<p>Returns a dataframe containing variables according to <code>vocs.variables</code> in sorted order</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[DataFrame, List[Dict], List[Dict]]</code> <p>Data to be processed.</p> required <code>prefix</code> <code>str</code> <p>Prefix added to column names.</p> <code>'variable_'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>DataFrame</code> <p>processed Dataframe</p> Source code in <code>xopt/vocs.py</code> <pre><code>def variable_data(\n    self,\n    data: Union[pd.DataFrame, List[Dict], List[Dict]],\n    prefix: str = \"variable_\",\n) -&gt; pd.DataFrame:\n\"\"\"\n    Returns a dataframe containing variables according to `vocs.variables` in sorted\n    order\n\n    Args:\n        data: Data to be processed.\n        prefix: Prefix added to column names.\n\n    Returns:\n        result: processed Dataframe\n    \"\"\"\n    return form_variable_data(self.variables, data, prefix=prefix)\n</code></pre>"},{"location":"api/xopt/","title":"Xopt","text":"<p>             Bases: <code>XoptBaseModel</code></p> <p>Object to handle a single optimization problem.</p> Source code in <code>xopt/base.py</code> <pre><code>class Xopt(XoptBaseModel):\n\"\"\"\n    Object to handle a single optimization problem.\n    \"\"\"\n\n    vocs: VOCS = Field(description=\"VOCS object for Xopt\")\n    generator: SerializeAsAny[Generator] = Field(description=\"generator object for Xopt\")\n    evaluator: SerializeAsAny[Evaluator] = Field(description=\"evaluator object for Xopt\")\n    strict: bool = Field(\n        True,\n        description=\"flag to indicate if exceptions raised during evaluation \"\n        \"should stop Xopt\",\n    )\n    dump_file: Optional[str] = Field(\n        None, description=\"file to dump the results of the evaluations\"\n    )\n    max_evaluations: Optional[int] = Field(\n        None, description=\"maximum number of evaluations to perform\"\n    )\n    data: Optional[DataFrame] = Field(None, description=\"internal DataFrame object\")\n    serialize_torch: bool = Field(\n        False,\n        description=\"flag to indicate that torch models should be serialized \"\n        \"when dumping\",\n    )\n    serialize_inline: bool = Field(False, description=\"flag to indicate if torch models\"\n                                                      \" should be stored inside main config file\")\n\n    @field_validator(\"vocs\", mode='before')\n    def validate_vocs(cls, value):\n        if isinstance(value, dict):\n            value = VOCS(**value)\n        return value\n\n    @field_validator(\"evaluator\", mode='before')\n    def validate_evaluator(cls, value):\n        if isinstance(value, dict):\n            value = Evaluator(**value)\n\n        return value\n\n    @field_validator(\"generator\", mode='before')\n    def validate_generator(cls, value, info: FieldValidationInfo):\n        if isinstance(value, dict):\n            name = value.pop(\"name\")\n            generator_class = get_generator(name)\n            value = generator_class.model_validate({**value, \"vocs\": info.data[\"vocs\"]})\n        elif isinstance(value, str):\n            generator_class = get_generator(value)\n            value = generator_class.model_validate({\"vocs\": info.data[\"vocs\"]})\n\n        return value\n\n    @field_validator(\"data\", mode='before')\n    def validate_data(cls, v, info: FieldValidationInfo):\n        if isinstance(v, dict):\n            try:\n                v = pd.DataFrame(v)\n            except IndexError:\n                v = pd.DataFrame(v, index=[0])\n\n        # also add data to generator\n        # TODO: find a more robust way of doing this\n        info.data[\"generator\"].add_data(v)\n\n        return v\n\n    @property\n    def n_data(self):\n        if self.data is None:\n            return 0\n        else:\n            return len(self.data)\n\n    def step(self):\n\"\"\"\n        run one optimization cycle\n\n        - determine the number of candidates to request from the generator\n        - pass candidate request to generator\n        - submit candidates to evaluator\n        - wait until all (asynch == False) or at least one (asynch == True) evaluation\n            is finished\n        - update data storage and generator data storage (if applicable)\n\n        \"\"\"\n        logger.info(\"Running Xopt step\")\n\n        # get number of candidates to generate\n        n_generate = self.evaluator.max_workers\n\n        # generate samples and submit to evaluator\n        logger.debug(f\"Generating {n_generate} candidates\")\n        new_samples = self.generator.generate(n_generate)\n\n        # Evaluate data\n        self.evaluate_data(new_samples)\n\n    def run(self):\n\"\"\"run until either max_evaluations is reached or the generator is\n        done\"\"\"\n        while not self.generator.is_done:\n            # Stopping criteria\n            if self.max_evaluations is not None:\n                if self.n_data &gt;= self.max_evaluations:\n                    logger.info(\n                        \"Xopt is done. \"\n                        f\"Max evaluations {self.max_evaluations} reached.\"\n                    )\n                    break\n\n            self.step()\n\n    def evaluate_data(\n        self,\n        input_data: Union[\n            pd.DataFrame,\n            List[Dict[str, float]],\n            Dict[str, List[float]],\n            Dict[str, float],\n        ],\n    ) -&gt; pd.DataFrame:\n\"\"\"\n        Evaluate data using the evaluator and wait for results.\n        Adds results to the internal dataframe.\n        \"\"\"\n        # translate input data into pandas dataframes\n        if not isinstance(input_data, DataFrame):\n            try:\n                input_data = DataFrame(input_data)\n            except ValueError:\n                input_data = DataFrame(input_data, index=[0])\n\n        logger.debug(f\"Evaluating {len(input_data)} inputs\")\n        self.vocs.validate_input_data(input_data)\n        output_data = self.evaluator.evaluate_data(input_data)\n\n        if self.strict:\n            validate_outputs(output_data)\n        new_data = pd.concat([input_data, output_data], axis=1)\n\n        # explode any list like results if all of the output names exist\n        new_data = explode_all_columns(new_data)\n\n        self.add_data(new_data)\n\n        # dump data to file if specified\n        self.dump_state()\n\n        return new_data\n\n    def add_data(self, new_data: pd.DataFrame):\n\"\"\"\n        Concatenate new data to internal dataframe,\n        and also adds this data to the generator.\n        \"\"\"\n        logger.debug(f\"Adding {len(new_data)} new data to internal dataframes\")\n\n        # Set internal dataframe.\n        if self.data is not None:\n            new_data = pd.DataFrame(new_data, copy=True)  # copy for reindexing\n            new_data.index = np.arange(\n                len(self.data) + 1, len(self.data) + len(new_data) + 1\n            )\n\n            self.data = pd.concat([self.data, new_data], axis=0)\n        else:\n            self.data = new_data\n        self.generator.add_data(new_data)\n\n    def reset_data(self):\n        self.data = pd.DataFrame()\n        self.generator.data = pd.DataFrame()\n\n    def random_evaluate(self, n_samples=1, seed=None, **kwargs):\n\"\"\"\n        Convenience method to generate random inputs using vocs\n        and evaluate them (adding data to Xopt object and generator).\n        \"\"\"\n        random_inputs = self.vocs.random_inputs(n_samples, seed=seed, **kwargs)\n        result = self.evaluate_data(random_inputs)\n        return result\n\n    def dump_state(self, **kwargs):\n\"\"\"dump data to file\"\"\"\n        if self.dump_file is not None:\n            output = json.loads(self.json(serialize_torch=self.serialize_torch,\n                                          serialize_inline=self.serialize_inline,\n                                          **kwargs))\n            with open(self.dump_file, \"w\") as f:\n                yaml.dump(output, f)\n            logger.debug(f\"Dumped state to YAML file: {self.dump_file}\")\n\n    def dict(self, **kwargs) -&gt; Dict:\n\"\"\"handle custom dict generation\"\"\"\n        result = super().model_dump(**kwargs)\n        result[\"generator\"] = {\"name\": self.generator.name} | result[\"generator\"]\n        return result\n\n    def json(self, **kwargs) -&gt; str:\n\"\"\"handle custom serialization of generators and dataframes\"\"\"\n        result = super().to_json(**kwargs)\n        dict_result = json.loads(result)\n        dict_result[\"generator\"] = {\"name\": self.generator.name} | dict_result[\n            \"generator\"\n        ]\n        dict_result[\"data\"] = (\n            json.loads(self.data.to_json()) if self.data is not None else None\n        )\n\n        # TODO: implement version checking\n        # dict_result[\"xopt_version\"] = __version__\n\n        return json.dumps(dict_result)\n\n    def __repr__(self):\n\"\"\"\n        Returns infor about the Xopt object, including the YAML representation without data.\n        \"\"\"\n\n        # get dict minus data\n        config = json.loads(self.json())\n        config.pop(\"data\")\n        return f\"\"\"\n            Xopt\n________________________________\nVersion: {__version__}\nData size: {self.n_data}\nConfig as YAML:\n{yaml.dump(config)}\n\"\"\"\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"api/xopt/#xopt.Xopt.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns infor about the Xopt object, including the YAML representation without data.</p> Source code in <code>xopt/base.py</code> <pre><code>    def __repr__(self):\n\"\"\"\n        Returns infor about the Xopt object, including the YAML representation without data.\n        \"\"\"\n\n        # get dict minus data\n        config = json.loads(self.json())\n        config.pop(\"data\")\n        return f\"\"\"\n            Xopt\n________________________________\nVersion: {__version__}\nData size: {self.n_data}\nConfig as YAML:\n{yaml.dump(config)}\n\"\"\"\n</code></pre>"},{"location":"api/xopt/#xopt.Xopt.add_data","title":"<code>add_data(new_data)</code>","text":"<p>Concatenate new data to internal dataframe, and also adds this data to the generator.</p> Source code in <code>xopt/base.py</code> <pre><code>def add_data(self, new_data: pd.DataFrame):\n\"\"\"\n    Concatenate new data to internal dataframe,\n    and also adds this data to the generator.\n    \"\"\"\n    logger.debug(f\"Adding {len(new_data)} new data to internal dataframes\")\n\n    # Set internal dataframe.\n    if self.data is not None:\n        new_data = pd.DataFrame(new_data, copy=True)  # copy for reindexing\n        new_data.index = np.arange(\n            len(self.data) + 1, len(self.data) + len(new_data) + 1\n        )\n\n        self.data = pd.concat([self.data, new_data], axis=0)\n    else:\n        self.data = new_data\n    self.generator.add_data(new_data)\n</code></pre>"},{"location":"api/xopt/#xopt.Xopt.dict","title":"<code>dict(**kwargs)</code>","text":"<p>handle custom dict generation</p> Source code in <code>xopt/base.py</code> <pre><code>def dict(self, **kwargs) -&gt; Dict:\n\"\"\"handle custom dict generation\"\"\"\n    result = super().model_dump(**kwargs)\n    result[\"generator\"] = {\"name\": self.generator.name} | result[\"generator\"]\n    return result\n</code></pre>"},{"location":"api/xopt/#xopt.Xopt.dump_state","title":"<code>dump_state(**kwargs)</code>","text":"<p>dump data to file</p> Source code in <code>xopt/base.py</code> <pre><code>def dump_state(self, **kwargs):\n\"\"\"dump data to file\"\"\"\n    if self.dump_file is not None:\n        output = json.loads(self.json(serialize_torch=self.serialize_torch,\n                                      serialize_inline=self.serialize_inline,\n                                      **kwargs))\n        with open(self.dump_file, \"w\") as f:\n            yaml.dump(output, f)\n        logger.debug(f\"Dumped state to YAML file: {self.dump_file}\")\n</code></pre>"},{"location":"api/xopt/#xopt.Xopt.evaluate_data","title":"<code>evaluate_data(input_data)</code>","text":"<p>Evaluate data using the evaluator and wait for results. Adds results to the internal dataframe.</p> Source code in <code>xopt/base.py</code> <pre><code>def evaluate_data(\n    self,\n    input_data: Union[\n        pd.DataFrame,\n        List[Dict[str, float]],\n        Dict[str, List[float]],\n        Dict[str, float],\n    ],\n) -&gt; pd.DataFrame:\n\"\"\"\n    Evaluate data using the evaluator and wait for results.\n    Adds results to the internal dataframe.\n    \"\"\"\n    # translate input data into pandas dataframes\n    if not isinstance(input_data, DataFrame):\n        try:\n            input_data = DataFrame(input_data)\n        except ValueError:\n            input_data = DataFrame(input_data, index=[0])\n\n    logger.debug(f\"Evaluating {len(input_data)} inputs\")\n    self.vocs.validate_input_data(input_data)\n    output_data = self.evaluator.evaluate_data(input_data)\n\n    if self.strict:\n        validate_outputs(output_data)\n    new_data = pd.concat([input_data, output_data], axis=1)\n\n    # explode any list like results if all of the output names exist\n    new_data = explode_all_columns(new_data)\n\n    self.add_data(new_data)\n\n    # dump data to file if specified\n    self.dump_state()\n\n    return new_data\n</code></pre>"},{"location":"api/xopt/#xopt.Xopt.json","title":"<code>json(**kwargs)</code>","text":"<p>handle custom serialization of generators and dataframes</p> Source code in <code>xopt/base.py</code> <pre><code>def json(self, **kwargs) -&gt; str:\n\"\"\"handle custom serialization of generators and dataframes\"\"\"\n    result = super().to_json(**kwargs)\n    dict_result = json.loads(result)\n    dict_result[\"generator\"] = {\"name\": self.generator.name} | dict_result[\n        \"generator\"\n    ]\n    dict_result[\"data\"] = (\n        json.loads(self.data.to_json()) if self.data is not None else None\n    )\n\n    # TODO: implement version checking\n    # dict_result[\"xopt_version\"] = __version__\n\n    return json.dumps(dict_result)\n</code></pre>"},{"location":"api/xopt/#xopt.Xopt.random_evaluate","title":"<code>random_evaluate(n_samples=1, seed=None, **kwargs)</code>","text":"<p>Convenience method to generate random inputs using vocs and evaluate them (adding data to Xopt object and generator).</p> Source code in <code>xopt/base.py</code> <pre><code>def random_evaluate(self, n_samples=1, seed=None, **kwargs):\n\"\"\"\n    Convenience method to generate random inputs using vocs\n    and evaluate them (adding data to Xopt object and generator).\n    \"\"\"\n    random_inputs = self.vocs.random_inputs(n_samples, seed=seed, **kwargs)\n    result = self.evaluate_data(random_inputs)\n    return result\n</code></pre>"},{"location":"api/xopt/#xopt.Xopt.run","title":"<code>run()</code>","text":"<p>run until either max_evaluations is reached or the generator is done</p> Source code in <code>xopt/base.py</code> <pre><code>def run(self):\n\"\"\"run until either max_evaluations is reached or the generator is\n    done\"\"\"\n    while not self.generator.is_done:\n        # Stopping criteria\n        if self.max_evaluations is not None:\n            if self.n_data &gt;= self.max_evaluations:\n                logger.info(\n                    \"Xopt is done. \"\n                    f\"Max evaluations {self.max_evaluations} reached.\"\n                )\n                break\n\n        self.step()\n</code></pre>"},{"location":"api/xopt/#xopt.Xopt.step","title":"<code>step()</code>","text":"<p>run one optimization cycle</p> <ul> <li>determine the number of candidates to request from the generator</li> <li>pass candidate request to generator</li> <li>submit candidates to evaluator</li> <li>wait until all (asynch == False) or at least one (asynch == True) evaluation     is finished</li> <li>update data storage and generator data storage (if applicable)</li> </ul> Source code in <code>xopt/base.py</code> <pre><code>def step(self):\n\"\"\"\n    run one optimization cycle\n\n    - determine the number of candidates to request from the generator\n    - pass candidate request to generator\n    - submit candidates to evaluator\n    - wait until all (asynch == False) or at least one (asynch == True) evaluation\n        is finished\n    - update data storage and generator data storage (if applicable)\n\n    \"\"\"\n    logger.info(\"Running Xopt step\")\n\n    # get number of candidates to generate\n    n_generate = self.evaluator.max_workers\n\n    # generate samples and submit to evaluator\n    logger.debug(f\"Generating {n_generate} candidates\")\n    new_samples = self.generator.generate(n_generate)\n\n    # Evaluate data\n    self.evaluate_data(new_samples)\n</code></pre>"},{"location":"api/generators/bayesian/","title":"Bayesian generators","text":"<p>             Bases: <code>Generator</code>, <code>ABC</code></p> Source code in <code>xopt/generators/bayesian/bayesian_generator.py</code> <pre><code>class BayesianGenerator(Generator, ABC):\n    name = \"base_bayesian_generator\"\n    model: Optional[Model] = Field(\n        None, description=\"botorch model used by the generator to perform optimization\"\n    )\n    n_monte_carlo_samples: int = Field(\n        128, description=\"number of monte carlo samples to use\"\n    )\n    turbo_controller: SerializeAsAny[Optional[TurboController]] = Field(\n        default=None, description=\"turbo controller for trust-region BO\"\n    )\n    use_cuda: bool = Field(False, description=\"flag to enable cuda usage if available\")\n    gp_constructor: SerializeAsAny[ModelConstructor] = Field(\n        StandardModelConstructor(), description=\"constructor used to generate model\"\n    )\n    numerical_optimizer: SerializeAsAny[NumericalOptimizer] = Field(\n        LBFGSOptimizer(),\n        description=\"optimizer used to optimize the acquisition \" \"function\",\n    )\n    max_travel_distances: Optional[List[float]] = Field(\n        None,\n        description=\"limits for travel distance between points in normalized space\",\n    )\n    fixed_features: Optional[Dict[str, float]] = Field(\n        None, description=\"fixed features used in Bayesian optimization\"\n    )\n    computation_time: Optional[pd.DataFrame] = Field(\n        None,\n        description=\"data frame tracking computation time in seconds\",\n    )\n    n_candidates: int = 1\n\n    @field_validator(\"model\",  mode='before')\n    def validate_torch_modules(cls, v):\n        if isinstance(v, str):\n            if v.startswith('base64:'):\n                v = decode_torch_module(v)\n            elif os.path.exists(v):\n                v = torch.load(v)\n        return v\n\n    @field_validator(\"gp_constructor\", mode='before')\n    def validate_gp_constructor(cls, value):\n        print(f'Verifying model {value}')\n        constructor_dict = {\"standard\": StandardModelConstructor}\n        if value is None:\n            value = StandardModelConstructor()\n        elif isinstance(value, ModelConstructor):\n            value = value\n        elif isinstance(value, str):\n            if value in constructor_dict:\n                value = constructor_dict[value]()\n            else:\n                raise ValueError(f\"{value} not found\")\n        elif isinstance(value, dict):\n            name = value.pop(\"name\")\n            if name in constructor_dict:\n                value = constructor_dict[name](**value)\n            else:\n                raise ValueError(f\"{value} not found\")\n\n        return value\n\n    @field_validator(\"numerical_optimizer\", mode='before')\n    def validate_numerical_optimizer(cls, value):\n        optimizer_dict = {\"grid\": GridOptimizer, \"LBFGS\": LBFGSOptimizer}\n        if value is None:\n            value = LBFGSOptimizer()\n        elif isinstance(value, NumericalOptimizer):\n            pass\n        elif isinstance(value, str):\n            if value in optimizer_dict:\n                value = optimizer_dict[value]()\n            else:\n                raise ValueError(f\"{value} not found\")\n        elif isinstance(value, dict):\n            name = value.pop(\"name\")\n            if name in optimizer_dict:\n                value = optimizer_dict[name](**value)\n            else:\n                raise ValueError(f\"{value} not found\")\n        return value\n\n    @field_validator(\"turbo_controller\", mode='before')\n    def validate_turbo_controller(cls, value, info: FieldValidationInfo):\n\"\"\"note default behavior is no use of turbo\"\"\"\n        optimizer_dict = {\n            \"optimize\": OptimizeTurboController,\n            \"safety\": SafetyTurboController,\n        }\n        if isinstance(value, TurboController):\n            pass\n        elif isinstance(value, str):\n            # create turbo controller from string input\n            if value in optimizer_dict:\n                value = optimizer_dict[value](info.data[\"vocs\"])\n            else:\n                raise ValueError(\n                    f\"{value} not found, available values are \"\n                    f\"{optimizer_dict.keys()}\"\n                )\n        elif isinstance(value, dict):\n            # create turbo controller from dict input\n            if \"name\" not in value:\n                raise ValueError(\"turbo input dict needs to have a `name` attribute\")\n            name = value.pop(\"name\")\n            if name in optimizer_dict:\n                value = optimizer_dict[name](vocs=info.data[\"vocs\"], **value)\n            else:\n                raise ValueError(\n                    f\"{value} not found, available values are \"\n                    f\"{optimizer_dict.keys()}\"\n                )\n        return value\n\n    @field_validator(\"computation_time\", mode='before')\n    def validate_computation_time(cls, value):\n        if isinstance(value, dict):\n            value = pd.DataFrame(value)\n\n        return value\n\n    def add_data(self, new_data: pd.DataFrame):\n        self.data = pd.concat([self.data, new_data], axis=0)\n\n    def generate(self, n_candidates: int) -&gt; list[dict]:\n        self.n_candidates = n_candidates\n        if n_candidates &gt; 1 and not self.supports_batch_generation:\n            raise NotImplementedError(\n                \"This Bayesian algorithm does not currently support parallel candidate \"\n                \"generation\"\n            )\n\n        # if no data exists raise error\n        if self.data is None:\n            raise RuntimeError(\n                \"no data contained in generator, call `add_data` \"\n                \"method to add data, see also `Xopt.random_evaluate()`\"\n            )\n\n        else:\n            # dict to track runtimes\n            timing_results = {}\n\n            # update internal model with internal data\n            start_time = time.perf_counter()\n            model = self.train_model(self.data)\n            timing_results[\"training\"] = time.perf_counter() - start_time\n\n            # propose candidates given model\n            start_time = time.perf_counter()\n            candidates = self.propose_candidates(model, n_candidates=n_candidates)\n            timing_results[\"acquisition_optimization\"] = (\n                time.perf_counter() - start_time\n            )\n\n            # post process candidates\n            result = self._process_candidates(candidates)\n\n            # append timing results to dataframe (if it exists)\n            if self.computation_time is not None:\n                self.computation_time = pd.concat(\n                    (\n                        self.computation_time,\n                        pd.DataFrame(timing_results, index=[0]),\n                    ),\n                    ignore_index=True,\n                )\n            else:\n                self.computation_time = pd.DataFrame(timing_results, index=[0])\n\n            return result.to_dict(\"records\")\n\n    def train_model(self, data: pd.DataFrame = None, update_internal=True) -&gt; Module:\n\"\"\"\n        Returns a ModelListGP containing independent models for the objectives and\n        constraints\n\n        \"\"\"\n        if data is None:\n            data = self.data\n        if data.empty:\n            raise ValueError(\"no data available to build model\")\n\n        # get input bounds\n        variable_bounds = deepcopy(self.vocs.variables)\n\n        # add fixed feature bounds if requested\n        if self.fixed_features is not None:\n            # get bounds for each fixed_feature (vocs bounds take precedent)\n            for key in self.fixed_features:\n                if key not in variable_bounds:\n                    f_data = data[key]\n                    bounds = [f_data.min(), f_data.max()]\n                    if bounds[1] - bounds[0] &lt; 1e-8:\n                        bounds[1] = bounds[0] + 1e-8\n                    variable_bounds[key] = bounds\n\n        _model = self.gp_constructor.build_model(\n            self.model_input_names,\n            self.vocs.output_names,\n            data,\n            {name: variable_bounds[name] for name in self.model_input_names},\n            **self._tkwargs,\n        )\n\n        if update_internal:\n            self.model = _model\n        return _model\n\n    def propose_candidates(self, model, n_candidates=1):\n\"\"\"\n        given a GP model, propose candidates by numerically optimizing the\n        acquisition function\n\n        \"\"\"\n        # update TurBO state if used with the last `n_candidates` points\n        if self.turbo_controller is not None:\n            self.turbo_controller.update_state(self.data, n_candidates)\n\n        # calculate optimization bounds\n        bounds = self._get_optimization_bounds()\n\n        # get acquisition function\n        acq_funct = self.get_acquisition(model)\n\n        # get candidates\n        candidates = self.numerical_optimizer.optimize(acq_funct, bounds, n_candidates)\n        return candidates\n\n    def get_input_data(self, data):\n        return torch.tensor(data[self.model_input_names].to_numpy(), **self._tkwargs)\n\n    def get_acquisition(self, model):\n\"\"\"\n        Returns a function that can be used to evaluate the acquisition function\n        \"\"\"\n        if model is None:\n            raise ValueError(\"model cannot be None\")\n\n        # get base acquisition function\n        acq = self._get_acquisition(model)\n\n        try:\n            sampler = acq.sampler\n        except AttributeError:\n            sampler = SobolQMCNormalSampler(\n                sample_shape=torch.Size([self.n_monte_carlo_samples])\n            )\n\n        # apply constraints if specified in vocs\n        if len(self.vocs.constraints):\n            acq = ConstrainedMCAcquisitionFunction(\n                model, acq, self._get_constraint_callables(), sampler=sampler\n            )\n\n        # apply fixed features if specified in the generator\n        if self.fixed_features is not None:\n            # get input dim\n            dim = len(self.model_input_names)\n            columns = []\n            values = []\n            for name, value in self.fixed_features.items():\n                columns += [self.model_input_names.index(name)]\n                values += [value]\n\n            acq = FixedFeatureAcquisitionFunction(\n                acq_function=acq, d=dim, columns=columns, values=values\n            )\n\n        return acq\n\n    def get_optimum(self):\n\"\"\"select the best point(s) given by the\n        model using the Posterior mean\"\"\"\n        c_posterior_mean = ConstrainedMCAcquisitionFunction(\n            self.model,\n            qUpperConfidenceBound(\n                model=self.model, beta=0.0, objective=self._get_objective()\n            ),\n            self._get_constraint_callables(),\n        )\n\n        result = self.numerical_optimizer.optimize(\n            c_posterior_mean, self._get_bounds(), 1\n        )\n\n        return self._process_candidates(result)\n\n    def _process_candidates(self, candidates: Tensor):\n\"\"\"process pytorch candidates from optimizing the acquisition function\"\"\"\n        logger.debug(\"Best candidate from optimize\", candidates)\n\n        if self.fixed_features is not None:\n            results = pd.DataFrame(\n                candidates.detach().cpu().numpy(), columns=self._candidate_names\n            )\n            for name, val in self.fixed_features.items():\n                results[name] = val\n\n        else:\n            results = self.vocs.convert_numpy_to_inputs(\n                candidates.detach().cpu().numpy(), include_constants=False\n            )\n\n        return results\n\n    def _get_sampler(self, model):\n        input_data = self.get_input_data(self.data)\n        sampler = get_sampler(\n            model.posterior(input_data),\n            sample_shape=torch.Size([self.n_monte_carlo_samples]),\n        )\n        return sampler\n\n    @abstractmethod\n    def _get_acquisition(self, model):\n        pass\n\n    def _get_objective(self):\n\"\"\"return default objective (scalar objective) determined by vocs\"\"\"\n        return create_mc_objective(self.vocs, self._tkwargs)\n\n    def _get_constraint_callables(self):\n\"\"\"return default objective (scalar objective) determined by vocs\"\"\"\n        constraint_callables = create_constraint_callables(self.vocs)\n        if len(constraint_callables) == 0:\n            constraint_callables = None\n        return constraint_callables\n\n    @property\n    def _tkwargs(self):\n        # set device and data type for generator\n        device = \"cpu\"\n        if self.use_cuda:\n            if torch.cuda.is_available():\n                device = \"cuda\"\n            else:\n                warnings.warn(\n                    \"Cuda requested in generator options but not found on \"\n                    \"machine! Using CPU instead\"\n                )\n\n        return {\"dtype\": torch.double, \"device\": device}\n\n    @property\n    def model_input_names(self):\n\"\"\"variable names corresponding to trained model\"\"\"\n        variable_names = self.vocs.variable_names\n        if self.fixed_features is not None:\n            for name, val in self.fixed_features.items():\n                if name not in variable_names:\n                    variable_names += [name]\n        return variable_names\n\n    @property\n    def _candidate_names(self):\n\"\"\"variable names corresponding to generated candidates\"\"\"\n        variable_names = self.vocs.variable_names\n        if self.fixed_features is not None:\n            for name in self.fixed_features:\n                if name in variable_names:\n                    variable_names.remove(name)\n        return variable_names\n\n    def _get_bounds(self):\n\"\"\"convert bounds from vocs to torch tensors\"\"\"\n        return torch.tensor(self.vocs.bounds, **self._tkwargs)\n\n    def _get_optimization_bounds(self):\n\"\"\"\n        gets optimization bounds based on the union of several domains\n        - if use_turbo is True include trust region\n        - if max_travel_distances is not None limit max travel distance\n\n        \"\"\"\n        bounds = deepcopy(self._get_bounds())\n\n        # if specified modify bounds to limit maximum travel distances\n        if self.max_travel_distances is not None:\n            max_travel_bounds = self._get_max_travel_distances_region(bounds)\n            bounds = rectilinear_domain_union(bounds, max_travel_bounds)\n\n        # if using turbo, update turbo state and set bounds according to turbo state\n        if self.turbo_controller is not None:\n            # set the best value\n            turbo_bounds = self.turbo_controller.get_trust_region(self.model)\n            bounds = rectilinear_domain_union(bounds, turbo_bounds)\n\n        # if fixed features key is in vocs then we need to remove the bounds\n        # associated with that key\n        if self.fixed_features is not None:\n            # grab variable name indices that are NOT in fixed features\n            indicies = []\n            for idx, name in enumerate(self.vocs.variable_names):\n                if name not in self.fixed_features:\n                    indicies += [idx]\n\n            # grab indexed bounds\n            bounds = bounds.T[indicies].T\n\n        return bounds\n\n    def _get_max_travel_distances_region(self, bounds):\n\"\"\"get region based on max travel distances and last observation\"\"\"\n        if len(self.max_travel_distances) != bounds.shape[-1]:\n            raise ValueError(\n                f\"length of max_travel_distances must match the number of \"\n                f\"variables {bounds.shape[-1]}\"\n            )\n\n        # get last point\n        if self.data is None:\n            raise ValueError(\n                \"No data exists to specify max_travel_distances \"\n                \"from, add data first to use during BO\"\n            )\n        last_point = torch.tensor(\n            self.data[self.vocs.variable_names].iloc[-1].to_numpy(), **self._tkwargs\n        )\n\n        # bound lengths based on vocs for normalization\n        lengths = self.vocs.bounds[1, :] - self.vocs.bounds[0, :]\n\n        # get maximum travel distances\n        max_travel_distances = (\n            torch.tensor(self.max_travel_distances, **self._tkwargs) * lengths\n        )\n        max_travel_bounds = torch.stack(\n            (last_point - max_travel_distances, last_point + max_travel_distances)\n        )\n\n        return max_travel_bounds\n</code></pre> <p>             Bases: <code>BayesianGenerator</code></p> Source code in <code>xopt/generators/bayesian/bayesian_exploration.py</code> <pre><code>class BayesianExplorationGenerator(BayesianGenerator):\n    name = \"bayesian_exploration\"\n    supports_batch_generation = True\n\n    def _get_acquisition(self, model):\n        sampler = self._get_sampler(model)\n        qPV = qPosteriorVariance(\n            model,\n            sampler=sampler,\n            objective=self._get_objective(),\n        )\n\n        return qPV\n\n    def _get_objective(self):\n\"\"\"return exploration objective, which only captures the output of the first\n        model output\"\"\"\n\n        return create_exploration_objective(self.vocs, self._tkwargs)\n</code></pre> <p>             Bases: <code>MultiObjectiveBayesianGenerator</code></p> Source code in <code>xopt/generators/bayesian/mobo.py</code> <pre><code>class MOBOGenerator(MultiObjectiveBayesianGenerator):\n    name = \"mobo\"\n    __doc__ = \"\"\"Implements Multi-Objective Bayesian Optimization using the Expected\n            Hypervolume Improvement acquisition function\"\"\"\n\n    def _get_objective(self):\n        return create_mobo_objective(self.vocs, self._tkwargs)\n\n    def get_acquisition(self, model):\n\"\"\"\n        Returns a function that can be used to evaluate the acquisition function\n        \"\"\"\n        if model is None:\n            raise ValueError(\"model cannot be None\")\n\n        # get base acquisition function\n        acq = self._get_acquisition(model)\n        return acq\n\n    def _get_acquisition(self, model):\n        inputs = self.get_input_data(self.data)\n        sampler = self._get_sampler(model)\n\n        # fix problem with qNEHVI interpretation with constraints\n        acq = qNoisyExpectedHypervolumeImprovement(\n            model,\n            X_baseline=inputs,\n            constraints=self._get_constraint_callables(),\n            ref_point=self.torch_reference_point,\n            sampler=sampler,\n            objective=self._get_objective(),\n            cache_root=False,\n            prune_baseline=True,\n        )\n\n        return acq\n</code></pre> <p>             Bases: <code>BayesianGenerator</code></p> Source code in <code>xopt/generators/bayesian/upper_confidence_bound.py</code> <pre><code>class UpperConfidenceBoundGenerator(BayesianGenerator):\n    name = \"upper_confidence_bound\"\n    beta: float = Field(2.0, description=\"Beta parameter for UCB optimization\")\n    supports_batch_generation = True\n    __doc__ = \"\"\"Implements Bayesian Optimization using the Upper Confidence Bound\n    acquisition function\"\"\"\n\n    @field_validator(\"vocs\", mode='before')\n    def validate_vocs_without_constraints(cls, v):\n        if v.constraints:\n            warnings.warn(\n                f\"Using {cls.__name__} with constraints may lead to numerical issues if the base acquisition \"\n                f\"function has negative values.\"\n            )\n        return v\n\n    def _get_acquisition(self, model):\n        if self.n_candidates &gt; 1:\n            # MC sampling for generating multiple candidate points\n            sampler = self._get_sampler(model)\n            acq = qUpperConfidenceBound(\n                model,\n                sampler=sampler,\n                objective=self._get_objective(),\n                beta=self.beta,\n            )\n        else:\n            # analytic acquisition function for single candidate generation\n            weights = torch.zeros(self.vocs.n_outputs).to(**self._tkwargs)\n            weights = set_botorch_weights(weights, self.vocs)\n            posterior_transform = ScalarizedPosteriorTransform(weights)\n            acq = UpperConfidenceBound(\n                model, beta=self.beta, posterior_transform=posterior_transform\n            )\n\n        return acq\n</code></pre>"},{"location":"api/generators/bayesian/#xopt.generators.bayesian.bayesian_generator.BayesianGenerator.model_input_names","title":"<code>model_input_names</code>  <code>property</code>","text":"<p>variable names corresponding to trained model</p>"},{"location":"api/generators/bayesian/#xopt.generators.bayesian.bayesian_generator.BayesianGenerator.get_acquisition","title":"<code>get_acquisition(model)</code>","text":"<p>Returns a function that can be used to evaluate the acquisition function</p> Source code in <code>xopt/generators/bayesian/bayesian_generator.py</code> <pre><code>def get_acquisition(self, model):\n\"\"\"\n    Returns a function that can be used to evaluate the acquisition function\n    \"\"\"\n    if model is None:\n        raise ValueError(\"model cannot be None\")\n\n    # get base acquisition function\n    acq = self._get_acquisition(model)\n\n    try:\n        sampler = acq.sampler\n    except AttributeError:\n        sampler = SobolQMCNormalSampler(\n            sample_shape=torch.Size([self.n_monte_carlo_samples])\n        )\n\n    # apply constraints if specified in vocs\n    if len(self.vocs.constraints):\n        acq = ConstrainedMCAcquisitionFunction(\n            model, acq, self._get_constraint_callables(), sampler=sampler\n        )\n\n    # apply fixed features if specified in the generator\n    if self.fixed_features is not None:\n        # get input dim\n        dim = len(self.model_input_names)\n        columns = []\n        values = []\n        for name, value in self.fixed_features.items():\n            columns += [self.model_input_names.index(name)]\n            values += [value]\n\n        acq = FixedFeatureAcquisitionFunction(\n            acq_function=acq, d=dim, columns=columns, values=values\n        )\n\n    return acq\n</code></pre>"},{"location":"api/generators/bayesian/#xopt.generators.bayesian.bayesian_generator.BayesianGenerator.get_optimum","title":"<code>get_optimum()</code>","text":"<p>select the best point(s) given by the model using the Posterior mean</p> Source code in <code>xopt/generators/bayesian/bayesian_generator.py</code> <pre><code>def get_optimum(self):\n\"\"\"select the best point(s) given by the\n    model using the Posterior mean\"\"\"\n    c_posterior_mean = ConstrainedMCAcquisitionFunction(\n        self.model,\n        qUpperConfidenceBound(\n            model=self.model, beta=0.0, objective=self._get_objective()\n        ),\n        self._get_constraint_callables(),\n    )\n\n    result = self.numerical_optimizer.optimize(\n        c_posterior_mean, self._get_bounds(), 1\n    )\n\n    return self._process_candidates(result)\n</code></pre>"},{"location":"api/generators/bayesian/#xopt.generators.bayesian.bayesian_generator.BayesianGenerator.propose_candidates","title":"<code>propose_candidates(model, n_candidates=1)</code>","text":"<p>given a GP model, propose candidates by numerically optimizing the acquisition function</p> Source code in <code>xopt/generators/bayesian/bayesian_generator.py</code> <pre><code>def propose_candidates(self, model, n_candidates=1):\n\"\"\"\n    given a GP model, propose candidates by numerically optimizing the\n    acquisition function\n\n    \"\"\"\n    # update TurBO state if used with the last `n_candidates` points\n    if self.turbo_controller is not None:\n        self.turbo_controller.update_state(self.data, n_candidates)\n\n    # calculate optimization bounds\n    bounds = self._get_optimization_bounds()\n\n    # get acquisition function\n    acq_funct = self.get_acquisition(model)\n\n    # get candidates\n    candidates = self.numerical_optimizer.optimize(acq_funct, bounds, n_candidates)\n    return candidates\n</code></pre>"},{"location":"api/generators/bayesian/#xopt.generators.bayesian.bayesian_generator.BayesianGenerator.train_model","title":"<code>train_model(data=None, update_internal=True)</code>","text":"<p>Returns a ModelListGP containing independent models for the objectives and constraints</p> Source code in <code>xopt/generators/bayesian/bayesian_generator.py</code> <pre><code>def train_model(self, data: pd.DataFrame = None, update_internal=True) -&gt; Module:\n\"\"\"\n    Returns a ModelListGP containing independent models for the objectives and\n    constraints\n\n    \"\"\"\n    if data is None:\n        data = self.data\n    if data.empty:\n        raise ValueError(\"no data available to build model\")\n\n    # get input bounds\n    variable_bounds = deepcopy(self.vocs.variables)\n\n    # add fixed feature bounds if requested\n    if self.fixed_features is not None:\n        # get bounds for each fixed_feature (vocs bounds take precedent)\n        for key in self.fixed_features:\n            if key not in variable_bounds:\n                f_data = data[key]\n                bounds = [f_data.min(), f_data.max()]\n                if bounds[1] - bounds[0] &lt; 1e-8:\n                    bounds[1] = bounds[0] + 1e-8\n                variable_bounds[key] = bounds\n\n    _model = self.gp_constructor.build_model(\n        self.model_input_names,\n        self.vocs.output_names,\n        data,\n        {name: variable_bounds[name] for name in self.model_input_names},\n        **self._tkwargs,\n    )\n\n    if update_internal:\n        self.model = _model\n    return _model\n</code></pre>"},{"location":"api/generators/bayesian/#xopt.generators.bayesian.bayesian_generator.BayesianGenerator.validate_turbo_controller","title":"<code>validate_turbo_controller(value, info)</code>","text":"<p>note default behavior is no use of turbo</p> Source code in <code>xopt/generators/bayesian/bayesian_generator.py</code> <pre><code>@field_validator(\"turbo_controller\", mode='before')\ndef validate_turbo_controller(cls, value, info: FieldValidationInfo):\n\"\"\"note default behavior is no use of turbo\"\"\"\n    optimizer_dict = {\n        \"optimize\": OptimizeTurboController,\n        \"safety\": SafetyTurboController,\n    }\n    if isinstance(value, TurboController):\n        pass\n    elif isinstance(value, str):\n        # create turbo controller from string input\n        if value in optimizer_dict:\n            value = optimizer_dict[value](info.data[\"vocs\"])\n        else:\n            raise ValueError(\n                f\"{value} not found, available values are \"\n                f\"{optimizer_dict.keys()}\"\n            )\n    elif isinstance(value, dict):\n        # create turbo controller from dict input\n        if \"name\" not in value:\n            raise ValueError(\"turbo input dict needs to have a `name` attribute\")\n        name = value.pop(\"name\")\n        if name in optimizer_dict:\n            value = optimizer_dict[name](vocs=info.data[\"vocs\"], **value)\n        else:\n            raise ValueError(\n                f\"{value} not found, available values are \"\n                f\"{optimizer_dict.keys()}\"\n            )\n    return value\n</code></pre>"},{"location":"api/generators/bayesian/#xopt.generators.bayesian.mobo.MOBOGenerator.get_acquisition","title":"<code>get_acquisition(model)</code>","text":"<p>Returns a function that can be used to evaluate the acquisition function</p> Source code in <code>xopt/generators/bayesian/mobo.py</code> <pre><code>def get_acquisition(self, model):\n\"\"\"\n    Returns a function that can be used to evaluate the acquisition function\n    \"\"\"\n    if model is None:\n        raise ValueError(\"model cannot be None\")\n\n    # get base acquisition function\n    acq = self._get_acquisition(model)\n    return acq\n</code></pre>"},{"location":"api/generators/genetic/","title":"Genetic generators","text":"<p>             Bases: <code>Generator</code></p> Source code in <code>xopt/generators/ga/cnsga.py</code> <pre><code>class CNSGAGenerator(Generator):\n    name = \"cnsga\"\n    supports_multi_objective = True\n    population_size: int = Field(64, description=\"Population size\")\n    crossover_probability: confloat(ge=0, le=1) = Field(\n        0.9, description=\"Crossover probability\"\n    )\n    mutation_probability: confloat(ge=0, le=1) = Field(\n        1.0, description=\"Mutation probability\"\n    )\n    population_file: str = Field(\n        None, description=\"Population file to load (CSV format)\"\n    )\n    output_path: str = Field(None, description=\"Output path for population files\")\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        # Internal data structures\n        self.children = (\n            []\n        )  # list of unevaluated inputs. This should be a list of dicts.\n        self.population = None  # The latest population data (fully evaluated)\n        self.offspring = None  # Newly evaluated data, but not yet added to population\n\n        self._loaded_population = (\n            None  # use these to generate children until the first pop is made\n        )\n\n        # DEAP toolbox (internal)\n        self.toolbox = cnsga_toolbox(self.vocs, selection=\"auto\")\n\n        if self.population_file is not None:\n            self.load_population_csv(self.population_file)\n\n        if self.output_path is not None:\n            assert os.path.isdir(self.output_path), \"Output directory does not exist\"\n\n        # if data is not None:\n        #    self.population = cnsga_select(data, n_pop, vocs, self.toolbox)\n\n    def old__init__(\n        self,\n        vocs,\n        *,\n        n_pop,\n        data=None,\n        crossover_probability=0.9,\n        mutation_probability=1.0,\n    ):\n        self._vocs = vocs  # TODO: use proper options\n        self.n_pop = n_pop\n        self.crossover_probability = crossover_probability\n        self.mutation_probability = mutation_probability\n\n        # Internal data structures\n        self.children = []  # unevaluated inputs. This should be a list of dicts.\n        self.population = None  # The latest population (fully evaluated)\n        self.offspring = None  # Newly evaluated data, but not yet added to population\n\n        # DEAP toolbox (internal)\n        self.toolbox = cnsga_toolbox(vocs, selection=\"auto\")\n\n        if data is not None:\n            self.population = cnsga_select(data, n_pop, vocs, self.toolbox)\n\n    def create_children(self) -&gt; List[Dict]:\n        # No population, so create random children\n        if self.population is None:\n            # Special case when pop is loaded from file\n            if self._loaded_population is None:\n                return self.vocs.random_inputs(self.n_pop, include_constants=False)\n            else:\n                pop = self._loaded_population\n        else:\n            pop = self.population\n\n        # Use population to create children\n        inputs = cnsga_variation(\n            pop,\n            self.vocs,\n            self.toolbox,\n            crossover_probability=self.crossover_probability,\n            mutation_probability=self.mutation_probability,\n        )\n        return inputs.to_dict(orient=\"records\")\n\n    def add_data(self, new_data: pd.DataFrame):\n        self.offspring = pd.concat([self.offspring, new_data])\n\n        # Next generation\n        if len(self.offspring) &gt;= self.n_pop:\n            candidates = pd.concat([self.population, self.offspring])\n            self.population = cnsga_select(\n                candidates, self.n_pop, self.vocs, self.toolbox\n            )\n\n            if self.output_path is not None:\n                self.write_offspring()\n                self.write_population()\n\n            self.children = []  # reset children\n            self.offspring = None  # reset offspring\n\n    def generate(self, n_candidates) -&gt; list[dict]:\n\"\"\"\n        generate `n_candidates` candidates\n\n        \"\"\"\n\n        # Make sure we have enough children to fulfill the request\n        while len(self.children) &lt; n_candidates:\n            self.children.extend(self.create_children())\n\n        return [self.children.pop() for _ in range(n_candidates)]\n\n    def write_offspring(self, filename=None):\n\"\"\"\n        Write the current offspring to a CSV file.\n\n        Similar to write_population\n        \"\"\"\n        if self.offspring is None:\n            logger.warning(\"No offspring to write\")\n            return\n\n        if filename is None:\n            filename = f\"{self.name}_offspring_{xopt.utils.isotime(include_microseconds=True)}.csv\"\n            filename = os.path.join(self.output_path, filename)\n\n        self.offspring.to_csv(filename, index_label=\"xopt_index\")\n\n    def write_population(self, filename=None):\n\"\"\"\n        Write the current population to a CSV file.\n\n        Similar to write_offspring\n        \"\"\"\n        if self.population is None:\n            logger.warning(\"No population to write\")\n            return\n\n        if filename is None:\n            filename = f\"{self.name}_population_{xopt.utils.isotime(include_microseconds=True)}.csv\"\n            filename = os.path.join(self.output_path, filename)\n\n        self.population.to_csv(filename, index_label=\"xopt_index\")\n\n    def load_population_csv(self, filename):\n\"\"\"\n        Read a population from a CSV file.\n        These will be reverted back to children for re-evaluation.\n        \"\"\"\n        pop = pd.read_csv(filename, index_col=\"xopt_index\")\n        self._loaded_population = pop\n        # This is a list of dicts\n        self.children = self.vocs.convert_dataframe_to_inputs(\n            pop[self.vocs.variable_names], include_constants=False\n        ).to_dict(orient=\"records\")\n        logger.info(f\"Loaded population of len {len(pop)} from file: {filename}\")\n\n    @property\n    def n_pop(self):\n\"\"\"\n        Convenience name for `options.population_size`\n        \"\"\"\n        return self.population_size\n</code></pre>"},{"location":"api/generators/genetic/#xopt.generators.ga.cnsga.CNSGAGenerator.n_pop","title":"<code>n_pop</code>  <code>property</code>","text":"<p>Convenience name for <code>options.population_size</code></p>"},{"location":"api/generators/genetic/#xopt.generators.ga.cnsga.CNSGAGenerator.generate","title":"<code>generate(n_candidates)</code>","text":"<p>generate <code>n_candidates</code> candidates</p> Source code in <code>xopt/generators/ga/cnsga.py</code> <pre><code>def generate(self, n_candidates) -&gt; list[dict]:\n\"\"\"\n    generate `n_candidates` candidates\n\n    \"\"\"\n\n    # Make sure we have enough children to fulfill the request\n    while len(self.children) &lt; n_candidates:\n        self.children.extend(self.create_children())\n\n    return [self.children.pop() for _ in range(n_candidates)]\n</code></pre>"},{"location":"api/generators/genetic/#xopt.generators.ga.cnsga.CNSGAGenerator.load_population_csv","title":"<code>load_population_csv(filename)</code>","text":"<p>Read a population from a CSV file. These will be reverted back to children for re-evaluation.</p> Source code in <code>xopt/generators/ga/cnsga.py</code> <pre><code>def load_population_csv(self, filename):\n\"\"\"\n    Read a population from a CSV file.\n    These will be reverted back to children for re-evaluation.\n    \"\"\"\n    pop = pd.read_csv(filename, index_col=\"xopt_index\")\n    self._loaded_population = pop\n    # This is a list of dicts\n    self.children = self.vocs.convert_dataframe_to_inputs(\n        pop[self.vocs.variable_names], include_constants=False\n    ).to_dict(orient=\"records\")\n    logger.info(f\"Loaded population of len {len(pop)} from file: {filename}\")\n</code></pre>"},{"location":"api/generators/genetic/#xopt.generators.ga.cnsga.CNSGAGenerator.write_offspring","title":"<code>write_offspring(filename=None)</code>","text":"<p>Write the current offspring to a CSV file.</p> <p>Similar to write_population</p> Source code in <code>xopt/generators/ga/cnsga.py</code> <pre><code>def write_offspring(self, filename=None):\n\"\"\"\n    Write the current offspring to a CSV file.\n\n    Similar to write_population\n    \"\"\"\n    if self.offspring is None:\n        logger.warning(\"No offspring to write\")\n        return\n\n    if filename is None:\n        filename = f\"{self.name}_offspring_{xopt.utils.isotime(include_microseconds=True)}.csv\"\n        filename = os.path.join(self.output_path, filename)\n\n    self.offspring.to_csv(filename, index_label=\"xopt_index\")\n</code></pre>"},{"location":"api/generators/genetic/#xopt.generators.ga.cnsga.CNSGAGenerator.write_population","title":"<code>write_population(filename=None)</code>","text":"<p>Write the current population to a CSV file.</p> <p>Similar to write_offspring</p> Source code in <code>xopt/generators/ga/cnsga.py</code> <pre><code>def write_population(self, filename=None):\n\"\"\"\n    Write the current population to a CSV file.\n\n    Similar to write_offspring\n    \"\"\"\n    if self.population is None:\n        logger.warning(\"No population to write\")\n        return\n\n    if filename is None:\n        filename = f\"{self.name}_population_{xopt.utils.isotime(include_microseconds=True)}.csv\"\n        filename = os.path.join(self.output_path, filename)\n\n    self.population.to_csv(filename, index_label=\"xopt_index\")\n</code></pre>"},{"location":"api/generators/scipy/","title":"SciPy generators","text":"<p>             Bases: <code>ScipyOptimizeGenerator</code></p> <p>Nelder-Mead algorithm from SciPy in Xopt's Generator form.</p> Source code in <code>xopt/generators/scipy/neldermead.py</code> <pre><code>class NelderMeadGenerator(ScipyOptimizeGenerator):\n\"\"\"\n    Nelder-Mead algorithm from SciPy in Xopt's Generator form.\n    \"\"\"\n\n    name = \"neldermead\"\n\n    def _init_algorithm(self):\n\"\"\"\n        sets self._algorithm to the generator function (initializing it).\n        \"\"\"\n\n        if self.initial_simplex:\n            sim = np.array(\n                [self.initial_simplex[k] for k in self.vocs.variable_names]\n            ).T\n        else:\n            sim = None\n\n        self._algorithm = _neldermead_generator(  # adapted from scipy.optimize\n            self.func,  # Handled by base class\n            self.x0,  # Handled by base class\n            adaptive=self.adaptive,\n            xatol=self.xatol,\n            fatol=self.fatol,\n            initial_simplex=sim,\n            bounds=self.vocs.bounds,\n        )\n\n    @property\n    def simplex(self):\n\"\"\"\n        Returns the simplex in the current state.\n        \"\"\"\n        sim = self._state\n        return dict(zip(self.vocs.variable_names, sim.T))\n</code></pre>"},{"location":"api/generators/scipy/#xopt.generators.scipy.neldermead.NelderMeadGenerator.simplex","title":"<code>simplex</code>  <code>property</code>","text":"<p>Returns the simplex in the current state.</p>"},{"location":"examples/basic/checkpointing_and_restarts/","title":"Checkpointing and Restarts","text":"In\u00a0[1]: Copied! <pre># Import the class\nfrom xopt import Xopt\n\n# Make a proper input file.\nYAML = \"\"\"\ndump_file: dump.yml\ngenerator:\n    name: random\n\nevaluator:\n    function: xopt.resources.test_functions.tnk.evaluate_TNK\n    function_kwargs:\n        a: 999\n\nvocs:\n    variables:\n        x1: [0, 3.14159]\n        x2: [0, 3.14159]\n    objectives: {y1: MINIMIZE, y2: MINIMIZE}\n    constraints:\n        c1: [GREATER_THAN, 0]\n        c2: [LESS_THAN, 0.5]\n    constants: {a: dummy_constant}\n\n\"\"\"\n</pre> # Import the class from xopt import Xopt  # Make a proper input file. YAML = \"\"\" dump_file: dump.yml generator:     name: random  evaluator:     function: xopt.resources.test_functions.tnk.evaluate_TNK     function_kwargs:         a: 999  vocs:     variables:         x1: [0, 3.14159]         x2: [0, 3.14159]     objectives: {y1: MINIMIZE, y2: MINIMIZE}     constraints:         c1: [GREATER_THAN, 0]         c2: [LESS_THAN, 0.5]     constants: {a: dummy_constant}  \"\"\" In\u00a0[2]: Copied! <pre># create Xopt object.\nX = Xopt.from_yaml(YAML)\n\n# take 10 steps and view data\nfor _ in range(10):\n    X.step()\n\nX.data\n</pre> # create Xopt object. X = Xopt.from_yaml(YAML)  # take 10 steps and view data for _ in range(10):     X.step()  X.data Out[2]: x1 x2 y1 y2 c1 c2 xopt_runtime xopt_error 0 0.845226 1.740561 0.845226 1.740561 2.68578 1.658172 0.000078 False 2 0.032152 0.83741 0.032152 0.83741 -0.379445 0.332727 0.000054 False 3 0.568537 1.012684 0.568537 1.012684 0.381268 0.267542 0.000052 False 4 2.851359 0.673923 2.851359 0.673923 7.66851 5.559139 0.000052 False 5 2.378597 1.486794 2.378597 1.486794 6.956684 4.502889 0.000052 False 6 1.19109 0.876803 1.19109 0.876803 1.262109 0.619586 0.000053 False 7 0.969899 2.235828 0.969899 2.235828 4.843138 3.233904 0.000053 False 8 2.018167 1.653974 2.018167 1.653974 5.809715 3.636487 0.000054 False 9 2.584645 2.952354 2.584645 2.952354 14.347987 10.359787 0.000050 False 10 1.441926 2.903639 1.441926 2.903639 9.464155 6.664705 0.000050 False In\u00a0[3]: Copied! <pre>X2 = Xopt.from_file(\"dump.yml\")\nX2\n</pre> X2 = Xopt.from_file(\"dump.yml\") X2 Out[3]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 10\nConfig as YAML:\ndump_file: dump.yml\nevaluator:\n  function: xopt.resources.test_functions.tnk.evaluate_TNK\n  function_kwargs:\n    a: 999\n    raise_probability: 0\n    random_sleep: 0\n    sleep: 0\n  max_workers: 1\n  vectorized: false\ngenerator:\n  name: random\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants:\n    a: dummy_constant\n  constraints:\n    c1:\n    - GREATER_THAN\n    - 0.0\n    c2:\n    - LESS_THAN\n    - 0.5\n  objectives:\n    y1: MINIMIZE\n    y2: MINIMIZE\n  observables: []\n  variables:\n    x1:\n    - 0.0\n    - 3.14159\n    x2:\n    - 0.0\n    - 3.14159\n</pre> In\u00a0[4]: Copied! <pre>for _ in range(10):\n    X2.step()\n\nX2.data\n</pre> for _ in range(10):     X2.step()  X2.data Out[4]: c1 c2 x1 x2 xopt_error xopt_runtime y1 y2 0 2.68578 1.658172 0.845226 1.740561 False 0.000078 0.845226 1.740561 10 9.464155 6.664705 1.441926 2.903639 False 0.000050 1.441926 2.903639 2 -0.379445 0.332727 0.032152 0.83741 False 0.000054 0.032152 0.83741 3 0.381268 0.267542 0.568537 1.012684 False 0.000052 0.568537 1.012684 4 7.66851 5.559139 2.851359 0.673923 False 0.000052 2.851359 0.673923 5 6.956684 4.502889 2.378597 1.486794 False 0.000052 2.378597 1.486794 6 1.262109 0.619586 1.19109 0.876803 False 0.000053 1.19109 0.876803 7 4.843138 3.233904 0.969899 2.235828 False 0.000053 0.969899 2.235828 8 5.809715 3.636487 2.018167 1.653974 False 0.000054 2.018167 1.653974 9 14.347987 10.359787 2.584645 2.952354 False 0.000050 2.584645 2.952354 11 5.607741 3.460091 1.456913 2.09512 False 0.000056 1.456913 2.09512 12 13.69286 9.852464 2.686456 2.752082 False 0.000057 2.686456 2.752082 13 6.013294 4.196041 2.520343 0.838018 False 0.000057 2.520343 0.838018 14 3.042765 1.769393 1.735339 0.993287 False 0.000057 1.735339 0.993287 15 3.10552 1.939758 1.837444 0.888589 False 0.000055 1.837444 0.888589 16 -0.661891 0.088842 0.605791 0.221342 False 0.000055 0.605791 0.221342 17 -0.344878 0.151871 0.203399 0.752783 False 0.000053 0.203399 0.752783 18 4.832243 3.153754 1.053395 2.187456 False 0.000054 1.053395 2.187456 19 -0.820203 0.248509 0.27839 0.05346 False 0.000059 0.27839 0.05346 20 12.296356 8.705029 2.700796 2.465077 False 0.000053 2.700796 2.465077 In\u00a0[5]: Copied! <pre># clean up\n</pre> # clean up"},{"location":"examples/basic/checkpointing_and_restarts/#checkpointing-and-restarts","title":"Checkpointing and Restarts\u00b6","text":"<p>If <code>dump_file</code> is provided Xopt will save the data and the Xopt configuration in a yaml file. This can be used directly to create a new Xopt object.</p>"},{"location":"examples/basic/checkpointing_and_restarts/#checkpoints","title":"Checkpoints\u00b6","text":"<p>Since we specified a dump file Xopt will dump the data and all of the options required to create a new Xopt object that continues the run.</p>"},{"location":"examples/basic/checkpointing_and_restarts/#create-xopt-object-from-dump-file","title":"Create Xopt object from dump file\u00b6","text":""},{"location":"examples/basic/xopt_basic/","title":"Xopt basic example","text":"In\u00a0[1]: Copied! <pre># Import the class\nfrom xopt import Xopt\n</pre> # Import the class from xopt import Xopt In\u00a0[2]: Copied! <pre># Nicer plotting\n%config InlineBackend.figure_format = 'retina'\n</pre> # Nicer plotting %config InlineBackend.figure_format = 'retina' In\u00a0[3]: Copied! <pre># Make a proper input file.\nYAML = \"\"\"\nevaluator:\n    function: xopt.resources.test_functions.tnk.evaluate_TNK\n    function_kwargs:\n        a: 999\n\ngenerator:\n    name: random\n\nvocs:\n    variables:\n        x1: [0, 3.14159]\n        x2: [0, 3.14159]\n    objectives: {y1: MINIMIZE, y2: MINIMIZE}\n    constraints:\n        c1: [GREATER_THAN, 0]\n        c2: [LESS_THAN, 0.5]\n    constants: {a: dummy_constant}\n\n\"\"\"\n</pre> # Make a proper input file. YAML = \"\"\" evaluator:     function: xopt.resources.test_functions.tnk.evaluate_TNK     function_kwargs:         a: 999  generator:     name: random  vocs:     variables:         x1: [0, 3.14159]         x2: [0, 3.14159]     objectives: {y1: MINIMIZE, y2: MINIMIZE}     constraints:         c1: [GREATER_THAN, 0]         c2: [LESS_THAN, 0.5]     constants: {a: dummy_constant}  \"\"\" In\u00a0[4]: Copied! <pre># create Xopt object.\n\nX = Xopt.from_yaml(YAML)\n</pre> # create Xopt object.  X = Xopt.from_yaml(YAML) In\u00a0[5]: Copied! <pre># Convenient representation of the state.\nX\n</pre> # Convenient representation of the state. X Out[5]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: xopt.resources.test_functions.tnk.evaluate_TNK\n  function_kwargs:\n    a: 999\n    raise_probability: 0\n    random_sleep: 0\n    sleep: 0\n  max_workers: 1\n  vectorized: false\ngenerator:\n  name: random\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants:\n    a: dummy_constant\n  constraints:\n    c1:\n    - GREATER_THAN\n    - 0.0\n    c2:\n    - LESS_THAN\n    - 0.5\n  objectives:\n    y1: MINIMIZE\n    y2: MINIMIZE\n  observables: []\n  variables:\n    x1:\n    - 0.0\n    - 3.14159\n    x2:\n    - 0.0\n    - 3.14159\n</pre> In\u00a0[6]: Copied! <pre>X.random_evaluate(10)\n</pre> X.random_evaluate(10) Out[6]: x1 x2 a y1 y2 c1 c2 xopt_runtime xopt_error 0 0.331896 0.586760 dummy_constant 0.331896 0.586760 -0.508244 0.035786 0.000066 False 1 1.172834 3.003514 dummy_constant 1.172834 3.003514 9.301922 6.720285 0.000011 False 2 1.048725 1.438040 dummy_constant 1.048725 1.438040 2.246974 1.181019 0.000010 False 3 1.646850 0.772128 dummy_constant 1.646850 0.772128 2.233882 1.389319 0.000009 False 4 2.669389 1.904718 dummy_constant 2.669389 1.904718 9.841759 6.679481 0.000008 False 5 1.958919 1.464556 dummy_constant 1.958919 1.464556 5.048510 3.058811 0.000008 False 6 2.326489 0.248541 dummy_constant 2.326489 0.248541 4.487488 3.399292 0.000008 False 7 0.912375 1.613921 dummy_constant 0.912375 1.613921 2.474116 1.410874 0.000007 False 8 2.294768 3.082051 dummy_constant 2.294768 3.082051 13.833558 9.888179 0.000007 False 9 0.117898 1.495803 dummy_constant 0.117898 1.495803 1.220603 1.137626 0.000008 False In\u00a0[7]: Copied! <pre>import numpy as np\nnp.random.seed(10)\n</pre> import numpy as np np.random.seed(10) In\u00a0[8]: Copied! <pre># Take one step (generate a single point)\nX.step()\n</pre> # Take one step (generate a single point) X.step() In\u00a0[9]: Copied! <pre># examine the results\nX.data\n</pre> # examine the results X.data Out[9]: x1 x2 a y1 y2 c1 c2 xopt_runtime xopt_error 0 0.331896 0.58676 dummy_constant 0.331896 0.58676 -0.508244 0.035786 0.000066 False 1 1.172834 3.003514 dummy_constant 1.172834 3.003514 9.301922 6.720285 0.000011 False 2 1.048725 1.43804 dummy_constant 1.048725 1.43804 2.246974 1.181019 0.000010 False 3 1.64685 0.772128 dummy_constant 1.64685 0.772128 2.233882 1.389319 0.000009 False 4 2.669389 1.904718 dummy_constant 2.669389 1.904718 9.841759 6.679481 0.000008 False 5 1.958919 1.464556 dummy_constant 1.958919 1.464556 5.04851 3.058811 0.000008 False 6 2.326489 0.248541 dummy_constant 2.326489 0.248541 4.487488 3.399292 0.000008 False 7 0.912375 1.613921 dummy_constant 0.912375 1.613921 2.474116 1.410874 0.000007 False 8 2.294768 3.082051 dummy_constant 2.294768 3.082051 13.833558 9.888179 0.000007 False 9 0.117898 1.495803 dummy_constant 0.117898 1.495803 1.220603 1.137626 0.000008 False 11 0.718417 3.076396 NaN 0.718417 3.076396 9.066664 6.685522 0.000062 False In\u00a0[10]: Copied! <pre># take a couple of steps and examine the results\nfor _ in range(10):\n    X.step()\nX.data\n</pre> # take a couple of steps and examine the results for _ in range(10):     X.step() X.data Out[10]: x1 x2 a y1 y2 c1 c2 xopt_runtime xopt_error 0 0.331896 0.58676 dummy_constant 0.331896 0.58676 -0.508244 0.035786 0.000066 False 1 1.172834 3.003514 dummy_constant 1.172834 3.003514 9.301922 6.720285 0.000011 False 2 1.048725 1.43804 dummy_constant 1.048725 1.43804 2.246974 1.181019 0.000010 False 3 1.64685 0.772128 dummy_constant 1.64685 0.772128 2.233882 1.389319 0.000009 False 4 2.669389 1.904718 dummy_constant 2.669389 1.904718 9.841759 6.679481 0.000008 False 5 1.958919 1.464556 dummy_constant 1.958919 1.464556 5.04851 3.058811 0.000008 False 6 2.326489 0.248541 dummy_constant 2.326489 0.248541 4.487488 3.399292 0.000008 False 7 0.912375 1.613921 dummy_constant 0.912375 1.613921 2.474116 1.410874 0.000007 False 8 2.294768 3.082051 dummy_constant 2.294768 3.082051 13.833558 9.888179 0.000007 False 9 0.117898 1.495803 dummy_constant 0.117898 1.495803 1.220603 1.137626 0.000008 False 11 0.718417 3.076396 NaN 0.718417 3.076396 9.066664 6.685522 0.000062 False 12 1.150927 0.789155 NaN 1.150927 0.789155 1.045563 0.507317 0.000061 False 13 1.575485 2.435371 NaN 1.575485 2.435371 7.51038 4.90233 0.001632 False 14 2.519358 0.752314 NaN 2.519358 0.752314 5.920078 4.141468 0.000051 False 15 2.610313 2.864063 NaN 2.610313 2.864063 13.942816 10.042213 0.000051 False 16 0.98847 0.146419 NaN 0.98847 0.146419 0.068991 0.363623 0.000049 False 17 3.129186 1.532492 NaN 3.129186 1.532492 11.086588 7.978659 0.000047 False 18 0.588668 1.217284 NaN 0.588668 1.217284 0.768029 0.522359 0.000047 False 19 0.874131 2.224635 NaN 0.874131 2.224635 4.617362 3.11434 0.000046 False 20 0.25832 0.896686 NaN 0.25832 0.896686 -0.106956 0.215769 0.000044 False 21 1.437138 2.69495 NaN 1.437138 2.69495 8.326577 5.696033 0.000045 False In\u00a0[11]: Copied! <pre>import matplotlib.pyplot as plt\n\nX.data.plot(*X.vocs.objective_names, kind=\"scatter\")\n</pre> import matplotlib.pyplot as plt  X.data.plot(*X.vocs.objective_names, kind=\"scatter\") Out[11]: <pre>&lt;Axes: xlabel='y1', ylabel='y2'&gt;</pre> In\u00a0[12]: Copied! <pre>import yaml\n\nconfig  = yaml.safe_load(YAML)\nX = Xopt.from_dict(config)\n</pre> import yaml  config  = yaml.safe_load(YAML) X = Xopt.from_dict(config)  In\u00a0[13]: Copied! <pre># convenience method for evaluating a random sample\nX.random_evaluate()\n</pre> # convenience method for evaluating a random sample X.random_evaluate() Out[13]: x1 x2 a y1 y2 c1 c2 xopt_runtime xopt_error 0 1.968706 1.023739 dummy_constant 1.968706 1.023739 3.905785 2.431401 0.000065 False In\u00a0[14]: Copied! <pre>X.random_evaluate(5)\n</pre> X.random_evaluate(5) Out[14]: x1 x2 a y1 y2 c1 c2 xopt_runtime xopt_error 0 1.753531 1.253372 dummy_constant 1.753531 1.253372 3.733363 2.138910 0.000060 False 1 1.778096 0.611909 dummy_constant 1.778096 0.611909 2.480365 1.646053 0.000018 False 2 1.200819 1.502789 dummy_constant 1.200819 1.502789 2.721078 1.496733 0.000025 False 3 1.529520 0.286988 dummy_constant 1.529520 0.286988 1.520284 1.105286 0.000143 False 4 1.098309 2.138681 dummy_constant 1.098309 2.138681 4.754223 3.043249 0.000016 False In\u00a0[15]: Copied! <pre># Notebook printing output\nfrom xopt import output_notebook\noutput_notebook()\n</pre> # Notebook printing output from xopt import output_notebook output_notebook() In\u00a0[16]: Copied! <pre>X.step()\n</pre> X.step() <pre>Running Xopt step\n</pre>"},{"location":"examples/basic/xopt_basic/#xopt-basic-example","title":"Xopt basic example\u00b6","text":"<p>An Xopt problem can be described by a simple YAML file. Here we will demonstrate how this is used to optimize a well-known constrained multi-objective test function, TNK. The TNK function is defined with:</p> <p>$n=2$ variables: $x_i \\in [0, \\pi], i=1,2$</p> <p>Objectives:</p> <ul> <li>$f_i(x) = x_i$</li> </ul> <p>Constraints:</p> <ul> <li>$g_1(x) = -x_1^2 -x_2^2 + 1 + 0.1 \\cos\\left(16 \\arctan \\frac{x_1}{x_2}\\right) \\le 0$</li> <li>$g_2(x) = (x_1 - 1/2)^2 + (x_2-1/2)^2 \\le 0.5$</li> </ul>"},{"location":"examples/basic/xopt_basic/#xopt-components","title":"Xopt Components\u00b6","text":"<p>The definition of the Xopt object requires 4 parts, listed below:</p> <ul> <li>The <code>Evaluator</code> object, which evaluates input points using the arbitrary function specified by the <code>function</code> property.</li> <li>The <code>Generator</code> object, which, when given data that has been evaluated, generates future points to evaluate using the evaluator.</li> <li>The <code>VOCS</code> (variables, objectives, constraints, statics) object, which specifies the input domain, the objectives, constraints and constants passed to the evaluator function.</li> </ul> <p>Through the YAML interface these objects and their options are specified by name. Here we will make one:</p>"},{"location":"examples/basic/xopt_basic/#run-random-data-generation","title":"Run Random data generation\u00b6","text":""},{"location":"examples/basic/xopt_basic/#plotting","title":"Plotting\u00b6","text":"<p>Plot the objective results</p>"},{"location":"examples/basic/xopt_basic/#alternative-initialization-methods","title":"Alternative initialization methods\u00b6","text":"<p>For convenience you can also use <code>Xopt.from_dict</code> to create Xopt objects from dictionaries.</p>"},{"location":"examples/basic/xopt_basic/#convenience-methods","title":"Convenience Methods\u00b6","text":""},{"location":"examples/basic/xopt_basic/#logging","title":"Logging\u00b6","text":"<p>Normally Xopt will not issue print statments, and instead issue logging messages. Below will enable these to be seen in the notebook</p>"},{"location":"examples/basic/xopt_evaluator/","title":"Xopt Evaluator Basic Usage","text":"In\u00a0[1]: Copied! <pre># needed for macos\nimport platform\nif platform.system() == \"Darwin\": import multiprocessing;multiprocessing.set_start_method(\"fork\")\n</pre> # needed for macos import platform if platform.system() == \"Darwin\": import multiprocessing;multiprocessing.set_start_method(\"fork\")  In\u00a0[2]: Copied! <pre>from xopt import Xopt, Evaluator, VOCS\nfrom xopt.generators.random import RandomGenerator\n\nimport pandas as pd\n\nfrom time import sleep\nfrom numpy.random import randint\n\nfrom typing import Dict\n\nimport numpy as np\nnp.random.seed(666) # for reproducibility\n</pre> from xopt import Xopt, Evaluator, VOCS from xopt.generators.random import RandomGenerator  import pandas as pd  from time import sleep from numpy.random import randint  from typing import Dict  import numpy as np np.random.seed(666) # for reproducibility <p>Define a custom function <code>f(inputs: Dict) -&gt; outputs: Dict</code>.</p> In\u00a0[3]: Copied! <pre>def f(inputs: Dict, enable_errors=True) -&gt; Dict:\n\n    sleep(randint(1, 5)*.1)  # simulate computation time\n    # Make some occasional errors\n    if enable_errors and np.any(inputs[\"x\"] &gt; 0.8):\n        raise ValueError(\"x &gt; 0.8\")\n\n    return {\"f1\": inputs[\"x\"] ** 2 + inputs[\"y\"] ** 2}\n</pre> def f(inputs: Dict, enable_errors=True) -&gt; Dict:      sleep(randint(1, 5)*.1)  # simulate computation time     # Make some occasional errors     if enable_errors and np.any(inputs[\"x\"] &gt; 0.8):         raise ValueError(\"x &gt; 0.8\")      return {\"f1\": inputs[\"x\"] ** 2 + inputs[\"y\"] ** 2} <p>Define variables, objectives, constraints, and other settings (VOCS)</p> In\u00a0[4]: Copied! <pre>vocs = VOCS(variables={\"x\": [0, 1], \"y\": [0, 1]}, objectives={\"f1\": \"MINIMIZE\"})\nvocs\n</pre> vocs = VOCS(variables={\"x\": [0, 1], \"y\": [0, 1]}, objectives={\"f1\": \"MINIMIZE\"}) vocs   Out[4]: <pre>VOCS(variables={'x': [0.0, 1.0], 'y': [0.0, 1.0]}, constraints={}, objectives={'f1': 'MINIMIZE'}, constants={}, observables=[])</pre> <p>This can be used to make some random inputs for evaluating the function.</p> In\u00a0[5]: Copied! <pre>in1 = vocs.random_inputs()[0]\n\nf(in1, enable_errors=False)\n</pre> in1 = vocs.random_inputs()[0]  f(in1, enable_errors=False) Out[5]: <pre>{'f1': array([0.11401572])}</pre> In\u00a0[6]: Copied! <pre># Add in occasional errors. \ntry:\n    f({\"x\": 1, \"y\": 0})\nexcept Exception as ex:\n    print(f\"Caught error in f: {ex}\")\n</pre> # Add in occasional errors.  try:     f({\"x\": 1, \"y\": 0}) except Exception as ex:     print(f\"Caught error in f: {ex}\") <pre>Caught error in f: x &gt; 0.8\n</pre> In\u00a0[7]: Copied! <pre># Create Evaluator\nev = Evaluator(function=f)\n</pre> # Create Evaluator ev = Evaluator(function=f) In\u00a0[8]: Copied! <pre># Single input evaluation\nev.evaluate(in1)\n</pre> # Single input evaluation ev.evaluate(in1) Out[8]: <pre>{'f1': array([0.11401572]),\n 'xopt_runtime': 0.2004864059999818,\n 'xopt_error': False}</pre> In\u00a0[9]: Copied! <pre># Dataframe evaluation\nin10 = pd.DataFrame({\n    \"x\":np.linspace(0,1,10),\n    \"y\":np.linspace(0,1,10)\n})\nev.evaluate_data(in10)\n</pre> # Dataframe evaluation in10 = pd.DataFrame({     \"x\":np.linspace(0,1,10),     \"y\":np.linspace(0,1,10) }) ev.evaluate_data(in10)  Out[9]: f1 xopt_runtime xopt_error xopt_error_str 0 0.000000 0.300511 False NaN 1 0.024691 0.100347 False NaN 2 0.098765 0.200406 False NaN 3 0.222222 0.400587 False NaN 4 0.395062 0.300571 False NaN 5 0.617284 0.400642 False NaN 6 0.888889 0.100311 False NaN 7 1.209877 0.400608 False NaN 8 NaN 0.100811 True Traceback (most recent call last):\\n  File \"/u... 9 NaN 0.300691 True Traceback (most recent call last):\\n  File \"/u... In\u00a0[10]: Copied! <pre># Dataframe evaluation, vectorized\nev.vectorized = True\nev.evaluate_data(in10)\n</pre> # Dataframe evaluation, vectorized ev.vectorized = True ev.evaluate_data(in10)  Out[10]: xopt_runtime xopt_error xopt_error_str 0 0.201152 True Traceback (most recent call last):\\n  File \"/u... 1 0.201152 True Traceback (most recent call last):\\n  File \"/u... 2 0.201152 True Traceback (most recent call last):\\n  File \"/u... 3 0.201152 True Traceback (most recent call last):\\n  File \"/u... 4 0.201152 True Traceback (most recent call last):\\n  File \"/u... 5 0.201152 True Traceback (most recent call last):\\n  File \"/u... 6 0.201152 True Traceback (most recent call last):\\n  File \"/u... 7 0.201152 True Traceback (most recent call last):\\n  File \"/u... 8 0.201152 True Traceback (most recent call last):\\n  File \"/u... 9 0.201152 True Traceback (most recent call last):\\n  File \"/u... In\u00a0[11]: Copied! <pre>from concurrent.futures import ProcessPoolExecutor\nMAX_WORKERS = 10\n</pre> from concurrent.futures import ProcessPoolExecutor MAX_WORKERS = 10 In\u00a0[12]: Copied! <pre># Create Executor instance\nexecutor = ProcessPoolExecutor(max_workers=MAX_WORKERS)\nexecutor\n</pre> # Create Executor instance executor = ProcessPoolExecutor(max_workers=MAX_WORKERS) executor Out[12]: <pre>&lt;concurrent.futures.process.ProcessPoolExecutor at 0x7fb76449f4f0&gt;</pre> In\u00a0[13]: Copied! <pre># Dask (Optional)\n# from dask.distributed import Client\n# import logging\n# client = Client( silence_logs=logging.ERROR)\n# executor = client.get_executor()\n# client\n</pre> # Dask (Optional) # from dask.distributed import Client # import logging # client = Client( silence_logs=logging.ERROR) # executor = client.get_executor() # client In\u00a0[14]: Copied! <pre># This calls `executor.map`\nev = Evaluator(function=f, executor=executor, max_workers=MAX_WORKERS)\n</pre> # This calls `executor.map` ev = Evaluator(function=f, executor=executor, max_workers=MAX_WORKERS) In\u00a0[15]: Copied! <pre># This will run in parallel\nev.evaluate_data(in10)\n</pre> # This will run in parallel ev.evaluate_data(in10) Out[15]: f1 xopt_runtime xopt_error xopt_error_str 0 0.000000 0.401245 False NaN 1 0.024691 0.401263 False NaN 2 0.098765 0.401311 False NaN 3 0.222222 0.401385 False NaN 4 0.395062 0.401461 False NaN 5 0.617284 0.401669 False NaN 6 0.888889 0.401911 False NaN 7 1.209877 0.402185 False NaN 8 NaN 0.403147 True Traceback (most recent call last):\\n  File \"/u... 9 NaN 0.404212 True Traceback (most recent call last):\\n  File \"/u... In\u00a0[16]: Copied! <pre>X = Xopt(generator=RandomGenerator(vocs=vocs), evaluator=Evaluator(function=f),\n         vocs=vocs)\nX.strict = False\n\n# Evaluate to the evaluator some new inputs\nX.evaluate_data(X.vocs.random_inputs(4))\n</pre> X = Xopt(generator=RandomGenerator(vocs=vocs), evaluator=Evaluator(function=f),          vocs=vocs) X.strict = False  # Evaluate to the evaluator some new inputs X.evaluate_data(X.vocs.random_inputs(4))  Out[16]: x y f1 xopt_runtime xopt_error xopt_error_str 0 0.491934 0.299155 0.331493 0.100314 False NaN 1 0.799752 0.706772 1.139131 0.100289 False NaN 2 0.255846 0.225521 0.116317 0.100355 False NaN 3 0.807108 0.994891 NaN 0.100796 True Traceback (most recent call last):\\n  File \"/u... In\u00a0[17]: Copied! <pre># Usage with a parallel executor.\nfrom xopt import AsynchronousXopt\n\nexecutor = ProcessPoolExecutor(max_workers=MAX_WORKERS)\n\nX2 = AsynchronousXopt(\n    generator=RandomGenerator(vocs=vocs),\n    evaluator=Evaluator(function=f, executor=executor, max_workers=MAX_WORKERS),\n    vocs=vocs,\n)\nX2.strict = False\n</pre> # Usage with a parallel executor. from xopt import AsynchronousXopt  executor = ProcessPoolExecutor(max_workers=MAX_WORKERS)  X2 = AsynchronousXopt(     generator=RandomGenerator(vocs=vocs),     evaluator=Evaluator(function=f, executor=executor, max_workers=MAX_WORKERS),     vocs=vocs, ) X2.strict = False In\u00a0[18]: Copied! <pre>X2.step()\n</pre> X2.step() In\u00a0[19]: Copied! <pre>for _ in range(20):\n    X2.step()\n\nlen(X2.data)\n</pre> for _ in range(20):     X2.step()  len(X2.data) Out[19]: <pre>52</pre> In\u00a0[20]: Copied! <pre>X2.data.plot.scatter(\"x\", \"y\")\n</pre> X2.data.plot.scatter(\"x\", \"y\") Out[20]: <pre>&lt;Axes: xlabel='x', ylabel='y'&gt;</pre> In\u00a0[21]: Copied! <pre># Asynchronous, Vectorized\nX2 = AsynchronousXopt(\n    generator=RandomGenerator(vocs=vocs),\n    evaluator=Evaluator(function=f, executor=executor, max_workers=MAX_WORKERS),\n    vocs=vocs,\n)\nX2.evaluator.vectorized = True\nX2.strict = False\n\n# This takes fewer steps to achieve a similar number of evaluations\nfor _ in range(3):\n    X2.step()\n\nlen(X2.data)\n</pre> # Asynchronous, Vectorized X2 = AsynchronousXopt(     generator=RandomGenerator(vocs=vocs),     evaluator=Evaluator(function=f, executor=executor, max_workers=MAX_WORKERS),     vocs=vocs, ) X2.evaluator.vectorized = True X2.strict = False  # This takes fewer steps to achieve a similar number of evaluations for _ in range(3):     X2.step()  len(X2.data) Out[21]: <pre>30</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/basic/xopt_evaluator/#xopt-evaluator-basic-usage","title":"Xopt Evaluator Basic Usage\u00b6","text":"<p>The <code>Evaluator</code> handles the execution of the user-provided <code>function</code> with optional <code>function_kwags</code>, asyncrhonously and parallel, with exception handling.</p>"},{"location":"examples/basic/xopt_evaluator/#executors","title":"Executors\u00b6","text":""},{"location":"examples/basic/xopt_evaluator/#evaluator-in-the-xopt-object","title":"Evaluator in the Xopt object\u00b6","text":""},{"location":"examples/basic/xopt_evaluator/#asynchronous-xopt","title":"Asynchronous Xopt\u00b6","text":"<p>Instead of waiting for evaluations to be finished, AsynchronousXopt can be used to generate candidates while waiting for other evaluations to finish (requires parallel execution). In this case, calling <code>X.step()</code> generates and executes a number of candidates that are executed in parallel using python <code>concurrent.futures</code> formalism. Calling <code>X.step()</code> again will generate and evaluate new points based on finished futures asynchronously.</p>"},{"location":"examples/basic/xopt_generator/","title":"Working with Xopt generators","text":"In\u00a0[1]: Copied! <pre># Import the class\nfrom xopt.generators import generators, get_generator\n</pre> # Import the class from xopt.generators import generators, get_generator In\u00a0[2]: Copied! <pre># named generators\ngenerators.keys()\n</pre> # named generators generators.keys() Out[2]: <pre>dict_keys(['random', 'extremum_seeking', 'rcds', 'cnsga', 'upper_confidence_bound', 'mobo', 'bayesian_exploration', 'time_dependent_upper_confidence_bound', 'expected_improvement', 'multi_fidelity', 'mggpo', 'neldermead'])</pre> In\u00a0[3]: Copied! <pre># get default options for the upper confidence bound generator\ngenerator_type = get_generator(\"upper_confidence_bound\")\n</pre> # get default options for the upper confidence bound generator generator_type = get_generator(\"upper_confidence_bound\") In\u00a0[4]: Copied! <pre># define vocs for the problem\nfrom xopt.vocs import VOCS\nimport math\n\nvocs = VOCS(\n    variables={\"x\": [0, 2 * math.pi]},\n    objectives={\"f\": \"MINIMIZE\"},\n)\n</pre> # define vocs for the problem from xopt.vocs import VOCS import math  vocs = VOCS(     variables={\"x\": [0, 2 * math.pi]},     objectives={\"f\": \"MINIMIZE\"}, ) In\u00a0[5]: Copied! <pre># define a test function to optimize\nimport numpy as np\n\n\ndef test_function(input_dict):\n    return {\"f\": np.sin(input_dict[\"x\"])}\n</pre> # define a test function to optimize import numpy as np   def test_function(input_dict):     return {\"f\": np.sin(input_dict[\"x\"])} In\u00a0[6]: Copied! <pre># create xopt evaluator and run the optimization\nfrom xopt import Evaluator, Xopt\n\nevaluator = Evaluator(function=test_function)\ngenerator = generator_type(vocs=vocs)\nX = Xopt(generator=generator, evaluator=evaluator, vocs=vocs)\nX\n</pre> # create xopt evaluator and run the optimization from xopt import Evaluator, Xopt  evaluator = Evaluator(function=test_function) generator = generator_type(vocs=vocs) X = Xopt(generator=generator, evaluator=evaluator, vocs=vocs) X Out[6]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: __main__.test_function\n  function_kwargs: {}\n  max_workers: 1\n  vectorized: false\ngenerator:\n  beta: 2.0\n  computation_time: null\n  fixed_features: null\n  gp_constructor:\n    covar_modules: {}\n    mean_modules: {}\n    name: standard\n    trainable_mean_keys: []\n    use_low_noise_prior: true\n  max_travel_distances: null\n  model: null\n  n_candidates: 1\n  n_monte_carlo_samples: 128\n  name: upper_confidence_bound\n  numerical_optimizer:\n    max_iter: 2000\n    n_raw_samples: 20\n    n_restarts: 20\n    name: LBFGS\n  turbo_controller: null\n  use_cuda: false\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants: {}\n  constraints: {}\n  objectives:\n    f: MINIMIZE\n  observables: []\n  variables:\n    x:\n    - 0.0\n    - 6.283185307179586\n</pre> In\u00a0[7]: Copied! <pre># run the optimization for a couple of iterations (see bayes_opt folder for\n# more examples of ucb)\nX.random_evaluate(2)\nfor i in range(4):\n    X.step()\n</pre> # run the optimization for a couple of iterations (see bayes_opt folder for # more examples of ucb) X.random_evaluate(2) for i in range(4):     X.step() <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> In\u00a0[8]: Copied! <pre>X.data\n</pre> X.data Out[8]: x f xopt_runtime xopt_error 0 3.158832 -0.017239 0.000026 False 1 4.028870 -0.775355 0.000003 False 3 6.153320 -0.129500 0.000011 False 4 4.783705 -0.997458 0.000011 False 5 0.000000 0.000000 0.000012 False 6 4.526177 -0.982713 0.000012 False In\u00a0[8]: Copied! <pre>\n</pre> In\u00a0[8]: Copied! <pre>\n</pre>"},{"location":"examples/basic/xopt_generator/#working-with-xopt-generators","title":"Working with Xopt generators\u00b6","text":""},{"location":"examples/basic/xopt_parallel/","title":"Xopt Parallel Examples","text":"In\u00a0[1]: Copied! <pre>from xopt import Xopt\n</pre> from xopt import Xopt In\u00a0[2]: Copied! <pre># Helpers for this notebook\nimport multiprocessing\nN_CPUS=multiprocessing.cpu_count()\nN_CPUS\n\nimport os\n\n# directory for data. \nos.makedirs(\"temp\", exist_ok=True)\n\n# Notebook printing output\n#from xopt import output_notebook\n#output_notebook()\n\n# Nicer plotting\n%config InlineBackend.figure_format = 'retina'\n</pre> # Helpers for this notebook import multiprocessing N_CPUS=multiprocessing.cpu_count() N_CPUS  import os  # directory for data.  os.makedirs(\"temp\", exist_ok=True)  # Notebook printing output #from xopt import output_notebook #output_notebook()  # Nicer plotting %config InlineBackend.figure_format = 'retina'  <p>The <code>Xopt</code> object can be instantiated from a JSON or YAML file, or a dict, with the proper structure.</p> <p>Here we will make one</p> In\u00a0[3]: Copied! <pre># Make a proper input file.\nYAML = \"\"\"\nxopt:\n  asynch: True\n  max_evaluations: 1000\n\ngenerator:\n  name: cnsga\n  output_path: temp\n  population_size:  64\nevaluator:\n  function: xopt.resources.test_functions.tnk.evaluate_TNK\n  function_kwargs:\n    sleep: 0\n    random_sleep: 0.1\nvocs:\n  variables:\n    x1: [0, 3.14159]\n    x2: [0, 3.14159]\n  objectives: {y1: MINIMIZE, y2: MINIMIZE}\n  constraints:\n    c1: [GREATER_THAN, 0]\n    c2: [LESS_THAN, 0.5]\n  linked_variables: {x9: x1}\n  constants: {a: dummy_constant}\n\n\"\"\"\nX = Xopt(YAML)\nX\n</pre> # Make a proper input file. YAML = \"\"\" xopt:   asynch: True   max_evaluations: 1000  generator:   name: cnsga   output_path: temp   population_size:  64    evaluator:   function: xopt.resources.test_functions.tnk.evaluate_TNK   function_kwargs:     sleep: 0     random_sleep: 0.1    vocs:   variables:     x1: [0, 3.14159]     x2: [0, 3.14159]   objectives: {y1: MINIMIZE, y2: MINIMIZE}   constraints:     c1: [GREATER_THAN, 0]     c2: [LESS_THAN, 0.5]   linked_variables: {x9: x1}   constants: {a: dummy_constant}  \"\"\" X = Xopt(YAML) X Out[3]: <pre>\n            Xopt\n________________________________\nVersion: 1.1.2+31.g422c5a9.dirty\nData size: 0\nConfig as YAML:\nxopt: {asynch: true, strict: false, dump_file: null, max_evaluations: 1000}\ngenerator: {name: cnsga, population_size: 64, crossover_probability: 0.9, mutation_probability: 1.0,\n  population_file: null, output_path: temp}\nevaluator:\n  function: xopt.resources.test_functions.tnk.evaluate_TNK\n  max_workers: 1\n  function_kwargs: {sleep: 0, random_sleep: 0.1, raise_probability: 0}\n  vectorized: false\nvocs:\n  variables:\n    x1: [0.0, 3.14159]\n    x2: [0.0, 3.14159]\n  constraints:\n    c1: [GREATER_THAN, 0.0]\n    c2: [LESS_THAN, 0.5]\n  objectives: {y1: MINIMIZE, y2: MINIMIZE}\n  constants: {a: dummy_constant}\n  linked_variables: {x9: x1}\n</pre> In\u00a0[4]: Copied! <pre>%%timeit\n# Check that the average time is close to random_sleep\nX.evaluator.function({\"x1\": 0.5, \"x2\": 0.5}, random_sleep = .1)\n</pre> %%timeit # Check that the average time is close to random_sleep X.evaluator.function({\"x1\": 0.5, \"x2\": 0.5}, random_sleep = .1) <pre>96.5 ms \u00b1 16.8 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</pre> In\u00a0[5]: Copied! <pre>%%time\nX.run()\n</pre> %%time X.run() <pre>CPU times: user 6.94 s, sys: 225 ms, total: 7.16 s\nWall time: 1min 50s\n</pre> In\u00a0[6]: Copied! <pre>from concurrent.futures import ProcessPoolExecutor\n</pre> from concurrent.futures import ProcessPoolExecutor In\u00a0[7]: Copied! <pre>%%time\nX = Xopt(YAML)\n\nwith ProcessPoolExecutor() as executor:\n    X.evaluator.executor = executor\n    X.evaluator.max_workers = N_CPUS\n    X.run()\nlen(X.data)\n</pre> %%time X = Xopt(YAML)  with ProcessPoolExecutor() as executor:     X.evaluator.executor = executor     X.evaluator.max_workers = N_CPUS     X.run() len(X.data) <pre>CPU times: user 3.86 s, sys: 294 ms, total: 4.15 s\nWall time: 12.9 s\n</pre> Out[7]: <pre>1000</pre> In\u00a0[8]: Copied! <pre>from concurrent.futures import ThreadPoolExecutor\n</pre> from concurrent.futures import ThreadPoolExecutor In\u00a0[9]: Copied! <pre>%%time\n\nX = Xopt(YAML)\n\nwith ThreadPoolExecutor() as executor:\n    X.evaluator.executor = executor\n    X.evaluator.max_workers = N_CPUS\n    X.run()\nlen(X.data)\n</pre> %%time  X = Xopt(YAML)  with ThreadPoolExecutor() as executor:     X.evaluator.executor = executor     X.evaluator.max_workers = N_CPUS     X.run() len(X.data) <pre>CPU times: user 4.3 s, sys: 192 ms, total: 4.49 s\nWall time: 11.3 s\n</pre> Out[9]: <pre>1000</pre> In\u00a0[10]: Copied! <pre>X = Xopt(YAML)\nX.yaml('test.yaml') # Write this input to file\n!cat test.yaml\n</pre> X = Xopt(YAML) X.yaml('test.yaml') # Write this input to file !cat test.yaml <pre>xopt: {asynch: true, strict: false, dump_file: null, max_evaluations: 1000}\ngenerator: {name: cnsga, population_size: 64, crossover_probability: 0.9, mutation_probability: 1.0,\n  population_file: null, output_path: temp}\nevaluator:\n  function: xopt.resources.test_functions.tnk.evaluate_TNK\n  max_workers: 1\n  function_kwargs: {sleep: 0, random_sleep: 0.1, raise_probability: 0}\n  vectorized: false\nvocs:\n  variables:\n    x1: [0.0, 3.14159]\n    x2: [0.0, 3.14159]\n  constraints:\n    c1: [GREATER_THAN, 0.0]\n    c2: [LESS_THAN, 0.5]\n  objectives: {y1: MINIMIZE, y2: MINIMIZE}\n  constants: {a: dummy_constant}\n  linked_variables: {x9: x1}\n</pre> In\u00a0[11]: Copied! <pre>%%time\n!mpirun -n {N_CPUS} python -m mpi4py.futures -m xopt.mpi.run -vv --logfile xopt.log test.yaml\n</pre> %%time !mpirun -n {N_CPUS} python -m mpi4py.futures -m xopt.mpi.run -vv --logfile xopt.log test.yaml <pre>Namespace(input_file='test.yaml', logfile='xopt.log', verbose=2)\nParallel execution with 10 workers\nInitializing Xopt object\nInitializing generator cnsga,\nCreated toolbox with 2 variables, 2 constraints, and 2 objectives.\n    Using selection algorithm: nsga2\nInitializing Xopt object\nXopt object initialized\nEnabling async mode\n\n            Xopt\n________________________________\nVersion: 1.1.2+31.g422c5a9.dirty\nData size: 0\nConfig as YAML:\nxopt: {asynch: true, strict: false, dump_file: null, max_evaluations: 1000}\ngenerator: {name: cnsga, population_size: 64, crossover_probability: 0.9, mutation_probability: 1.0,\n  population_file: null, output_path: temp}\nevaluator:\n  function: xopt.resources.test_functions.tnk.evaluate_TNK\n  max_workers: 1\n  function_kwargs: {sleep: 0, random_sleep: 0.1, raise_probability: 0}\n  vectorized: false\nvocs:\n  variables:\n    x1: [0.0, 3.14159]\n    x2: [0.0, 3.14159]\n  constraints:\n    c1: [GREATER_THAN, 0.0]\n    c2: [LESS_THAN, 0.5]\n  objectives: {y1: MINIMIZE, y2: MINIMIZE}\n  constants: {a: dummy_constant}\n  linked_variables: {x9: x1}\n\n\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nRunning Xopt step\nXopt is done. Max evaluations 1000 reached.\n--------------------------------------------------------------------------\nA system call failed during shared memory initialization that should\nnot have.  It is likely that your MPI job will now either abort or\nexperience performance degradation.\n\n  Local host:  ChristophersMBP\n  System call: unlink(2) /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T//ompi.ChristophersMBP.501/pid.15991/1/vader_segment.ChristophersMBP.501.89fb0001.4\n  Error:       No such file or directory (errno 2)\n--------------------------------------------------------------------------\nCPU times: user 180 ms, sys: 53.8 ms, total: 233 ms\nWall time: 14.8 s\n</pre> In\u00a0[12]: Copied! <pre>!tail xopt.log\n</pre> !tail xopt.log <pre>2022-08-18T11:45:27-0700 - xopt.base - INFO - Running Xopt step\n2022-08-18T11:45:27-0700 - xopt.base - INFO - Running Xopt step\n2022-08-18T11:45:27-0700 - xopt.base - INFO - Running Xopt step\n2022-08-18T11:45:27-0700 - xopt.base - INFO - Running Xopt step\n2022-08-18T11:45:27-0700 - xopt.base - INFO - Running Xopt step\n2022-08-18T11:45:27-0700 - xopt.base - INFO - Running Xopt step\n2022-08-18T11:45:27-0700 - xopt.base - INFO - Running Xopt step\n2022-08-18T11:45:27-0700 - xopt.base - INFO - Running Xopt step\n2022-08-18T11:45:27-0700 - xopt.base - INFO - Running Xopt step\n2022-08-18T11:45:27-0700 - xopt.base - INFO - Xopt is done. Max evaluations 1000 reached.\n</pre> In\u00a0[13]: Copied! <pre>from dask.distributed import Client\nclient = Client()\nexecutor = client.get_executor()\nclient\n</pre> from dask.distributed import Client client = Client() executor = client.get_executor() client <pre>2022-08-18 11:45:28,982 - distributed.diskutils - INFO - Found stale lock file and directory '/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/dask-worker-space/worker-o2x19bac', purging\n2022-08-18 11:45:28,982 - distributed.diskutils - INFO - Found stale lock file and directory '/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/dask-worker-space/worker-pkfm2l0b', purging\n2022-08-18 11:45:28,982 - distributed.diskutils - INFO - Found stale lock file and directory '/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/dask-worker-space/worker-2pe9ydgc', purging\n2022-08-18 11:45:28,982 - distributed.diskutils - INFO - Found stale lock file and directory '/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/dask-worker-space/worker-3ol1dgla', purging\n2022-08-18 11:45:28,982 - distributed.diskutils - INFO - Found stale lock file and directory '/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/dask-worker-space/worker-37kim0g2', purging\n</pre> Out[13]: Client <p>Client-ee055da8-1f25-11ed-bd56-060412c509ec</p> Connection method: Cluster object Cluster type: distributed.LocalCluster Dashboard:  http://127.0.0.1:8787/status Cluster Info LocalCluster <p>e3a69ad2</p> Dashboard: http://127.0.0.1:8787/status Workers: 5                  Total threads: 10                  Total memory: 64.00 GiB                  Status: running Using processes: True Scheduler Info Scheduler <p>Scheduler-8735408f-e5e0-4929-bc89-e8e4f21e0082</p> Comm: tcp://127.0.0.1:54856                      Workers: 5                      Dashboard: http://127.0.0.1:8787/status Total threads: 10                      Started: Just now                      Total memory: 64.00 GiB                      Workers Worker: 0 Comm:  tcp://127.0.0.1:54896                          Total threads:  2                          Dashboard:  http://127.0.0.1:54897/status Memory:  12.80 GiB                          Nanny:  tcp://127.0.0.1:54861                          Local directory:  /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/dask-worker-space/worker-nlturonv                          Worker: 1 Comm:  tcp://127.0.0.1:54899                          Total threads:  2                          Dashboard:  http://127.0.0.1:54900/status Memory:  12.80 GiB                          Nanny:  tcp://127.0.0.1:54863                          Local directory:  /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/dask-worker-space/worker-wu2vuab_                          Worker: 2 Comm:  tcp://127.0.0.1:54902                          Total threads:  2                          Dashboard:  http://127.0.0.1:54903/status Memory:  12.80 GiB                          Nanny:  tcp://127.0.0.1:54862                          Local directory:  /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/dask-worker-space/worker-c67xq0c9                          Worker: 3 Comm:  tcp://127.0.0.1:54891                          Total threads:  2                          Dashboard:  http://127.0.0.1:54892/status Memory:  12.80 GiB                          Nanny:  tcp://127.0.0.1:54860                          Local directory:  /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/dask-worker-space/worker-l9dnpx62                          Worker: 4 Comm:  tcp://127.0.0.1:54890                          Total threads:  2                          Dashboard:  http://127.0.0.1:54893/status Memory:  12.80 GiB                          Nanny:  tcp://127.0.0.1:54859                          Local directory:  /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/dask-worker-space/worker-eerlov4r                          In\u00a0[14]: Copied! <pre>%%time\nX = Xopt(YAML)\nX.evaluator.executor = executor\nX.evaluator.max_workers = N_CPUS\nX.run()\nlen(X.data)\n</pre> %%time X = Xopt(YAML) X.evaluator.executor = executor X.evaluator.max_workers = N_CPUS X.run() len(X.data) <pre>CPU times: user 4.25 s, sys: 559 ms, total: 4.81 s\nWall time: 12.5 s\n</pre> Out[14]: <pre>1000</pre> In\u00a0[15]: Copied! <pre>import pandas as pd\n</pre> import pandas as pd In\u00a0[16]: Copied! <pre>X.data\n</pre> X.data Out[16]: x1 x2 a x9 y1 y2 c1 c2 some_array xopt_runtime xopt_error 10 2.471422 0.488736 dummy_constant 2.471422 2.471422 0.488736 5.446776 3.886633 [1, 2, 3] 0.011140 False 6 0.976978 2.405552 dummy_constant 0.976978 0.976978 2.405552 5.641776 3.858635 [1, 2, 3] 0.038039 False 7 0.455740 2.939118 dummy_constant 0.455740 0.455740 2.939118 7.923855 5.951254 [1, 2, 3] 0.074599 False 11 0.232046 0.367798 dummy_constant 0.232046 0.232046 0.367798 -0.719546 0.089277 [1, 2, 3] 0.036718 False 8 1.494465 2.718696 dummy_constant 1.494465 1.494465 2.718696 8.643407 5.911574 [1, 2, 3] 0.058163 False ... ... ... ... ... ... ... ... ... ... ... ... 998 0.801200 0.637918 dummy_constant NaN 0.801200 0.637918 0.072322 0.109743 [1, 2, 3] 0.037957 False 1006 0.480176 0.997499 dummy_constant NaN 0.480176 0.997499 0.163026 0.247899 [1, 2, 3] 0.008176 False 989 1.272588 0.147963 dummy_constant NaN 1.272588 0.147963 0.669124 0.720823 [1, 2, 3] 0.191139 False 1002 0.583817 0.787997 dummy_constant NaN 0.583817 0.787997 0.033047 0.089968 [1, 2, 3] 0.071444 False 997 0.875323 0.596263 dummy_constant NaN 0.875323 0.596263 0.220698 0.150134 [1, 2, 3] 0.105140 False <p>1000 rows \u00d7 11 columns</p> In\u00a0[17]: Copied! <pre>df = pd.concat([X.data, X.vocs.feasibility_data(X.data)], axis=1)\ndf[df['feasible']]\n</pre> df = pd.concat([X.data, X.vocs.feasibility_data(X.data)], axis=1) df[df['feasible']] Out[17]: x1 x2 a x9 y1 y2 c1 c2 some_array xopt_runtime xopt_error feasible_c1 feasible_c2 feasible 9 0.547623 1.169586 dummy_constant 0.547623 0.547623 1.169586 0.592854 0.450613 [1, 2, 3] 0.110823 False True True True 26 0.980003 0.426040 dummy_constant 0.980003 0.980003 0.426040 0.045761 0.235873 [1, 2, 3] 0.081441 False True True True 18 0.922711 0.491246 dummy_constant 0.922711 0.922711 0.491246 0.090082 0.178761 [1, 2, 3] 0.171685 False True True True 66 0.432459 1.093330 dummy_constant 0.432459 0.432459 1.093330 0.285668 0.356603 [1, 2, 3] 0.087319 False True True True 72 0.504830 1.092646 dummy_constant 0.504830 0.504830 1.092646 0.368625 0.351253 [1, 2, 3] 0.009447 False True True True ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 1000 1.048656 0.099549 dummy_constant NaN 1.048656 0.099549 0.103946 0.461385 [1, 2, 3] 0.014905 False True True True 998 0.801200 0.637918 dummy_constant NaN 0.801200 0.637918 0.072322 0.109743 [1, 2, 3] 0.037957 False True True True 1006 0.480176 0.997499 dummy_constant NaN 0.480176 0.997499 0.163026 0.247899 [1, 2, 3] 0.008176 False True True True 1002 0.583817 0.787997 dummy_constant NaN 0.583817 0.787997 0.033047 0.089968 [1, 2, 3] 0.071444 False True True True 997 0.875323 0.596263 dummy_constant NaN 0.875323 0.596263 0.220698 0.150134 [1, 2, 3] 0.105140 False True True True <p>439 rows \u00d7 14 columns</p> In\u00a0[18]: Copied! <pre># Plot the feasible ones\nfeasible_df = df[df[\"feasible\"]]\nfeasible_df.plot(\"y1\", \"y2\", kind=\"scatter\").set_aspect(\"equal\")\n</pre> # Plot the feasible ones feasible_df = df[df[\"feasible\"]] feasible_df.plot(\"y1\", \"y2\", kind=\"scatter\").set_aspect(\"equal\") In\u00a0[19]: Copied! <pre># Plot the infeasible ones\ninfeasible_df = df[~df[\"feasible\"]]\ninfeasible_df.plot(\"y1\", \"y2\", kind=\"scatter\").set_aspect(\"equal\")\n</pre> # Plot the infeasible ones infeasible_df = df[~df[\"feasible\"]] infeasible_df.plot(\"y1\", \"y2\", kind=\"scatter\").set_aspect(\"equal\") In\u00a0[20]: Copied! <pre># This is the final population\ndf1 = X.generator.population\ndf1.plot(\"y1\", \"y2\", kind=\"scatter\").set_aspect(\"equal\")\n</pre> # This is the final population df1 = X.generator.population df1.plot(\"y1\", \"y2\", kind=\"scatter\").set_aspect(\"equal\") In\u00a0[21]: Copied! <pre>import matplotlib.pyplot as plt\n\n%matplotlib inline\n</pre> import matplotlib.pyplot as plt  %matplotlib inline In\u00a0[22]: Copied! <pre># Extract objectives from output\nk1, k2 = \"y1\", \"y2\"\n\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.scatter(\n    infeasible_df[k1],\n    infeasible_df[k2],\n    color=\"blue\",\n    marker=\".\",\n    alpha=0.5,\n    label=\"infeasible\",\n)\nax.scatter(\n    feasible_df[k1], feasible_df[k2], color=\"orange\", marker=\".\", label=\"feasible\"\n)\nax.scatter(df1[k1], df1[k2], color=\"red\", marker=\".\", label=\"final population\")\nax.set_xlabel(k1)\nax.set_ylabel(k2)\nax.set_aspect(\"auto\")\nax.set_title(f\"Xopt's CNSGA algorithm\")\nplt.legend()\n</pre> # Extract objectives from output k1, k2 = \"y1\", \"y2\"  fig, ax = plt.subplots(figsize=(6, 6))  ax.scatter(     infeasible_df[k1],     infeasible_df[k2],     color=\"blue\",     marker=\".\",     alpha=0.5,     label=\"infeasible\", ) ax.scatter(     feasible_df[k1], feasible_df[k2], color=\"orange\", marker=\".\", label=\"feasible\" ) ax.scatter(df1[k1], df1[k2], color=\"red\", marker=\".\", label=\"final population\") ax.set_xlabel(k1) ax.set_ylabel(k2) ax.set_aspect(\"auto\") ax.set_title(f\"Xopt's CNSGA algorithm\") plt.legend() Out[22]: <pre>&lt;matplotlib.legend.Legend at 0x1429c0b80&gt;</pre> In\u00a0[23]: Copied! <pre># Cleanup\n!rm -r dask-worker-space\n!rm -r temp\n!rm xopt.log*\n!rm test.yaml\n</pre> # Cleanup !rm -r dask-worker-space !rm -r temp !rm xopt.log* !rm test.yaml <pre>rm: dask-worker-space: No such file or directory\n</pre>"},{"location":"examples/basic/xopt_parallel/#xopt-parallel-examples","title":"Xopt Parallel Examples\u00b6","text":"<p>Xopt provides methods to parallelize optimizations using Processes, Threads, MPI, and Dask using the <code>concurrent.futures</code> interface as defined in  https://www.python.org/dev/peps/pep-3148/ .</p>"},{"location":"examples/basic/xopt_parallel/#processes","title":"Processes\u00b6","text":""},{"location":"examples/basic/xopt_parallel/#threads","title":"Threads\u00b6","text":"<p>Continue running, this time with threads.</p>"},{"location":"examples/basic/xopt_parallel/#mpi","title":"MPI\u00b6","text":"<p>The <code>test.yaml</code> file completely defines the problem. We will also direct the logging to an <code>xopt.log</code> file. The following invocation recruits 4 MPI workers to solve this problem.</p> <p>We can also continue by calling <code>.save</code> with a JSON filename. This will write all of previous results into the file.</p>"},{"location":"examples/basic/xopt_parallel/#dask","title":"Dask\u00b6","text":""},{"location":"examples/basic/xopt_parallel/#load-output-into-pandas","title":"Load output into Pandas\u00b6","text":"<p>This algorithm writes two types of files: <code>gen_{i}.json</code> with all of the new individuals evaluated in a generation, and <code>pop_{i}.json</code> with the latest best population. Xopt provides some functions to load these easily into a Pandas dataframe for further analysis.</p>"},{"location":"examples/basic/xopt_parallel/#matplotlib-plotting","title":"matplotlib plotting\u00b6","text":"<p>You can always use matplotlib for customizable plotting</p>"},{"location":"examples/basic/xopt_vocs/","title":"VOCS data structure","text":"In\u00a0[1]: Copied! <pre>from xopt.vocs import VOCS\n</pre> from xopt.vocs import VOCS In\u00a0[2]: Copied! <pre>help(VOCS)\n</pre> help(VOCS) <pre>Help on class VOCS in module xopt.vocs:\n\nclass VOCS(xopt.pydantic.XoptBaseModel)\n |  VOCS(*, variables: Dict[str, Annotated[List[float], Len(min_length=2, max_length=2)]] = {}, constraints: Dict[str, Annotated[List[Union[float, xopt.vocs.ConstraintEnum]], Len(min_length=2, max_length=2)]] = {}, objectives: Dict[str, xopt.vocs.ObjectiveEnum] = {}, constants: Dict[str, Any] = {}, observables: List[str] = []) -&gt; None\n |  \n |  Variables, Objectives, Constraints, and other Settings (VOCS) data structure\n |  to describe optimization problems.\n |  \n |  Method resolution order:\n |      VOCS\n |      xopt.pydantic.XoptBaseModel\n |      pydantic.main.BaseModel\n |      builtins.object\n |  \n |  Methods defined here:\n |  \n |  as_yaml(self)\n |  \n |  constraint_data(self, data: Union[pandas.core.frame.DataFrame, List[Dict]], prefix: str = 'constraint_') -&gt; pandas.core.frame.DataFrame\n |      Returns a dataframe containing constraint data transformed according to\n |      `vocs.constraints` such that values that satisfy each constraint are negative.\n |      \n |      Args:\n |          data: data to be processed.\n |          prefix: prefix added to column names.\n |      \n |      Returns:\n |          result: processed Dataframe\n |  \n |  convert_dataframe_to_inputs(self, data: pandas.core.frame.DataFrame, include_constants=True) -&gt; pandas.core.frame.DataFrame\n |      Extracts only inputs from a dataframe.\n |      This will add constants if `include_constants` is true.\n |  \n |  convert_numpy_to_inputs(self, inputs: numpy.ndarray, include_constants=True) -&gt; pandas.core.frame.DataFrame\n |      convert 2D numpy array to list of dicts (inputs) for evaluation\n |      Assumes that the columns of the array match correspond to\n |      `sorted(self.vocs.variables.keys())\n |  \n |  extract_data(self, data: pandas.core.frame.DataFrame, return_raw=False)\n |      split dataframe into seperate dataframes for variables, objectives and\n |      constraints based on vocs - objective data is transformed based on\n |      `vocs.objectives` properties\n |      \n |      Args:\n |          data: dataframe to be split\n |          return_raw: if True, return untransformed objective data\n |      \n |      Returns:\n |          variable_data: dataframe containing variable data\n |          objective_data: dataframe containing objective data\n |          constraint_data: dataframe containing constraint data\n |  \n |  feasibility_data(self, data: Union[pandas.core.frame.DataFrame, List[Dict]], prefix: str = 'feasible_') -&gt; pandas.core.frame.DataFrame\n |      Returns a dataframe containing booleans denoting if a constraint is satisfied or\n |      not. Returned dataframe also contains a column `feasible` which denotes if\n |      all constraints are satisfied.\n |      \n |      Args:\n |          data: data to be processed.\n |          prefix: prefix added to column names.\n |      \n |      Returns:\n |          result: processed Dataframe\n |  \n |  objective_data(self, data: Union[pandas.core.frame.DataFrame, List[Dict]], prefix: str = 'objective_', return_raw=False) -&gt; pandas.core.frame.DataFrame\n |      Returns a dataframe containing objective data transformed according to\n |      `vocs.objectives` such that we always assume minimization.\n |      \n |      Args:\n |          data: data to be processed.\n |          prefix: prefix added to column names.\n |      \n |      Returns:\n |          result: processed Dataframe\n |  \n |  observable_data(self, data: Union[pandas.core.frame.DataFrame, List[Dict]], prefix: str = 'observable_') -&gt; pandas.core.frame.DataFrame\n |      Returns a dataframe containing observable data\n |      \n |      Args:\n |          data: data to be processed.\n |          prefix: prefix added to column names.\n |      \n |      Returns:\n |          result: processed Dataframe\n |  \n |  random_inputs(self, n: int = None, custom_bounds: dict = None, include_constants: bool = True, seed: int = None) -&gt; list[dict]\n |      Uniform sampling of the variables.\n |      \n |      Returns a dict of inputs.\n |      \n |      If include_constants, the vocs.constants are added to the dict.\n |      \n |      Optional:\n |          n (integer) to make arrays of inputs, of size n.\n |          seed (integer) to initialize the random number generator\n |  \n |  validate_input_data(self, input_points: pandas.core.frame.DataFrame) -&gt; None\n |      Validates input data. Raises an error if the input data does not satisfy\n |      requirements given by vocs.\n |      \n |      Args:\n |          input_points: input data to be validated.\n |      \n |      Returns:\n |          None\n |      \n |      Raises:\n |          ValueError: if input data does not satisfy requirements.\n |  \n |  variable_data(self, data: Union[pandas.core.frame.DataFrame, List[Dict]], prefix: str = 'variable_') -&gt; pandas.core.frame.DataFrame\n |      Returns a dataframe containing variables according to `vocs.variables` in sorted\n |      order\n |      \n |      Args:\n |          data: Data to be processed.\n |          prefix: Prefix added to column names.\n |      \n |      Returns:\n |          result: processed Dataframe\n |  \n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |  \n |  from_yaml(yaml_text) from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |  \n |  all_names\n |      Returns all vocs names (variables, constants, objectives, constraints)\n |  \n |  bounds\n |      Returns a bounds array (mins, maxs) of shape (2, n_variables)\n |      Arrays of lower and upper bounds can be extracted by:\n |          mins, maxs = vocs.bounds\n |  \n |  constant_names\n |      Returns a sorted list of constraint names\n |  \n |  constraint_names\n |      Returns a sorted list of constraint names\n |  \n |  n_constants\n |      Returns the number of constants\n |  \n |  n_constraints\n |      Returns the number of constraints\n |  \n |  n_inputs\n |      Returns the number of inputs (variables and constants)\n |  \n |  n_objectives\n |      Returns the number of objectives\n |  \n |  n_observables\n |      Returns the number of constraints\n |  \n |  n_outputs\n |      Returns the number of outputs\n |          len(objectives + constraints + observables)\n |  \n |  n_variables\n |      Returns the number of variables\n |  \n |  objective_names\n |      Returns a sorted list of objective names\n |  \n |  observable_names\n |  \n |  output_names\n |      Returns a list of expected output keys:\n |          (objectives + constraints + observables)\n |      Each sub-list is sorted.\n |  \n |  variable_names\n |      Returns a sorted list of variable names\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  __abstractmethods__ = frozenset()\n |  \n |  __annotations__ = {'constants': typing.Dict[str, typing.Any], 'constra...\n |  \n |  __class_vars__ = set()\n |  \n |  __private_attributes__ = {}\n |  \n |  __pydantic_complete__ = True\n |  \n |  __pydantic_core_schema__ = {'cls': &lt;class 'xopt.vocs.VOCS'&gt;, 'config':...\n |  \n |  __pydantic_custom_init__ = False\n |  \n |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...\n |  \n |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...\n |  \n |  __pydantic_parent_namespace__ = {'Any': &lt;weakref at 0x7fc54cfd9e20; to...\n |  \n |  __pydantic_post_init__ = None\n |  \n |  __pydantic_serializer__ = SchemaSerializer(serializer=Function(\n |      Fu...\n |  \n |  __pydantic_validator__ = SchemaValidator(title=\"VOCS\", validator=Model...\n |  \n |  __signature__ = &lt;Signature (*, variables: Dict[str, Annotated[Li... An...\n |  \n |  model_config = {'arbitrary_types_allowed': True, 'extra': 'forbid', 'u...\n |  \n |  model_fields = {'constants': FieldInfo(annotation=Dict[str, Any], requ...\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from xopt.pydantic.XoptBaseModel:\n |  \n |  serialize_json(self, sinfo: pydantic_core.core_schema.SerializationInfo) -&gt; dict\n |      # Note that this function still returns a dict, NOT a string. Pydantic will handle\n |      # final serialization of basic types in Rust.\n |  \n |  to_json(self, **kwargs) -&gt; str\n |  \n |  ----------------------------------------------------------------------\n |  Class methods inherited from xopt.pydantic.XoptBaseModel:\n |  \n |  from_dict(config: dict) from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  from_file(filename: str) from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  validate_files(value, info: pydantic_core.core_schema.ValidationInfo) from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from xopt.pydantic.XoptBaseModel:\n |  \n |  __weakref__\n |      list of weak references to the object (if defined)\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from pydantic.main.BaseModel:\n |  \n |  __copy__(self: 'Model') -&gt; 'Model'\n |      Returns a shallow copy of the model.\n |  \n |  __deepcopy__(self: 'Model', memo: 'dict[int, Any] | None' = None) -&gt; 'Model'\n |      Returns a deep copy of the model.\n |  \n |  __delattr__(self, item: 'str') -&gt; 'Any'\n |      Implement delattr(self, name).\n |  \n |  __eq__(self, other: 'Any') -&gt; 'bool'\n |      Return self==value.\n |  \n |  __getattr__(self, item: 'str') -&gt; 'Any'\n |  \n |  __getstate__(self) -&gt; 'dict[Any, Any]'\n |  \n |  __init__(__pydantic_self__, **data: 'Any') -&gt; 'None'\n |      Create a new model by parsing and validating input data from keyword arguments.\n |      \n |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n |      validated to form a valid model.\n |      \n |      `__init__` uses `__pydantic_self__` instead of the more common `self` for the first arg to\n |      allow `self` as a field name.\n |  \n |  __iter__(self) -&gt; 'TupleGenerator'\n |      So `dict(model)` works.\n |  \n |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -&gt; 'typing.Generator[Any, None, None]'\n |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.\n |  \n |  __repr__(self) -&gt; 'str'\n |      Return repr(self).\n |  \n |  __repr_args__(self) -&gt; '_repr.ReprArgs'\n |  \n |  __repr_name__(self) -&gt; 'str'\n |      Name of the instance's class, used in __repr__.\n |  \n |  __repr_str__(self, join_str: 'str') -&gt; 'str'\n |  \n |  __rich_repr__(self) -&gt; 'RichReprResult'\n |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.\n |  \n |  __setattr__(self, name: 'str', value: 'Any') -&gt; 'None'\n |      Implement setattr(self, name, value).\n |  \n |  __setstate__(self, state: 'dict[Any, Any]') -&gt; 'None'\n |  \n |  __str__(self) -&gt; 'str'\n |      Return str(self).\n |  \n |  copy(self: 'Model', *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'typing.Dict[str, Any] | None' = None, deep: 'bool' = False) -&gt; 'Model'\n |      Returns a copy of the model.\n |      \n |      !!! warning \"Deprecated\"\n |          This method is now deprecated; use `model_copy` instead.\n |      \n |      If you need `include` or `exclude`, use:\n |      \n |      ```py\n |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n |      data = {**data, **(update or {})}\n |      copied = self.model_validate(data)\n |      ```\n |      \n |      Args:\n |          include: Optional set or mapping\n |              specifying which fields to include in the copied model.\n |          exclude: Optional set or mapping\n |              specifying which fields to exclude in the copied model.\n |          update: Optional dictionary of field-value pairs to override field values\n |              in the copied model.\n |          deep: If True, the values of fields that are Pydantic models will be deep copied.\n |      \n |      Returns:\n |          A copy of the model with included, excluded and updated fields as specified.\n |  \n |  dict(self, *, include: 'IncEx' = None, exclude: 'IncEx' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -&gt; 'typing.Dict[str, Any]'\n |  \n |  json(self, *, include: 'IncEx' = None, exclude: 'IncEx' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -&gt; 'str'\n |  \n |  model_copy(self: 'Model', *, update: 'dict[str, Any] | None' = None, deep: 'bool' = False) -&gt; 'Model'\n |      Usage docs: https://docs.pydantic.dev/2.4/concepts/serialization/#model_copy\n |      \n |      Returns a copy of the model.\n |      \n |      Args:\n |          update: Values to change/add in the new model. Note: the data is not validated\n |              before creating the new model. You should trust this data.\n |          deep: Set to `True` to make a deep copy of the model.\n |      \n |      Returns:\n |          New model instance.\n |  \n |  model_dump(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx' = None, exclude: 'IncEx' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: 'bool' = True) -&gt; 'dict[str, Any]'\n |      Usage docs: https://docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump\n |      \n |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n |      \n |      Args:\n |          mode: The mode in which `to_python` should run.\n |              If mode is 'json', the dictionary will only contain JSON serializable types.\n |              If mode is 'python', the dictionary may contain any Python objects.\n |          include: A list of fields to include in the output.\n |          exclude: A list of fields to exclude from the output.\n |          by_alias: Whether to use the field's alias in the dictionary key if defined.\n |          exclude_unset: Whether to exclude fields that are unset or None from the output.\n |          exclude_defaults: Whether to exclude fields that are set to their default value from the output.\n |          exclude_none: Whether to exclude fields that have a value of `None` from the output.\n |          round_trip: Whether to enable serialization and deserialization round-trip support.\n |          warnings: Whether to log warnings when invalid fields are encountered.\n |      \n |      Returns:\n |          A dictionary representation of the model.\n |  \n |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx' = None, exclude: 'IncEx' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: 'bool' = True) -&gt; 'str'\n |      Usage docs: https://docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json\n |      \n |      Generates a JSON representation of the model using Pydantic's `to_json` method.\n |      \n |      Args:\n |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n |          include: Field(s) to include in the JSON output. Can take either a string or set of strings.\n |          exclude: Field(s) to exclude from the JSON output. Can take either a string or set of strings.\n |          by_alias: Whether to serialize using field aliases.\n |          exclude_unset: Whether to exclude fields that have not been explicitly set.\n |          exclude_defaults: Whether to exclude fields that have the default value.\n |          exclude_none: Whether to exclude fields that have a value of `None`.\n |          round_trip: Whether to use serialization/deserialization between JSON and class instance.\n |          warnings: Whether to show any warnings that occurred during serialization.\n |      \n |      Returns:\n |          A JSON string representation of the model.\n |  \n |  model_post_init(self, _BaseModel__context: 'Any') -&gt; 'None'\n |      Override this method to perform additional initialization after `__init__` and `model_construct`.\n |      This is useful if you want to do some validation that requires the entire model to be initialized.\n |  \n |  ----------------------------------------------------------------------\n |  Class methods inherited from pydantic.main.BaseModel:\n |  \n |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -&gt; 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  __get_pydantic_core_schema__(_BaseModel__source: 'type[BaseModel]', _BaseModel__handler: 'GetCoreSchemaHandler') -&gt; 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass\n |      Hook into generating the model's CoreSchema.\n |      \n |      Args:\n |          __source: The class we are generating a schema for.\n |              This will generally be the same as the `cls` argument if this is a classmethod.\n |          __handler: Call into Pydantic's internal JSON schema generation.\n |              A callable that calls into Pydantic's internal CoreSchema generation logic.\n |      \n |      Returns:\n |          A `pydantic-core` `CoreSchema`.\n |  \n |  __get_pydantic_json_schema__(_BaseModel__core_schema: 'CoreSchema', _BaseModel__handler: 'GetJsonSchemaHandler') -&gt; 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass\n |      Hook into generating the model's JSON schema.\n |      \n |      Args:\n |          __core_schema: A `pydantic-core` CoreSchema.\n |              You can ignore this argument and call the handler with a new CoreSchema,\n |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n |              or just call the handler with the original schema.\n |          __handler: Call into Pydantic's internal JSON schema generation.\n |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n |              generation fails.\n |              Since this gets called by `BaseModel.model_json_schema` you can override the\n |              `schema_generator` argument to that function to change JSON schema generation globally\n |              for a type.\n |      \n |      Returns:\n |          A JSON schema, as a Python object.\n |  \n |  __pydantic_init_subclass__(**kwargs: 'Any') -&gt; 'None' from pydantic._internal._model_construction.ModelMetaclass\n |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will\n |      be present when this is called.\n |      \n |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n |      \n |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n |      any kwargs passed to the class definition that aren't used internally by pydantic.\n |      \n |      Args:\n |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n |              by pydantic.\n |  \n |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -&gt; 'Model' from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  from_orm(obj: 'Any') -&gt; 'Model' from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -&gt; 'Model' from pydantic._internal._model_construction.ModelMetaclass\n |      Creates a new instance of the `Model` class with validated data.\n |      \n |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n |      Default values are respected, but no other validation is performed.\n |      Behaves as if `Config.extra = 'allow'` was set since it adds all passed values\n |      \n |      Args:\n |          _fields_set: The set of field names accepted for the Model instance.\n |          values: Trusted or pre-validated data dictionary.\n |      \n |      Returns:\n |          A new instance of the `Model` class with validated data.\n |  \n |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;, mode: 'JsonSchemaMode' = 'validation') -&gt; 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass\n |      Generates a JSON schema for a model class.\n |      \n |      Args:\n |          by_alias: Whether to use attribute aliases or not.\n |          ref_template: The reference template.\n |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n |              `GenerateJsonSchema` with your desired modifications\n |          mode: The mode in which to generate the schema.\n |      \n |      Returns:\n |          The JSON schema for the given model class.\n |  \n |  model_parametrized_name(params: 'tuple[type[Any], ...]') -&gt; 'str' from pydantic._internal._model_construction.ModelMetaclass\n |      Compute the class name for parametrizations of generic classes.\n |      \n |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n |      \n |      Args:\n |          params: Tuple of types of the class. Given a generic class\n |              `Model` with 2 type variables and a concrete model `Model[str, int]`,\n |              the value `(str, int)` would be passed to `params`.\n |      \n |      Returns:\n |          String representing the new class where `params` are passed to `cls` as type variables.\n |      \n |      Raises:\n |          TypeError: Raised when trying to generate concrete names for non-generic models.\n |  \n |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'dict[str, Any] | None' = None) -&gt; 'bool | None' from pydantic._internal._model_construction.ModelMetaclass\n |      Try to rebuild the pydantic-core schema for the model.\n |      \n |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n |      the initial attempt to build the schema, and automatic rebuilding fails.\n |      \n |      Args:\n |          force: Whether to force the rebuilding of the model schema, defaults to `False`.\n |          raise_errors: Whether to raise errors, defaults to `True`.\n |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n |          _types_namespace: The types namespace, defaults to `None`.\n |      \n |      Returns:\n |          Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n |  \n |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'dict[str, Any] | None' = None) -&gt; 'Model' from pydantic._internal._model_construction.ModelMetaclass\n |      Validate a pydantic model instance.\n |      \n |      Args:\n |          obj: The object to validate.\n |          strict: Whether to raise an exception on invalid fields.\n |          from_attributes: Whether to extract data from object attributes.\n |          context: Additional context to pass to the validator.\n |      \n |      Raises:\n |          ValidationError: If the object could not be validated.\n |      \n |      Returns:\n |          The validated model instance.\n |  \n |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'dict[str, Any] | None' = None) -&gt; 'Model' from pydantic._internal._model_construction.ModelMetaclass\n |      Validate the given JSON data against the Pydantic model.\n |      \n |      Args:\n |          json_data: The JSON data to validate.\n |          strict: Whether to enforce types strictly.\n |          context: Extra variables to pass to the validator.\n |      \n |      Returns:\n |          The validated Pydantic model.\n |      \n |      Raises:\n |          ValueError: If `json_data` is not a JSON string.\n |  \n |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'dict[str, Any] | None' = None) -&gt; 'Model' from pydantic._internal._model_construction.ModelMetaclass\n |      Validate the given object contains string data against the Pydantic model.\n |      \n |      Args:\n |          obj: The object contains string data to validate.\n |          strict: Whether to enforce types strictly.\n |          context: Extra variables to pass to the validator.\n |      \n |      Returns:\n |          The validated Pydantic model.\n |  \n |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -&gt; 'Model' from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  parse_obj(obj: 'Any') -&gt; 'Model' from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -&gt; 'Model' from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -&gt; 'typing.Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -&gt; 'str' from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  update_forward_refs(**localns: 'Any') -&gt; 'None' from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  validate(value: 'Any') -&gt; 'Model' from pydantic._internal._model_construction.ModelMetaclass\n |  \n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pydantic.main.BaseModel:\n |  \n |  __fields__\n |  \n |  __fields_set__\n |  \n |  model_computed_fields\n |      Get the computed fields of this model instance.\n |      \n |      Returns:\n |          A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\n |  \n |  model_extra\n |      Get extra fields set during validation.\n |      \n |      Returns:\n |          A dictionary of extra fields, or `None` if `config.extra` is not set to `\"allow\"`.\n |  \n |  model_fields_set\n |      Returns the set of fields that have been set on this model instance.\n |      \n |      Returns:\n |          A set of strings representing the fields that have been set,\n |              i.e. that were not filled from defaults.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from pydantic.main.BaseModel:\n |  \n |  __dict__\n |      dictionary for instance variables (if defined)\n |  \n |  __pydantic_extra__\n |  \n |  __pydantic_fields_set__\n |  \n |  __pydantic_private__\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from pydantic.main.BaseModel:\n |  \n |  __hash__ = None\n |  \n |  __pydantic_root_model__ = False\n\n</pre> In\u00a0[3]: Copied! <pre>Y = \"\"\"\nvariables:\n  a: [0, 1e3] # Note that 1e3 usually parses as a str with YAML. \n  b: [-1, 1]\nobjectives:\n  c: maximize\n  d: minimize \nconstraints:\n  e: ['Less_than', 2]\n  f: ['greater_than', 0]\nconstants:\n  g: 1234\n\n\"\"\"\n\nvocs = VOCS.from_yaml(Y)\nvocs\n</pre> Y = \"\"\" variables:   a: [0, 1e3] # Note that 1e3 usually parses as a str with YAML.    b: [-1, 1] objectives:   c: maximize   d: minimize  constraints:   e: ['Less_than', 2]   f: ['greater_than', 0] constants:   g: 1234  \"\"\"  vocs = VOCS.from_yaml(Y) vocs Out[3]: <pre>VOCS(variables={'a': [0.0, 1000.0], 'b': [-1.0, 1.0]}, constraints={'e': ['LESS_THAN', 2.0], 'f': ['GREATER_THAN', 0.0]}, objectives={'c': 'MAXIMIZE', 'd': 'MINIMIZE'}, constants={'g': 1234}, observables=[])</pre> In\u00a0[4]: Copied! <pre># as dict\nvocs.dict()\n</pre> # as dict vocs.dict() <pre>/tmp/ipykernel_2801/20160725.py:2: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.4/migration/\n  vocs.dict()\n</pre> Out[4]: <pre>{'variables': {'a': [0.0, 1000.0], 'b': [-1.0, 1.0]},\n 'constraints': {'e': ['LESS_THAN', 2.0], 'f': ['GREATER_THAN', 0.0]},\n 'objectives': {'c': 'MAXIMIZE', 'd': 'MINIMIZE'},\n 'constants': {'g': 1234},\n 'observables': []}</pre> In\u00a0[5]: Copied! <pre>#  re-parse dict\nvocs2 = VOCS.parse_obj(vocs.dict())\n</pre> #  re-parse dict vocs2 = VOCS.parse_obj(vocs.dict()) <pre>/tmp/ipykernel_2801/3773362369.py:2: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.4/migration/\n  vocs2 = VOCS.parse_obj(vocs.dict())\n/tmp/ipykernel_2801/3773362369.py:2: PydanticDeprecatedSince20: The `parse_obj` method is deprecated; use `model_validate` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.4/migration/\n  vocs2 = VOCS.parse_obj(vocs.dict())\n</pre> In\u00a0[6]: Copied! <pre># Check that these are the same\nvocs2 == vocs\n</pre> # Check that these are the same vocs2 == vocs Out[6]: <pre>True</pre> In\u00a0[7]: Copied! <pre># This replaces the old vocs[\"variables\"]\ngetattr(vocs, \"variables\")\n</pre> # This replaces the old vocs[\"variables\"] getattr(vocs, \"variables\") Out[7]: <pre>{'a': [0.0, 1000.0], 'b': [-1.0, 1.0]}</pre> In\u00a0[8]: Copied! <pre>vocs.objectives[\"c\"] == 'MAXIMIZE'\n</pre> vocs.objectives[\"c\"] == 'MAXIMIZE' Out[8]: <pre>True</pre> In\u00a0[9]: Copied! <pre># json\nvocs.json()\n</pre> # json vocs.json() <pre>/tmp/ipykernel_2801/1166166515.py:2: PydanticDeprecatedSince20: The `json` method is deprecated; use `model_dump_json` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.4/migration/\n  vocs.json()\n</pre> Out[9]: <pre>'{\"variables\":{\"a\":[0.0,1000.0],\"b\":[-1.0,1.0]},\"constraints\":{\"e\":[\"LESS_THAN\",2.0],\"f\":[\"GREATER_THAN\",0.0]},\"objectives\":{\"c\":\"MAXIMIZE\",\"d\":\"MINIMIZE\"},\"constants\":{\"g\":1234},\"observables\":[]}'</pre> In\u00a0[10]: Copied! <pre>from xopt.vocs import form_objective_data, form_constraint_data, form_feasibility_data\nimport pandas as pd\nimport numpy as np\n\ndata = pd.DataFrame(vocs.random_inputs(10))\n# Add some outputs\ndata[\"c\"] = data[\"a\"] + data[\"b\"]\ndata[\"d\"] = data[\"a\"] - data[\"b\"]\ndata[\"e\"] = data[\"a\"] * 2 + data[\"b\"] * 2\ndata[\"f\"] = data[\"a\"] * 2 - data[\"b\"] * 2\ndata.index = np.arange(len(data)) + 5  # custom index\ndata\n</pre> from xopt.vocs import form_objective_data, form_constraint_data, form_feasibility_data import pandas as pd import numpy as np  data = pd.DataFrame(vocs.random_inputs(10)) # Add some outputs data[\"c\"] = data[\"a\"] + data[\"b\"] data[\"d\"] = data[\"a\"] - data[\"b\"] data[\"e\"] = data[\"a\"] * 2 + data[\"b\"] * 2 data[\"f\"] = data[\"a\"] * 2 - data[\"b\"] * 2 data.index = np.arange(len(data)) + 5  # custom index data Out[10]: a b g c d e f 5 695.565235 0.535904 1234 696.101139 695.029331 1392.202278 1390.058661 6 229.777907 -0.839272 1234 228.938635 230.617180 457.877270 461.234359 7 426.673302 -0.027573 1234 426.645730 426.700875 853.291460 853.401750 8 856.239440 0.200815 1234 856.440255 856.038626 1712.880510 1712.077252 9 104.968966 -0.969844 1234 103.999122 105.938811 207.998244 211.877621 10 817.272395 0.535278 1234 817.807673 816.737116 1635.615346 1633.474233 11 723.964763 -0.870283 1234 723.094480 724.835046 1446.188960 1449.670091 12 823.192521 0.720923 1234 823.913444 822.471598 1647.826888 1644.943196 13 414.793922 -0.687150 1234 414.106772 415.481073 828.213544 830.962145 14 895.058281 -0.697968 1234 894.360313 895.756249 1788.720626 1791.512498 In\u00a0[11]: Copied! <pre>vocs.objectives\n</pre> vocs.objectives Out[11]: <pre>{'c': 'MAXIMIZE', 'd': 'MINIMIZE'}</pre> In\u00a0[12]: Copied! <pre># These are in standard form for minimization\nform_objective_data(vocs.objectives, data)\n</pre> # These are in standard form for minimization form_objective_data(vocs.objectives, data) Out[12]: objective_c objective_d 5 -696.101139 695.029331 6 -228.938635 230.617180 7 -426.645730 426.700875 8 -856.440255 856.038626 9 -103.999122 105.938811 10 -817.807673 816.737116 11 -723.094480 724.835046 12 -823.913444 822.471598 13 -414.106772 415.481073 14 -894.360313 895.756249 In\u00a0[13]: Copied! <pre># This is also available as a method\nvocs.objective_data(data)\n</pre> # This is also available as a method vocs.objective_data(data) Out[13]: objective_c objective_d 5 -696.101139 695.029331 6 -228.938635 230.617180 7 -426.645730 426.700875 8 -856.440255 856.038626 9 -103.999122 105.938811 10 -817.807673 816.737116 11 -723.094480 724.835046 12 -823.913444 822.471598 13 -414.106772 415.481073 14 -894.360313 895.756249 In\u00a0[14]: Copied! <pre># use the to_numpy() method to convert for low level use.\nvocs.objective_data(data).to_numpy()\n</pre> # use the to_numpy() method to convert for low level use. vocs.objective_data(data).to_numpy() Out[14]: <pre>array([[-696.10113881,  695.02933063],\n       [-228.9386348 ,  230.61717951],\n       [-426.64572976,  426.7008752 ],\n       [-856.44025514,  856.03862586],\n       [-103.99912214,  105.93881068],\n       [-817.8076732 ,  816.73711646],\n       [-723.09447998,  724.83504564],\n       [-823.9134438 ,  822.4715979 ],\n       [-414.10677225,  415.48107261],\n       [-894.36031289,  895.75624894]])</pre> In\u00a0[15]: Copied! <pre>vocs.constraint_data(data)\n</pre> vocs.constraint_data(data) Out[15]: constraint_e constraint_f 5 1390.202278 -1390.058661 6 455.877270 -461.234359 7 851.291460 -853.401750 8 1710.880510 -1712.077252 9 205.998244 -211.877621 10 1633.615346 -1633.474233 11 1444.188960 -1449.670091 12 1645.826888 -1644.943196 13 826.213544 -830.962145 14 1786.720626 -1791.512498 In\u00a0[16]: Copied! <pre>vocs.feasibility_data(data)\n</pre> vocs.feasibility_data(data) Out[16]: feasible_e feasible_f feasible 5 False True False 6 False True False 7 False True False 8 False True False 9 False True False 10 False True False 11 False True False 12 False True False 13 False True False 14 False True False In\u00a0[17]: Copied! <pre>Y = \"\"\"\nvariables:\n  a: [0, 1e3] # Note that 1e3 usually parses as a str with YAML. \n  b: [-1, 1]\nobjectives:\n  c: maximize\n  d: minimize \nconstraints:\n  e: ['Less_than', 2]\n  f: ['greater_than', 0]\nconstants:\n  g: 1234\n\n\"\"\"\n\nvocs = VOCS.from_yaml(Y)\n</pre> Y = \"\"\" variables:   a: [0, 1e3] # Note that 1e3 usually parses as a str with YAML.    b: [-1, 1] objectives:   c: maximize   d: minimize  constraints:   e: ['Less_than', 2]   f: ['greater_than', 0] constants:   g: 1234  \"\"\"  vocs = VOCS.from_yaml(Y) In\u00a0[18]: Copied! <pre>d = {'a': [1,2,3]}\n\ndf = pd.DataFrame(d)\ndf2 = pd.DataFrame(df).copy()\n\ndf2['b'] = np.nan\ndf2['b'] - 1\n</pre> d = {'a': [1,2,3]}  df = pd.DataFrame(d) df2 = pd.DataFrame(df).copy()  df2['b'] = np.nan df2['b'] - 1 Out[18]: <pre>0   NaN\n1   NaN\n2   NaN\nName: b, dtype: float64</pre> In\u00a0[19]: Copied! <pre>data['a']  = np.nan\n</pre> data['a']  = np.nan In\u00a0[20]: Copied! <pre>a = 2\ndef f(x=a):\n    return x\na=99\nf()\n</pre> a = 2 def f(x=a):     return x a=99 f() Out[20]: <pre>2</pre> In\u00a0[21]: Copied! <pre>pd.DataFrame(6e66, index=[1,2,3], columns=['A'])\n</pre> pd.DataFrame(6e66, index=[1,2,3], columns=['A']) Out[21]: A 1 6.000000e+66 2 6.000000e+66 3 6.000000e+66 In\u00a0[22]: Copied! <pre># These are in standard form for minimization\n\ndata = pd.DataFrame({'c':[1,2,3,4]}, index=[9,3,4,5])\n\nform_objective_data(vocs.objectives, data)\n</pre> # These are in standard form for minimization  data = pd.DataFrame({'c':[1,2,3,4]}, index=[9,3,4,5])  form_objective_data(vocs.objectives, data) Out[22]: objective_c objective_d 9 -1.0 inf 3 -2.0 inf 4 -3.0 inf 5 -4.0 inf"},{"location":"examples/basic/xopt_vocs/#vocs-data-structure","title":"VOCS data structure\u00b6","text":"<p>Variables, Objectives, Constraints, and other Settings (VOCS) helps define our optimization problems.</p>"},{"location":"examples/basic/xopt_vocs/#objective-evaluation","title":"Objective Evaluation\u00b6","text":""},{"location":"examples/basic/xopt_vocs/#error-handling","title":"Error handling\u00b6","text":""},{"location":"examples/bayes_exp/bayesian_exploration/","title":"Bayesian Exploration","text":"In\u00a0[1]: Copied! <pre># set values if testing\nimport os\nSMOKE_TEST = os.environ.get(\"SMOKE_TEST\")\nNUM_MC_SAMPLES = 1 if SMOKE_TEST else 128\nNUM_RESTARTS = 1 if SMOKE_TEST else 20\n\n# Ignore all warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport pandas as pd\nimport torch\nfrom copy import deepcopy\nfrom xopt import Xopt, Evaluator\nfrom xopt.generators.bayesian import BayesianExplorationGenerator\nfrom xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs\n\nvocs = deepcopy(tnk_vocs)\n\n# can only explore one objective\ndel vocs.objectives[\"y2\"]\n\ngenerator = BayesianExplorationGenerator(vocs=vocs)\ngenerator.max_travel_distances = [0.25, 0.25]\ngenerator.numerical_optimizer.n_restarts = NUM_RESTARTS\ngenerator.n_monte_carlo_samples = NUM_MC_SAMPLES\n\nevaluator = Evaluator(function=evaluate_TNK)\n\nX = Xopt(generator=generator, evaluator=evaluator, vocs=vocs)\nX\n</pre> # set values if testing import os SMOKE_TEST = os.environ.get(\"SMOKE_TEST\") NUM_MC_SAMPLES = 1 if SMOKE_TEST else 128 NUM_RESTARTS = 1 if SMOKE_TEST else 20  # Ignore all warnings import warnings warnings.filterwarnings(\"ignore\")  import pandas as pd import torch from copy import deepcopy from xopt import Xopt, Evaluator from xopt.generators.bayesian import BayesianExplorationGenerator from xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs  vocs = deepcopy(tnk_vocs)  # can only explore one objective del vocs.objectives[\"y2\"]  generator = BayesianExplorationGenerator(vocs=vocs) generator.max_travel_distances = [0.25, 0.25] generator.numerical_optimizer.n_restarts = NUM_RESTARTS generator.n_monte_carlo_samples = NUM_MC_SAMPLES  evaluator = Evaluator(function=evaluate_TNK)  X = Xopt(generator=generator, evaluator=evaluator, vocs=vocs) X Out[1]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: xopt.resources.test_functions.tnk.evaluate_TNK\n  function_kwargs:\n    raise_probability: 0\n    random_sleep: 0\n    sleep: 0\n  max_workers: 1\n  vectorized: false\ngenerator:\n  computation_time: null\n  fixed_features: null\n  gp_constructor:\n    covar_modules: {}\n    mean_modules: {}\n    name: standard\n    trainable_mean_keys: []\n    use_low_noise_prior: true\n  max_travel_distances:\n  - 0.25\n  - 0.25\n  model: null\n  n_candidates: 1\n  n_monte_carlo_samples: 128\n  name: bayesian_exploration\n  numerical_optimizer:\n    max_iter: 2000\n    n_raw_samples: 20\n    n_restarts: 20\n    name: LBFGS\n  turbo_controller: null\n  use_cuda: false\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants:\n    a: dummy_constant\n  constraints:\n    c1:\n    - GREATER_THAN\n    - 0.0\n    c2:\n    - LESS_THAN\n    - 0.5\n  objectives:\n    y1: MINIMIZE\n  observables: []\n  variables:\n    x1:\n    - 0.0\n    - 3.14159\n    x2:\n    - 0.0\n    - 3.14159\n</pre> In\u00a0[2]: Copied! <pre>X.evaluate_data({\"x1\":[1.0, 0.75],\"x2\":[0.7, 0.95]})\n</pre> X.evaluate_data({\"x1\":[1.0, 0.75],\"x2\":[0.7, 0.95]}) Out[2]: x1 x2 y1 y2 c1 c2 xopt_runtime xopt_error 0 1.00 0.70 1.00 0.70 0.584045 0.290 0.000055 False 1 0.75 0.95 0.75 0.95 0.494833 0.265 0.000011 False In\u00a0[3]: Copied! <pre>for i in range(2):\n    print(f\"step {i}\")\n    X.step()\n</pre> for i in range(2):     print(f\"step {i}\")     X.step() <pre>step 0\nstep 1\n</pre> In\u00a0[4]: Copied! <pre># view the data\nX.data\n</pre> # view the data X.data Out[4]: x1 x2 y1 y2 c1 c2 xopt_runtime xopt_error 0 1.000000 0.700000 1.000000 0.700000 0.584045 0.290000 0.000055 False 1 0.750000 0.950000 0.750000 0.950000 0.494833 0.265000 0.000011 False 3 1.535397 1.735397 1.535397 1.735397 4.313110 2.598255 0.000045 False 4 2.320795 0.950000 2.320795 0.950000 5.188811 3.517794 0.000037 False In\u00a0[5]: Copied! <pre># plot results\nax = X.data.plot(\"x1\", \"x2\")\nax.set_aspect(\"equal\")\n</pre> # plot results ax = X.data.plot(\"x1\", \"x2\") ax.set_aspect(\"equal\") In\u00a0[6]: Copied! <pre>from matplotlib import pyplot as plt  # plot model predictions\n\ndata = X.data\n\nbounds = X.generator.vocs.bounds\nmodel = X.generator.train_model(generator.data)\n\n# create mesh\nn = 100\nx = torch.linspace(*bounds.T[0], n)\ny = torch.linspace(*bounds.T[1], n)\nxx, yy = torch.meshgrid(x, y)\npts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()\n\nxx, yy = xx.numpy(), yy.numpy()\n\noutputs = X.generator.vocs.output_names\nwith torch.no_grad():\n    post = model.posterior(pts)\n\n    for i in range(len(vocs.output_names)):\n        mean = post.mean[...,i]\n        fig, ax = plt.subplots()\n        ax.plot(*data[[\"x1\", \"x2\"]].to_numpy().T, \"+C1\")\n\n        if vocs.output_names[i] == \"c2\":\n            c = ax.pcolor(\n                xx, yy, mean.squeeze().reshape(n, n),\n                cmap=\"seismic\",\n                vmin=-10.0 + 0.5,\n                vmax=10.0 + 0.5)\n        else:\n            c = ax.pcolor(\n                xx, yy, mean.squeeze().reshape(n, n),\n                cmap=\"seismic\",\n                vmin=-10.0,\n                vmax=10.0)\n        fig.colorbar(c)\n        ax.set_title(f\"Posterior mean: {outputs[i]}\")\n</pre> from matplotlib import pyplot as plt  # plot model predictions  data = X.data  bounds = X.generator.vocs.bounds model = X.generator.train_model(generator.data)  # create mesh n = 100 x = torch.linspace(*bounds.T[0], n) y = torch.linspace(*bounds.T[1], n) xx, yy = torch.meshgrid(x, y) pts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()  xx, yy = xx.numpy(), yy.numpy()  outputs = X.generator.vocs.output_names with torch.no_grad():     post = model.posterior(pts)      for i in range(len(vocs.output_names)):         mean = post.mean[...,i]         fig, ax = plt.subplots()         ax.plot(*data[[\"x1\", \"x2\"]].to_numpy().T, \"+C1\")          if vocs.output_names[i] == \"c2\":             c = ax.pcolor(                 xx, yy, mean.squeeze().reshape(n, n),                 cmap=\"seismic\",                 vmin=-10.0 + 0.5,                 vmax=10.0 + 0.5)         else:             c = ax.pcolor(                 xx, yy, mean.squeeze().reshape(n, n),                 cmap=\"seismic\",                 vmin=-10.0,                 vmax=10.0)         fig.colorbar(c)         ax.set_title(f\"Posterior mean: {outputs[i]}\") In\u00a0[7]: Copied! <pre>from xopt.generators.bayesian.objectives import feasibility\n\nacq_func = X.generator.get_acquisition(model)\nwith torch.no_grad():\n    acq_pts = pts.unsqueeze(1)\n    acq = acq_func(acq_pts)\n\n    fig, ax = plt.subplots()\n    c = ax.pcolor(xx, yy, acq.reshape(n, n))\n    ax.plot(*data[[\"x1\", \"x2\"]].to_numpy().T, \"+C3\")\n\n    fig.colorbar(c)\n    ax.set_title(\"Acquisition function\")\n\n    feas = feasibility(pts.unsqueeze(1), model, vocs).flatten()\n\n    fig2, ax2 = plt.subplots()\n    c = ax2.pcolor(xx, yy, feas.reshape(n, n))\n    ax2.plot(*data[[\"x1\", \"x2\"]].to_numpy().T, \"+C3\")\n\n    fig2.colorbar(c)\n    ax2.set_title(\"Feasible Region\")\n</pre> from xopt.generators.bayesian.objectives import feasibility  acq_func = X.generator.get_acquisition(model) with torch.no_grad():     acq_pts = pts.unsqueeze(1)     acq = acq_func(acq_pts)      fig, ax = plt.subplots()     c = ax.pcolor(xx, yy, acq.reshape(n, n))     ax.plot(*data[[\"x1\", \"x2\"]].to_numpy().T, \"+C3\")      fig.colorbar(c)     ax.set_title(\"Acquisition function\")      feas = feasibility(pts.unsqueeze(1), model, vocs).flatten()      fig2, ax2 = plt.subplots()     c = ax2.pcolor(xx, yy, feas.reshape(n, n))     ax2.plot(*data[[\"x1\", \"x2\"]].to_numpy().T, \"+C3\")      fig2.colorbar(c)     ax2.set_title(\"Feasible Region\") In\u00a0[8]: Copied! <pre># print generator model hyperparameters\nfor name, val in X.generator.model.named_parameters():\n    print(f\"{name}:{val}\")\n\nX.generator.model.models[2].covar_module.base_kernel.lengthscale\n</pre> # print generator model hyperparameters for name, val in X.generator.model.named_parameters():     print(f\"{name}:{val}\")  X.generator.model.models[2].covar_module.base_kernel.lengthscale <pre>models.0.likelihood.noise_covar.raw_noise:Parameter containing:\ntensor([-21.2665], dtype=torch.float64, requires_grad=True)\nmodels.0.mean_module.raw_constant:Parameter containing:\ntensor(0.1767, dtype=torch.float64, requires_grad=True)\nmodels.0.covar_module.raw_outputscale:Parameter containing:\ntensor(1.3871, dtype=torch.float64, requires_grad=True)\nmodels.0.covar_module.base_kernel.raw_lengthscale:Parameter containing:\ntensor([[-0.7966, -0.5403]], dtype=torch.float64, requires_grad=True)\nmodels.1.likelihood.noise_covar.raw_noise:Parameter containing:\ntensor([-19.9967], dtype=torch.float64, requires_grad=True)\nmodels.1.mean_module.raw_constant:Parameter containing:\ntensor(0.2075, dtype=torch.float64, requires_grad=True)\nmodels.1.covar_module.raw_outputscale:Parameter containing:\ntensor(1.3080, dtype=torch.float64, requires_grad=True)\nmodels.1.covar_module.base_kernel.raw_lengthscale:Parameter containing:\ntensor([[-0.7754, -0.6686]], dtype=torch.float64, requires_grad=True)\nmodels.2.likelihood.noise_covar.raw_noise:Parameter containing:\ntensor([-16.5975], dtype=torch.float64, requires_grad=True)\nmodels.2.mean_module.raw_constant:Parameter containing:\ntensor(0.2351, dtype=torch.float64, requires_grad=True)\nmodels.2.covar_module.raw_outputscale:Parameter containing:\ntensor(1.2653, dtype=torch.float64, requires_grad=True)\nmodels.2.covar_module.base_kernel.raw_lengthscale:Parameter containing:\ntensor([[-0.8121, -0.6410]], dtype=torch.float64, requires_grad=True)\n</pre> Out[8]: <pre>tensor([[0.3674, 0.4232]], dtype=torch.float64, grad_fn=&lt;SoftplusBackward0&gt;)</pre> In\u00a0[9]: Copied! <pre>X.vocs.feasibility_data(X.data)\n</pre> X.vocs.feasibility_data(X.data) Out[9]: feasible_c1 feasible_c2 feasible 0 True True True 1 True True True 3 True False False 4 True False False In\u00a0[10]: Copied! <pre># generate next point\nX.generator.generate(1)\n</pre> # generate next point X.generator.generate(1) Out[10]: <pre>[{'x1': 1.583186986709278, 'x2': 0.16460249999999998}]</pre> In\u00a0[10]: Copied! <pre>\n</pre>"},{"location":"examples/bayes_exp/bayesian_exploration/#bayesian-exploration","title":"Bayesian Exploration\u00b6","text":"<p>Here we demonstrate the use of Bayesian Exploration to characterize an unknown function in the presence of constraints (see here). The function we wish to explore is the first objective of the TNK test problem.</p>"},{"location":"examples/bayes_exp/bayesian_exploration/#specifiying-generator-options","title":"Specifiying generator options\u00b6","text":"<p>We start with the generator defaults and modify as needed for conservative exploration, which should prevent any constraint violations.</p>"},{"location":"examples/bayes_exp/bayesian_exploration/#run-exploration","title":"Run exploration\u00b6","text":"<p>We start with evaluating 2 points that we know satisfy the constraints. We then run 30 exploration steps.</p>"},{"location":"examples/bayes_exp/bayesian_exploration/#introspect-models","title":"Introspect models\u00b6","text":"<p>During exploration we generate Gaussian Process models of each objective and constraint. We demonstrate how they are viewed below.</p>"},{"location":"examples/bayes_exp/bayesian_exploration/#view-acquisition-function-and-feasibility-prediction","title":"View acquisition function and feasibility prediction\u00b6","text":""},{"location":"examples/bayes_exp/bayesian_exploration/#generator-model-hyperparameters","title":"Generator model hyperparameters\u00b6","text":""},{"location":"examples/bayes_exp/bayesian_exploration/#examine-the-number-of-constraint-violations","title":"Examine the number of constraint violations\u00b6","text":"<p>Using the convience function provided by the vocs object we can evaluate which samples violate either or both of our constraints.</p>"},{"location":"examples/bayes_exp/bayesian_exploration_from_yaml/","title":"Bayesian Exploration from yaml","text":"In\u00a0[1]: Copied! <pre>import warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport torch\nfrom xopt import Xopt\n\n# set values if testing\nimport os\nSMOKE_TEST = os.environ.get(\"SMOKE_TEST\")\n\nYAML = \"\"\"\ngenerator:\n    name: bayesian_exploration\n\nevaluator:\n    function: xopt.resources.test_functions.tnk.evaluate_TNK\n\nvocs:\n    variables:\n        x1: [0, 3.14159]\n        x2: [0, 3.14159]\n    objectives: {y1: MINIMIZE}\n    constraints:\n        c1: [GREATER_THAN, 0]\n        c2: [LESS_THAN, 0.5]\n    constants: {a: dummy_constant}\n\n\"\"\"\n</pre> import warnings warnings.filterwarnings(\"ignore\")  import torch from xopt import Xopt  # set values if testing import os SMOKE_TEST = os.environ.get(\"SMOKE_TEST\")  YAML = \"\"\" generator:     name: bayesian_exploration  evaluator:     function: xopt.resources.test_functions.tnk.evaluate_TNK  vocs:     variables:         x1: [0, 3.14159]         x2: [0, 3.14159]     objectives: {y1: MINIMIZE}     constraints:         c1: [GREATER_THAN, 0]         c2: [LESS_THAN, 0.5]     constants: {a: dummy_constant}  \"\"\" In\u00a0[2]: Copied! <pre>X = Xopt.from_yaml(YAML)\n\n\n# for testing purposes only\nif SMOKE_TEST:\n    X.generator.numerical_optimizer.n_restarts = 1\n    X.generator.n_monte_carlo_samples = 1\n\nX\n</pre>  X = Xopt.from_yaml(YAML)   # for testing purposes only if SMOKE_TEST:     X.generator.numerical_optimizer.n_restarts = 1     X.generator.n_monte_carlo_samples = 1  X Out[2]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: xopt.resources.test_functions.tnk.evaluate_TNK\n  function_kwargs:\n    raise_probability: 0\n    random_sleep: 0\n    sleep: 0\n  max_workers: 1\n  vectorized: false\ngenerator:\n  computation_time: null\n  fixed_features: null\n  gp_constructor:\n    covar_modules: {}\n    mean_modules: {}\n    name: standard\n    trainable_mean_keys: []\n    use_low_noise_prior: true\n  max_travel_distances: null\n  model: null\n  n_candidates: 1\n  n_monte_carlo_samples: 128\n  name: bayesian_exploration\n  numerical_optimizer:\n    max_iter: 2000\n    n_raw_samples: 20\n    n_restarts: 20\n    name: LBFGS\n  turbo_controller: null\n  use_cuda: false\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants:\n    a: dummy_constant\n  constraints:\n    c1:\n    - GREATER_THAN\n    - 0.0\n    c2:\n    - LESS_THAN\n    - 0.5\n  objectives:\n    y1: MINIMIZE\n  observables: []\n  variables:\n    x1:\n    - 0.0\n    - 3.14159\n    x2:\n    - 0.0\n    - 3.14159\n</pre> In\u00a0[3]: Copied! <pre>X.random_evaluate(5)\n\nfor i in range(5):\n    print(f\"step {i}\")\n    X.step()\n</pre> X.random_evaluate(5)  for i in range(5):     print(f\"step {i}\")     X.step() <pre>step 0\nstep 1\nstep 2\nstep 3\nstep 4\n</pre> In\u00a0[4]: Copied! <pre>print(X.data)\n</pre> print(X.data) <pre>          x1        x2               a        y1        y2         c1  \\\n0   2.635767  2.747567  dummy_constant  2.635767  2.747567  13.401861   \n1   0.144308  2.110451  dummy_constant  0.144308  2.110451   3.428787   \n2   0.436990  1.419577  dummy_constant  0.436990  1.419577   1.199601   \n3   1.968521  0.499873  dummy_constant  1.968521  0.499873   3.191898   \n4   2.178164  2.460937  dummy_constant  2.178164  2.460937   9.744414   \n6   0.000000  0.000000             NaN  0.000000  0.000000  -1.100000   \n7   1.063580  0.000000             NaN  1.063580  0.000000   0.031202   \n8   1.229606  1.266165             NaN  1.229606  1.266165   2.017837   \n9   0.000000  1.123489             NaN  0.000000  1.123489   0.162227   \n10  0.815362  0.986905             NaN  0.815362  0.986905   0.633552   \n\n          c2  xopt_runtime  xopt_error  \n0   9.613058      0.000068       False  \n1   2.720069      0.000013       False  \n2   0.849592      0.000009       False  \n3   2.156553      0.000009       False  \n4   6.661507      0.000008       False  \n6   0.500000      0.000037       False  \n7   0.567622      0.000039       False  \n8   1.119333      0.000040       False  \n9   0.638738      0.000039       False  \n10  0.336529      0.000036       False  \n</pre> In\u00a0[5]: Copied! <pre># plot results\nax = X.data.plot(\"x1\", \"x2\")\nax.set_aspect(\"equal\")\n</pre> # plot results ax = X.data.plot(\"x1\", \"x2\") ax.set_aspect(\"equal\") In\u00a0[6]: Copied! <pre>from matplotlib import pyplot as plt  # plot model predictions\n\ndata = X.data\n\nbounds = X.generator.vocs.bounds\nmodel = X.generator.model\n\n# create mesh\nn = 50\nx = torch.linspace(*bounds.T[0], n)\ny = torch.linspace(*bounds.T[1], n)\nxx, yy = torch.meshgrid(x, y)\npts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()\n\nxx, yy = xx.numpy(), yy.numpy()\n\noutputs = X.generator.vocs.output_names\nwith torch.no_grad():\n    post = model.posterior(pts)\n\n    for i in range(len(X.vocs.output_names)):\n        mean = post.mean[...,i]\n        fig, ax = plt.subplots()\n        ax.plot(*data[[\"x1\", \"x2\"]].to_numpy().T, \"+C1\")\n        c = ax.pcolor(\n            xx, yy, mean.squeeze().reshape(n, n),\n            cmap=\"seismic\",\n            vmin=-10.0,\n            vmax=10.0)\n        fig.colorbar(c)\n        ax.set_title(f\"Posterior mean: {outputs[i]}\")\n</pre> from matplotlib import pyplot as plt  # plot model predictions  data = X.data  bounds = X.generator.vocs.bounds model = X.generator.model  # create mesh n = 50 x = torch.linspace(*bounds.T[0], n) y = torch.linspace(*bounds.T[1], n) xx, yy = torch.meshgrid(x, y) pts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()  xx, yy = xx.numpy(), yy.numpy()  outputs = X.generator.vocs.output_names with torch.no_grad():     post = model.posterior(pts)      for i in range(len(X.vocs.output_names)):         mean = post.mean[...,i]         fig, ax = plt.subplots()         ax.plot(*data[[\"x1\", \"x2\"]].to_numpy().T, \"+C1\")         c = ax.pcolor(             xx, yy, mean.squeeze().reshape(n, n),             cmap=\"seismic\",             vmin=-10.0,             vmax=10.0)         fig.colorbar(c)         ax.set_title(f\"Posterior mean: {outputs[i]}\") In\u00a0[7]: Copied! <pre>from xopt.generators.bayesian.objectives import feasibility\n\nacq_func = X.generator.get_acquisition(model)\nwith torch.no_grad():\n    acq_pts = pts.unsqueeze(1)\n    acq = acq_func(acq_pts)\n\n    fig, ax = plt.subplots()\n    c = ax.pcolor(xx, yy, acq.reshape(n, n))\n    fig.colorbar(c)\n    ax.set_title(\"Acquisition function\")\n\n    feas = feasibility(pts.unsqueeze(1), model, X.vocs).flatten()\n\n    fig2, ax2 = plt.subplots()\n    c = ax2.pcolor(xx, yy, feas.reshape(n, n))\n    fig2.colorbar(c)\n    ax2.set_title(\"Feasible Region\")\n</pre> from xopt.generators.bayesian.objectives import feasibility  acq_func = X.generator.get_acquisition(model) with torch.no_grad():     acq_pts = pts.unsqueeze(1)     acq = acq_func(acq_pts)      fig, ax = plt.subplots()     c = ax.pcolor(xx, yy, acq.reshape(n, n))     fig.colorbar(c)     ax.set_title(\"Acquisition function\")      feas = feasibility(pts.unsqueeze(1), model, X.vocs).flatten()      fig2, ax2 = plt.subplots()     c = ax2.pcolor(xx, yy, feas.reshape(n, n))     fig2.colorbar(c)     ax2.set_title(\"Feasible Region\") In\u00a0[7]: Copied! <pre>\n</pre>"},{"location":"examples/bayes_exp/bayesian_exploration_with_nans/","title":"Bayesian Exploration with NaNs","text":"In\u00a0[1]: Copied! <pre># set values if testing\nimport os\nSMOKE_TEST = os.environ.get(\"SMOKE_TEST\")\nNUM_MC_SAMPLES = 1 if SMOKE_TEST else 128\nNUM_RESTARTS = 1 if SMOKE_TEST else 20\n\n# Ignore all warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport pandas as pd\nimport torch\nimport yaml\nfrom copy import deepcopy\nfrom xopt import Xopt, Evaluator\nfrom xopt.generators.bayesian import BayesianExplorationGenerator\nfrom xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs\n\nvocs = deepcopy(tnk_vocs)\n\n# can only explore one objective\ndel vocs.objectives[\"y2\"]\n</pre> # set values if testing import os SMOKE_TEST = os.environ.get(\"SMOKE_TEST\") NUM_MC_SAMPLES = 1 if SMOKE_TEST else 128 NUM_RESTARTS = 1 if SMOKE_TEST else 20  # Ignore all warnings import warnings warnings.filterwarnings(\"ignore\")  import pandas as pd import torch import yaml from copy import deepcopy from xopt import Xopt, Evaluator from xopt.generators.bayesian import BayesianExplorationGenerator from xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs  vocs = deepcopy(tnk_vocs)  # can only explore one objective del vocs.objectives[\"y2\"] In\u00a0[2]: Copied! <pre># modify the evaluate function to return NaNs if constraints are violated\ndef evaluate(input_dict):\n    output_dict = evaluate_TNK(input_dict)\n    del output_dict[\"y2\"]\n    for c in vocs.constraints.keys():\n        if vocs.constraints[c][0].upper() == \"GREATER_THAN\" and output_dict[c] &lt;= vocs.constraints[c][1]:\n            output_dict[\"y1\"] = torch.nan\n        elif vocs.constraints[c][0].upper() == \"LESS_THAN\" and output_dict[c] &gt;= vocs.constraints[c][1]:\n            output_dict[\"y1\"] = torch.nan\n    return output_dict\n</pre> # modify the evaluate function to return NaNs if constraints are violated def evaluate(input_dict):     output_dict = evaluate_TNK(input_dict)     del output_dict[\"y2\"]     for c in vocs.constraints.keys():         if vocs.constraints[c][0].upper() == \"GREATER_THAN\" and output_dict[c] &lt;= vocs.constraints[c][1]:             output_dict[\"y1\"] = torch.nan         elif vocs.constraints[c][0].upper() == \"LESS_THAN\" and output_dict[c] &gt;= vocs.constraints[c][1]:             output_dict[\"y1\"] = torch.nan     return output_dict In\u00a0[3]: Copied! <pre>generator = BayesianExplorationGenerator(vocs=vocs)\ngenerator.max_travel_distances = [0.25, 0.25]\ngenerator.n_monte_carlo_samples = NUM_MC_SAMPLES\ngenerator.numerical_optimizer.n_restarts = NUM_RESTARTS\n\nevaluator = Evaluator(function=evaluate)\nX = Xopt(generator=generator, evaluator=evaluator, vocs=vocs)\nX\n</pre> generator = BayesianExplorationGenerator(vocs=vocs) generator.max_travel_distances = [0.25, 0.25] generator.n_monte_carlo_samples = NUM_MC_SAMPLES generator.numerical_optimizer.n_restarts = NUM_RESTARTS  evaluator = Evaluator(function=evaluate) X = Xopt(generator=generator, evaluator=evaluator, vocs=vocs) X Out[3]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: __main__.evaluate\n  function_kwargs: {}\n  max_workers: 1\n  vectorized: false\ngenerator:\n  computation_time: null\n  fixed_features: null\n  gp_constructor:\n    covar_modules: {}\n    mean_modules: {}\n    name: standard\n    trainable_mean_keys: []\n    use_low_noise_prior: true\n  max_travel_distances:\n  - 0.25\n  - 0.25\n  model: null\n  n_candidates: 1\n  n_monte_carlo_samples: 128\n  name: bayesian_exploration\n  numerical_optimizer:\n    max_iter: 2000\n    n_raw_samples: 20\n    n_restarts: 20\n    name: LBFGS\n  turbo_controller: null\n  use_cuda: false\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants:\n    a: dummy_constant\n  constraints:\n    c1:\n    - GREATER_THAN\n    - 0.0\n    c2:\n    - LESS_THAN\n    - 0.5\n  objectives:\n    y1: MINIMIZE\n  observables: []\n  variables:\n    x1:\n    - 0.0\n    - 3.14159\n    x2:\n    - 0.0\n    - 3.14159\n</pre> In\u00a0[4]: Copied! <pre>X.evaluate_data(pd.DataFrame({\"x1\": [1.0, 0.75], \"x2\": [0.7, 0.95]}))\n</pre> X.evaluate_data(pd.DataFrame({\"x1\": [1.0, 0.75], \"x2\": [0.7, 0.95]})) Out[4]: x1 x2 y1 c1 c2 xopt_runtime xopt_error 0 1.00 0.70 1.00 0.584045 0.290 0.000060 False 1 0.75 0.95 0.75 0.494833 0.265 0.000013 False In\u00a0[5]: Copied! <pre>N_STEPS = 1 if SMOKE_TEST else 30\nfor i in range(N_STEPS):\n    print(f\"step {i}\")\n    X.step()\n</pre> N_STEPS = 1 if SMOKE_TEST else 30 for i in range(N_STEPS):     print(f\"step {i}\")     X.step() <pre>step 0\nstep 1\nstep 2\nstep 3\nstep 4\nstep 5\nstep 6\nstep 7\nstep 8\nstep 9\nstep 10\nstep 11\nstep 12\nstep 13\nstep 14\nstep 15\nstep 16\nstep 17\nstep 18\nstep 19\nstep 20\nstep 21\nstep 22\nstep 23\nstep 24\nstep 25\nstep 26\nstep 27\nstep 28\nstep 29\n</pre> In\u00a0[6]: Copied! <pre># view the data\nX.data\n</pre> # view the data X.data Out[6]: x1 x2 y1 c1 c2 xopt_runtime xopt_error 0 1.000000 0.700000 1.000000 0.584045 0.290000 0.000060 False 1 0.750000 0.950000 0.750000 0.494833 0.265000 0.000013 False 3 1.535397 1.735397 NaN 4.313110 2.598255 0.000043 False 4 0.773108 2.299430 NaN 4.839151 3.312535 0.000046 False 5 0.000000 1.693387 NaN 1.767560 1.674173 0.000044 False 6 0.000000 0.907990 NaN -0.275555 0.416455 0.000045 False 7 0.385101 1.036023 0.385101 0.138499 0.300522 0.000053 False 8 0.810404 0.556801 0.810404 0.064645 0.099577 0.000046 False 9 1.309660 0.000000 NaN 0.615209 0.905549 0.000045 False 10 1.021538 0.257492 1.021538 0.178856 0.330812 0.000045 False 11 1.176386 0.539252 1.176386 0.591799 0.459039 0.000042 False 12 0.565113 0.000000 NaN -0.780648 0.254240 0.000045 False 13 1.002183 0.062117 NaN -0.046602 0.443930 0.000044 False 14 1.044976 0.073269 1.044976 0.053777 0.479098 0.000044 False 15 0.578871 0.858667 0.578871 0.172184 0.134863 0.000044 False 16 0.523664 1.156665 0.523664 0.525257 0.431769 0.000044 False 17 0.174230 1.095788 0.174230 0.312570 0.461089 0.000046 False 18 0.959628 0.980983 0.959628 0.784758 0.442602 0.000044 False 19 1.149694 0.274907 1.149694 0.479122 0.472769 0.000047 False 20 1.119348 0.800238 1.119348 0.980795 0.473734 0.000044 False 21 0.333950 0.978044 0.333950 0.015640 0.256099 0.000045 False 22 0.070933 1.046075 0.070933 0.052460 0.482296 0.000046 False 23 0.743356 1.139107 0.743356 0.948636 0.467680 0.000066 False 24 0.947875 0.382204 NaN -0.054319 0.214468 0.000046 False 25 0.319724 1.167601 0.319724 0.507743 0.478191 0.000044 False 26 0.912495 1.056719 0.912495 0.910262 0.480088 0.000045 False 27 1.196075 0.529834 1.196075 0.618782 0.485410 0.000046 False 28 0.578033 1.188531 0.578033 0.689328 0.480164 0.000043 False 29 0.958363 0.407168 NaN -0.014707 0.218715 0.000046 False 30 0.961200 0.411715 NaN -0.004749 0.220500 0.000045 False 31 0.961329 0.412214 NaN -0.003969 0.220531 0.000045 False 32 0.175932 0.297485 NaN -0.816810 0.146032 0.000044 False In\u00a0[7]: Copied! <pre># plot results\nax = X.data.plot(\"x1\", \"x2\")\nax.set_aspect(\"equal\")\n</pre> # plot results ax = X.data.plot(\"x1\", \"x2\") ax.set_aspect(\"equal\") In\u00a0[7]: Copied! <pre>\n</pre>"},{"location":"examples/bayes_exp/bayesian_exploration_with_nans/#bayesian-exploration-with-nans","title":"Bayesian Exploration with NaNs\u00b6","text":"<p>As violations of constraints can lead to invalid values of the objective, the evaluate function may simply return NaNs. We demonstrate below how we can still perform Bayesian Exploration in that case.</p>"},{"location":"examples/bayes_exp/bayesian_exploration_with_nans/#run-exploration","title":"Run exploration\u00b6","text":"<p>We start with evaluating 2 points that we know satisfy the constraints. We then run 30 exploration steps.</p>"},{"location":"examples/cnsga/cnsga_tnk/","title":"Xopt CNSGA algorithm","text":"In\u00a0[1]: Copied! <pre>from xopt.generators.ga.cnsga import CNSGAGenerator\n\nfrom xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs\n\nfrom xopt import Xopt, Evaluator\n\nimport pandas as pd\n</pre> from xopt.generators.ga.cnsga import CNSGAGenerator  from xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs  from xopt import Xopt, Evaluator  import pandas as pd In\u00a0[2]: Copied! <pre># Useful for debugging\n#%load_ext autoreload\n#%autoreload 2\n</pre> # Useful for debugging #%load_ext autoreload #%autoreload 2 In\u00a0[3]: Copied! <pre>ev = Evaluator(function=evaluate_TNK)\nev.function_kwargs = {'raise_probability':0.1} # optional random crashing, to mimic real-world use.\n</pre> ev = Evaluator(function=evaluate_TNK) ev.function_kwargs = {'raise_probability':0.1} # optional random crashing, to mimic real-world use.  In\u00a0[4]: Copied! <pre>X = Xopt(\n    generator=CNSGAGenerator(vocs=tnk_vocs),\n    evaluator=ev,\n    vocs=tnk_vocs,\n)\nX.strict = False\n</pre> X = Xopt(     generator=CNSGAGenerator(vocs=tnk_vocs),     evaluator=ev,     vocs=tnk_vocs, ) X.strict = False <p>Run 100 generations</p> In\u00a0[5]: Copied! <pre>%%time\nfor _ in range(64 * 20):\n    X.step()\n</pre> %%time for _ in range(64 * 20):     X.step() <pre>CPU times: user 6.52 s, sys: 9.16 ms, total: 6.53 s\nWall time: 6.53 s\n</pre> In\u00a0[6]: Copied! <pre>import matplotlib.pyplot as plt\n</pre> import matplotlib.pyplot as plt In\u00a0[7]: Copied! <pre>def plot_population(X):\n    fig, ax = plt.subplots(figsize=(8, 8))\n    \n    fdata = tnk_vocs.feasibility_data(X.data)\n    \n    k1 = \"x1\"\n    k2 = \"x2\"\n    \n    X.data.plot.scatter(k1, k2, marker=\".\", alpha=0.1, color=\"black\", ax=ax)\n    X.data[fdata[\"feasible\"]].plot.scatter(\n        k1, k2, marker=\"x\", alpha=0.3, color=\"orange\", ax=ax\n    )\n    X.generator.population.plot.scatter(k1, k2, marker=\"o\", color=\"red\", alpha=1, ax=ax)\n    ax.set_xlabel(k1)\n    ax.set_ylabel(k2)\n    ax.set_xlim(0, 1.5)\n    ax.set_ylim(0, 1.5)\n    ax.set_title(\"TNK with Xopt's CNSGA\")\n</pre> def plot_population(X):     fig, ax = plt.subplots(figsize=(8, 8))          fdata = tnk_vocs.feasibility_data(X.data)          k1 = \"x1\"     k2 = \"x2\"          X.data.plot.scatter(k1, k2, marker=\".\", alpha=0.1, color=\"black\", ax=ax)     X.data[fdata[\"feasible\"]].plot.scatter(         k1, k2, marker=\"x\", alpha=0.3, color=\"orange\", ax=ax     )     X.generator.population.plot.scatter(k1, k2, marker=\"o\", color=\"red\", alpha=1, ax=ax)     ax.set_xlabel(k1)     ax.set_ylabel(k2)     ax.set_xlim(0, 1.5)     ax.set_ylim(0, 1.5)     ax.set_title(\"TNK with Xopt's CNSGA\") In\u00a0[8]: Copied! <pre>plot_population(X)\n</pre> plot_population(X) <p>Write the current population</p> In\u00a0[9]: Copied! <pre>X.generator.write_population('test.csv')\n</pre> X.generator.write_population('test.csv') In\u00a0[10]: Copied! <pre>from xopt import Xopt\n</pre> from xopt import Xopt In\u00a0[11]: Copied! <pre>YAML = \"\"\"\nmax_evaluations: 6400\nstrict: False\ngenerator:\n    name: cnsga\n    population_size: 64\n    population_file: test.csv\n    output_path: .\n\nevaluator:\n    function: xopt.resources.test_functions.tnk.evaluate_TNK\n    function_kwargs:\n      raise_probability: 0.1\n\nvocs:\n    variables:\n        x1: [0, 3.14159]\n        x2: [0, 3.14159]\n    objectives: {y1: MINIMIZE, y2: MINIMIZE}\n    constraints:\n        c1: [GREATER_THAN, 0]\n        c2: [LESS_THAN, 0.5]\n    constants: {a: dummy_constant}\n\n\"\"\"\n\nX = Xopt.from_yaml(YAML)\nX\n</pre> YAML = \"\"\" max_evaluations: 6400 strict: False generator:     name: cnsga     population_size: 64     population_file: test.csv     output_path: .  evaluator:     function: xopt.resources.test_functions.tnk.evaluate_TNK     function_kwargs:       raise_probability: 0.1  vocs:     variables:         x1: [0, 3.14159]         x2: [0, 3.14159]     objectives: {y1: MINIMIZE, y2: MINIMIZE}     constraints:         c1: [GREATER_THAN, 0]         c2: [LESS_THAN, 0.5]     constants: {a: dummy_constant}  \"\"\"  X = Xopt.from_yaml(YAML) X Out[11]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: xopt.resources.test_functions.tnk.evaluate_TNK\n  function_kwargs:\n    raise_probability: 0.1\n    random_sleep: 0\n    sleep: 0\n  max_workers: 1\n  vectorized: false\ngenerator:\n  _loaded_population: null\n  children:\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7690801253006403\n    x2: 0.6848354696725094\n  - x1: 0.7363621389639367\n    x2: 0.766532642123451\n  - x1: 0.2099529298163064\n    x2: 0.9309528558213378\n  - x1: 0.918816998023264\n    x2: 0.4572336165025973\n  - x1: 0.780241885157405\n    x2: 0.6820670914629436\n  - x1: 0.780241885157405\n    x2: 0.6820670914629436\n  - x1: 0.9062610889123174\n    x2: 0.466474567410948\n  - x1: 0.185411429033436\n    x2: 0.9334023276894235\n  - x1: 0.7508806778234336\n    x2: 0.7378825078935344\n  - x1: 0.095452164258871\n    x2: 1.053919259278837\n  - x1: 0.1000332572045047\n    x2: 1.0510922511530447\n  - x1: 0.1000332572045047\n    x2: 1.0510922511530447\n  - x1: 0.9894862498673538\n    x2: 0.1312420367925243\n  - x1: 0.9894862498673538\n    x2: 0.1312420367925243\n  - x1: 0.6525727821871687\n    x2: 0.7725964571834152\n  - x1: 0.6525727821871687\n    x2: 0.7725964571834152\n  - x1: 0.6525727821871687\n    x2: 0.7725964571834152\n  - x1: 0.1185356217019275\n    x2: 1.0414380693365732\n  - x1: 0.5576956171788344\n    x2: 0.831593222541261\n  - x1: 0.7414254165740305\n    x2: 0.7660185316424393\n  - x1: 0.7465189164291419\n    x2: 0.7637802801044273\n  - x1: 0.7465189164291419\n    x2: 0.7637802801044273\n  - x1: 0.7465189164291419\n    x2: 0.7637802801044273\n  - x1: 0.9302642574337237\n    x2: 0.45090126523366\n  - x1: 0.50478637787372\n    x2: 0.8374341577548728\n  - x1: 0.7690213312227997\n    x2: 0.6893960879409602\n  - x1: 0.8091483986432814\n    x2: 0.5257322699621095\n  - x1: 1.003198197208763\n    x2: 0.0943762487837772\n  - x1: 0.1461446411557576\n    x2: 1.005269403799601\n  - x1: 0.9767568110236904\n    x2: 0.1764690268401511\n  - x1: 0.4966504725881908\n    x2: 0.930353714985436\n  - x1: 0.7933122499972374\n    x2: 0.5328706405388665\n  - x1: 0.1750308217963818\n    x2: 0.9346545946431988\n  - x1: 0.564246691596984\n    x2: 0.7770992338365466\n  - x1: 0.9393043610859896\n    x2: 0.2461959726103789\n  - x1: 0.1188636331088643\n    x2: 1.008063698394866\n  - x1: 0.7450928159269129\n    x2: 0.7651039856411074\n  - x1: 0.1062959496711582\n    x2: 1.0573244881958346\n  - x1: 1.003198197208763\n    x2: 0.0963335076438071\n  - x1: 1.003198197208763\n    x2: 0.0963335076438071\n  - x1: 0.50478637787372\n    x2: 0.8794688542064231\n  - x1: 0.2101868528411702\n    x2: 0.9309528558213378\n  - x1: 0.5645808601178524\n    x2: 0.7772850427699477\n  - x1: 0.9589745177630996\n    x2: 0.2837471783311834\n  - x1: 0.9523067226380704\n    x2: 0.444304179087313\n  crossover_probability: 0.9\n  mutation_probability: 1.0\n  name: cnsga\n  offspring: null\n  output_path: .\n  population: null\n  population_file: test.csv\n  population_size: 64\n  toolbox: deap.base.Toolbox\nmax_evaluations: 6400\nserialize_inline: false\nserialize_torch: false\nstrict: false\nvocs:\n  constants:\n    a: dummy_constant\n  constraints:\n    c1:\n    - GREATER_THAN\n    - 0.0\n    c2:\n    - LESS_THAN\n    - 0.5\n  objectives:\n    y1: MINIMIZE\n    y2: MINIMIZE\n  observables: []\n  variables:\n    x1:\n    - 0.0\n    - 3.14159\n    x2:\n    - 0.0\n    - 3.14159\n</pre> <p>This will have loaded children from the population file. These will need to be re-evaluated.</p> In\u00a0[12]: Copied! <pre>len(X.generator.children)\n</pre> len(X.generator.children) Out[12]: <pre>64</pre> In\u00a0[13]: Copied! <pre>%%time\nX.run()\n</pre> %%time X.run() <pre>CPU times: user 32.5 s, sys: 83.9 ms, total: 32.6 s\nWall time: 32.6 s\n</pre> In\u00a0[14]: Copied! <pre>plot_population(X)\n</pre> plot_population(X) In\u00a0[15]: Copied! <pre>len(X.data)\n</pre> len(X.data) Out[15]: <pre>6400</pre> <p>Setting <code>output_path</code> will write .csv files for each population, as well as the offspring considered in each generation</p> In\u00a0[16]: Copied! <pre>from glob import glob\npop_files = sorted(glob(\"cnsga_population*\"))\npop_files[:10]\n</pre> from glob import glob pop_files = sorted(glob(\"cnsga_population*\")) pop_files[:10] Out[16]: <pre>['cnsga_population_2023-09-27T16:15:54.354824+00:00.csv',\n 'cnsga_population_2023-09-27T16:15:54.673596+00:00.csv',\n 'cnsga_population_2023-09-27T16:15:54.991043+00:00.csv',\n 'cnsga_population_2023-09-27T16:15:55.308978+00:00.csv',\n 'cnsga_population_2023-09-27T16:15:55.630145+00:00.csv',\n 'cnsga_population_2023-09-27T16:15:55.947956+00:00.csv',\n 'cnsga_population_2023-09-27T16:15:56.260366+00:00.csv',\n 'cnsga_population_2023-09-27T16:15:56.575861+00:00.csv',\n 'cnsga_population_2023-09-27T16:15:56.896182+00:00.csv',\n 'cnsga_population_2023-09-27T16:15:57.214855+00:00.csv']</pre> In\u00a0[17]: Copied! <pre>offspring_files = sorted(glob(\"cnsga_offspring*\"))\noffspring_files[0:10]\n</pre> offspring_files = sorted(glob(\"cnsga_offspring*\")) offspring_files[0:10] Out[17]: <pre>['cnsga_offspring_2023-09-27T16:15:54.352962+00:00.csv',\n 'cnsga_offspring_2023-09-27T16:15:54.671784+00:00.csv',\n 'cnsga_offspring_2023-09-27T16:15:54.989285+00:00.csv',\n 'cnsga_offspring_2023-09-27T16:15:55.307155+00:00.csv',\n 'cnsga_offspring_2023-09-27T16:15:55.628306+00:00.csv',\n 'cnsga_offspring_2023-09-27T16:15:55.946173+00:00.csv',\n 'cnsga_offspring_2023-09-27T16:15:56.258552+00:00.csv',\n 'cnsga_offspring_2023-09-27T16:15:56.574057+00:00.csv',\n 'cnsga_offspring_2023-09-27T16:15:56.894365+00:00.csv',\n 'cnsga_offspring_2023-09-27T16:15:57.213104+00:00.csv']</pre> In\u00a0[18]: Copied! <pre>from xopt.utils import read_xopt_csv\npop_df = read_xopt_csv(pop_files[-1])\npop_df.plot.scatter(\"x1\", \"x2\", marker=\"o\", color=\"red\", alpha=1)\n</pre> from xopt.utils import read_xopt_csv pop_df = read_xopt_csv(pop_files[-1]) pop_df.plot.scatter(\"x1\", \"x2\", marker=\"o\", color=\"red\", alpha=1) Out[18]: <pre>&lt;Axes: xlabel='x1', ylabel='x2'&gt;</pre> <p>Similarly, offsrping files can be loaded. This will load the last few:</p> In\u00a0[19]: Copied! <pre>offspring_df = read_xopt_csv(*offspring_files[-10:])\noffspring_df.plot.scatter(\"x1\", \"x2\", marker=\".\", color=\"black\", alpha=.1)\n</pre> offspring_df = read_xopt_csv(*offspring_files[-10:]) offspring_df.plot.scatter(\"x1\", \"x2\", marker=\".\", color=\"black\", alpha=.1) Out[19]: <pre>&lt;Axes: xlabel='x1', ylabel='x2'&gt;</pre> <p>Occationally there are duplicates in offspring</p> In\u00a0[20]: Copied! <pre>all_offspring = read_xopt_csv(*offspring_files) \nlen(all_offspring), len(all_offspring.drop_duplicates())\n</pre> all_offspring = read_xopt_csv(*offspring_files)  len(all_offspring), len(all_offspring.drop_duplicates()) Out[20]: <pre>(6400, 6347)</pre> In\u00a0[21]: Copied! <pre># Cleanup\n!rm cnsga_population*\n!rm cnsga_offspring*\n!rm test.csv\n</pre> # Cleanup !rm cnsga_population* !rm cnsga_offspring* !rm test.csv In\u00a0[22]: Copied! <pre>df = pd.DataFrame(X.generator.generate(1000))\n\nfig, ax = plt.subplots()\ndf.plot.scatter(\"x1\", \"x2\", marker=\".\", color=\"green\", alpha=0.5, ax=ax, label='candidates')\npop_df.plot.scatter(\"x1\", \"x2\", marker=\"o\", color=\"red\", alpha=1, ax=ax, label='population')\nplt.legend()\n</pre> df = pd.DataFrame(X.generator.generate(1000))  fig, ax = plt.subplots() df.plot.scatter(\"x1\", \"x2\", marker=\".\", color=\"green\", alpha=0.5, ax=ax, label='candidates') pop_df.plot.scatter(\"x1\", \"x2\", marker=\"o\", color=\"red\", alpha=1, ax=ax, label='population') plt.legend() Out[22]: <pre>&lt;matplotlib.legend.Legend at 0x7fbe2095cee0&gt;</pre> In\u00a0[23]: Copied! <pre># Notice that this returns `some_array`\nevaluate_TNK({'x1':1, 'x2':1})\n</pre> # Notice that this returns `some_array` evaluate_TNK({'x1':1, 'x2':1}) Out[23]: <pre>{'y1': 1, 'y2': 1, 'c1': 0.9, 'c2': 0.5}</pre> In\u00a0[24]: Copied! <pre># Here we make a version that does not have this\ndef evaluate_TNK2(*args, **kwargs):\n    outputs = evaluate_TNK(*args, **kwargs)\n    outputs.pop('some_array')\n    return outputs\n</pre> # Here we make a version that does not have this def evaluate_TNK2(*args, **kwargs):     outputs = evaluate_TNK(*args, **kwargs)     outputs.pop('some_array')     return outputs In\u00a0[25]: Copied! <pre>from xopt import Xopt\n\nYAML = \"\"\"\nmax_evaluations: 6400\nstrict: False\ngenerator:\n    name: cnsga\n    population_size: 64\n\nevaluator:\n    function: __main__.evaluate_TNK2\n    function_kwargs:\n      raise_probability: 0.1\n    vectorized: True\n    max_workers: 100 \n\nvocs:\n    variables:\n        x1: [0, 3.14159]\n        x2: [0, 3.14159]\n    objectives: {y1: MINIMIZE, y2: MINIMIZE}\n    constraints:\n        c1: [GREATER_THAN, 0]\n        c2: [LESS_THAN, 0.5]\n    constants: {a: dummy_constant}\n\n\"\"\"\n\n\nX2 = Xopt.from_yaml(YAML)\nX2.evaluator.function = evaluate_TNK2\n\nX2.run()\n\nlen(X2.data)\n</pre> from xopt import Xopt  YAML = \"\"\" max_evaluations: 6400 strict: False generator:     name: cnsga     population_size: 64  evaluator:     function: __main__.evaluate_TNK2     function_kwargs:       raise_probability: 0.1     vectorized: True     max_workers: 100   vocs:     variables:         x1: [0, 3.14159]         x2: [0, 3.14159]     objectives: {y1: MINIMIZE, y2: MINIMIZE}     constraints:         c1: [GREATER_THAN, 0]         c2: [LESS_THAN, 0.5]     constants: {a: dummy_constant}  \"\"\"   X2 = Xopt.from_yaml(YAML) X2.evaluator.function = evaluate_TNK2  X2.run()  len(X2.data) Out[25]: <pre>6400</pre> In\u00a0[26]: Copied! <pre>plot_population(X)\n</pre> plot_population(X) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/cnsga/cnsga_tnk/#xopt-cnsga-algorithm","title":"Xopt CNSGA algorithm\u00b6","text":""},{"location":"examples/cnsga/cnsga_tnk/#plot","title":"Plot\u00b6","text":""},{"location":"examples/cnsga/cnsga_tnk/#yaml-method","title":"YAML method\u00b6","text":""},{"location":"examples/cnsga/cnsga_tnk/#examine-generator","title":"Examine generator\u00b6","text":""},{"location":"examples/cnsga/cnsga_tnk/#vectorized-evaluation","title":"Vectorized evaluation\u00b6","text":"<p>Some functions also allow vectorized inputs. This can often be very fast.</p> <p>However, vectorized evaluation has some restrictions. For example, the output dict cannot append additional arrays with odd lengths.</p>"},{"location":"examples/es/extremum_seeking/","title":"Extremum seeking","text":"In\u00a0[1]: Copied! <pre># If you encounter the \"Initializing libomp.dylib, but found libomp.dylib already initialized.\" error\n# Please run this cell\n\nimport os\n</pre> # If you encounter the \"Initializing libomp.dylib, but found libomp.dylib already initialized.\" error # Please run this cell  import os  In\u00a0[2]: Copied! <pre># set values if testing\nSMOKE_TEST = os.environ.get(\"SMOKE_TEST\")\nNUM_STEPS = 10 if SMOKE_TEST else 1000\n</pre> # set values if testing SMOKE_TEST = os.environ.get(\"SMOKE_TEST\") NUM_STEPS = 10 if SMOKE_TEST else 1000 In\u00a0[3]: Copied! <pre>import numpy as np\nfrom xopt.generators.es.extremumseeking import ExtremumSeekingGenerator\nfrom xopt.vocs import VOCS\nfrom xopt.evaluator import Evaluator\nfrom xopt import Xopt\nfrom tqdm.auto import tqdm\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</pre> import numpy as np from xopt.generators.es.extremumseeking import ExtremumSeekingGenerator from xopt.vocs import VOCS from xopt.evaluator import Evaluator from xopt import Xopt from tqdm.auto import tqdm import warnings warnings.filterwarnings(\"ignore\") In\u00a0[4]: Copied! <pre>np.random.seed(42)  # set deterministic run\nimport pandas as pd\nnES = 10\n\n# This global dict is used as a counter to emulate drifting\nstates = {\n    'count': 0\n}\n\nnoise = 0.1 * np.random.randn(NUM_STEPS)\n\n# This is the unknown optimal point\np_opt = 1.5 * (2 * np.random.rand(nES) - 1)\n\n# Various frequencies for unknown points\nw_opt = 0.25 + 2 * np.random.rand(nES)\n\ndef f_ES_minimize(input_dict):\n    p = []\n    for i in range(10):\n        p.append(input_dict[f'p{i}'])\n    p = np.array(p)\n    \n    # Vary the optimal point with time\n    p_opt_i = np.zeros(nES)\n    i = states['count']\n    \n    outcome_dict = {}\n    for n in np.arange(nES):\n        p_opt_i[n] = p_opt[n] * (1 + np.sin(2 * np.pi * w_opt[n] * i / 2000))\n    # This simple cost will be distance from the optimal point\n    f_val = np.sum((p - p_opt_i) ** 2) + noise[i]\n    \n    states['count'] += 1\n    outcome_dict = {'f': f_val, 'p_opt': pd.Series(p_opt_i)}\n    \n    return outcome_dict\n</pre> np.random.seed(42)  # set deterministic run import pandas as pd nES = 10  # This global dict is used as a counter to emulate drifting states = {     'count': 0 }  noise = 0.1 * np.random.randn(NUM_STEPS)  # This is the unknown optimal point p_opt = 1.5 * (2 * np.random.rand(nES) - 1)  # Various frequencies for unknown points w_opt = 0.25 + 2 * np.random.rand(nES)  def f_ES_minimize(input_dict):     p = []     for i in range(10):         p.append(input_dict[f'p{i}'])     p = np.array(p)          # Vary the optimal point with time     p_opt_i = np.zeros(nES)     i = states['count']          outcome_dict = {}     for n in np.arange(nES):         p_opt_i[n] = p_opt[n] * (1 + np.sin(2 * np.pi * w_opt[n] * i / 2000))     # This simple cost will be distance from the optimal point     f_val = np.sum((p - p_opt_i) ** 2) + noise[i]          states['count'] += 1     outcome_dict = {'f': f_val, 'p_opt': pd.Series(p_opt_i)}          return outcome_dict In\u00a0[5]: Copied! <pre>YAML = \"\"\"\nmax_evaluations: 5000\ngenerator:\n    name: extremum_seeking\n    k: 2.0\n    oscillation_size: 0.1\n    decay_rate: 1.0\nevaluator:\n    function: __main__.f_ES_minimize\nvocs:\n    variables:\n        p0: [-2, 2]\n        p1: [-2, 2]\n        p2: [-2, 2]\n        p3: [-2, 2]\n        p4: [-2, 2]\n        p5: [-2, 2]\n        p6: [-2, 2]\n        p7: [-2, 2]\n        p8: [-2, 2]\n        p9: [-2, 2]\n    objectives:\n        f: MINIMIZE\n\"\"\"\n\nX = Xopt.from_yaml(YAML)\nX.max_evaluations = NUM_STEPS\n\nX\n</pre>  YAML = \"\"\" max_evaluations: 5000 generator:     name: extremum_seeking     k: 2.0     oscillation_size: 0.1     decay_rate: 1.0 evaluator:     function: __main__.f_ES_minimize vocs:     variables:         p0: [-2, 2]         p1: [-2, 2]         p2: [-2, 2]         p3: [-2, 2]         p4: [-2, 2]         p5: [-2, 2]         p6: [-2, 2]         p7: [-2, 2]         p8: [-2, 2]         p9: [-2, 2]     objectives:         f: MINIMIZE \"\"\"  X = Xopt.from_yaml(YAML) X.max_evaluations = NUM_STEPS  X Out[5]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: __main__.f_ES_minimize\n  function_kwargs: {}\n  max_workers: 1\n  vectorized: false\ngenerator:\n  decay_rate: 1.0\n  k: 2.0\n  name: extremum_seeking\n  oscillation_size: 0.1\nmax_evaluations: 1000\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants: {}\n  constraints: {}\n  objectives:\n    f: MINIMIZE\n  observables: []\n  variables:\n    p0:\n    - -2.0\n    - 2.0\n    p1:\n    - -2.0\n    - 2.0\n    p2:\n    - -2.0\n    - 2.0\n    p3:\n    - -2.0\n    - 2.0\n    p4:\n    - -2.0\n    - 2.0\n    p5:\n    - -2.0\n    - 2.0\n    p6:\n    - -2.0\n    - 2.0\n    p7:\n    - -2.0\n    - 2.0\n    p8:\n    - -2.0\n    - 2.0\n    p9:\n    - -2.0\n    - 2.0\n</pre> In\u00a0[6]: Copied! <pre># Reset global counter to guarantee deterministic optimization\nstates['count'] = 0\n\nX.random_evaluate(1)\nX.step()\n</pre> # Reset global counter to guarantee deterministic optimization states['count'] = 0  X.random_evaluate(1) X.step() <p>Now you can go directly to the Visualization section and check out the results.</p> In\u00a0[7]: Copied! <pre>variables = {}\nfor i in range(nES):\n    variables[f'p{i}'] = [-2, 2]\n\nvocs = VOCS(\n    variables=variables,\n    objectives={'f': 'MINIMIZE'},\n)\n</pre> variables = {} for i in range(nES):     variables[f'p{i}'] = [-2, 2]  vocs = VOCS(     variables=variables,     objectives={'f': 'MINIMIZE'}, ) In\u00a0[8]: Copied! <pre>vocs\n</pre> vocs Out[8]: <pre>VOCS(variables={'p0': [-2.0, 2.0], 'p1': [-2.0, 2.0], 'p2': [-2.0, 2.0], 'p3': [-2.0, 2.0], 'p4': [-2.0, 2.0], 'p5': [-2.0, 2.0], 'p6': [-2.0, 2.0], 'p7': [-2.0, 2.0], 'p8': [-2.0, 2.0], 'p9': [-2.0, 2.0]}, constraints={}, objectives={'f': 'MINIMIZE'}, constants={}, observables=[])</pre> In\u00a0[9]: Copied! <pre>evaluator = Evaluator(function=f_ES_minimize)\n</pre> evaluator = Evaluator(function=f_ES_minimize) In\u00a0[10]: Copied! <pre>generator = ExtremumSeekingGenerator(vocs=vocs)\n</pre> generator = ExtremumSeekingGenerator(vocs=vocs) In\u00a0[11]: Copied! <pre>generator.dict()\n</pre> generator.dict() Out[11]: <pre>{'k': 2.0, 'oscillation_size': 0.1, 'decay_rate': 1.0}</pre> <p>Note that ES has 3 hyper-parameters: <code>k</code>, <code>oscillation_size</code>, and <code>decay_rate</code>.</p> <ul> <li><code>k</code>: ES feedback gain (set <code>k &lt; 0</code> for maximization instead of minimization)</li> <li><code>oscillation_size</code>: ES dithering size</li> <li><code>decay_rate</code>: This value is optional, it causes the oscillation sizes to naturally decay. If you want the parameters to persistently oscillate without decay, set <code>decay_rate = 1.0</code></li> </ul> In\u00a0[12]: Copied! <pre>X = Xopt(vocs=vocs, evaluator=evaluator, generator=generator)\n</pre> X = Xopt(vocs=vocs, evaluator=evaluator, generator=generator) In\u00a0[13]: Copied! <pre>X.max_evaluations = NUM_STEPS\n</pre> X.max_evaluations = NUM_STEPS In\u00a0[14]: Copied! <pre># Reset global counter to guarantee deterministic optimization\nstates['count'] = 0\n\nfor i in tqdm(range(NUM_STEPS)):\n    X.step()\n</pre> # Reset global counter to guarantee deterministic optimization states['count'] = 0  for i in tqdm(range(NUM_STEPS)):     X.step() In\u00a0[15]: Copied! <pre>import matplotlib.pyplot as plt\n</pre> import matplotlib.pyplot as plt In\u00a0[16]: Copied! <pre># Plot all results\nplt.figure(1,figsize=(8,10))\n\nplt.subplot(2,1,1)\nplt.plot(X.data['f'])\nplt.ylabel('ES cost')\nplt.xticks([])\n\n\nplt.subplot(2,1,2)\nplt.plot(X.data[[f'p{i}' for i in range(10)]],alpha=0.25)\n_p_opt = np.vstack(X.data['p_opt'].values).astype(float)  # do not use p_opt as var name!\nplt.plot(_p_opt, 'k--')\nplt.plot(2+np.zeros(NUM_STEPS),'r')\nplt.plot(-2+np.zeros(NUM_STEPS),'r')\nplt.legend(frameon=False)\nplt.ylabel('ES parameter')\nplt.xlabel('ES step')\n\nplt.tight_layout()\n</pre> # Plot all results plt.figure(1,figsize=(8,10))  plt.subplot(2,1,1) plt.plot(X.data['f']) plt.ylabel('ES cost') plt.xticks([])   plt.subplot(2,1,2) plt.plot(X.data[[f'p{i}' for i in range(10)]],alpha=0.25) _p_opt = np.vstack(X.data['p_opt'].values).astype(float)  # do not use p_opt as var name! plt.plot(_p_opt, 'k--') plt.plot(2+np.zeros(NUM_STEPS),'r') plt.plot(-2+np.zeros(NUM_STEPS),'r') plt.legend(frameon=False) plt.ylabel('ES parameter') plt.xlabel('ES step')  plt.tight_layout() <pre>No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n</pre> In\u00a0[17]: Copied! <pre># Plot Individual Parameter Trajectories\nplt.figure(2,figsize=(15,8))\n\nfor n in np.arange(nES):\n    plt.subplot(2,5,n+1)\n    plt.plot(X.data[f'p{n}'],label=f'$p^{{ES}}_{n+1}$')\n    plt.plot(_p_opt[:,n],'k--',label=f'$p^*_{n+1}$')\n    plt.plot(2+np.zeros(NUM_STEPS),'r--')\n    plt.plot(-2+np.zeros(NUM_STEPS),'r--')\n    plt.ylim([-3,5])\n    plt.legend(frameon=False,loc=1)\n    if n == 0:\n        plt.ylabel('parameters')\n    elif n == 5:\n        plt.ylabel('parameters')\n    else:\n        plt.yticks([])\n    if n &gt; 4:\n        plt.xlabel('ES step')\n    else:\n        plt.xticks([])\n\nplt.tight_layout()\n</pre> # Plot Individual Parameter Trajectories plt.figure(2,figsize=(15,8))  for n in np.arange(nES):     plt.subplot(2,5,n+1)     plt.plot(X.data[f'p{n}'],label=f'$p^{{ES}}_{n+1}$')     plt.plot(_p_opt[:,n],'k--',label=f'$p^*_{n+1}$')     plt.plot(2+np.zeros(NUM_STEPS),'r--')     plt.plot(-2+np.zeros(NUM_STEPS),'r--')     plt.ylim([-3,5])     plt.legend(frameon=False,loc=1)     if n == 0:         plt.ylabel('parameters')     elif n == 5:         plt.ylabel('parameters')     else:         plt.yticks([])     if n &gt; 4:         plt.xlabel('ES step')     else:         plt.xticks([])  plt.tight_layout() In\u00a0[17]: Copied! <pre>\n</pre>"},{"location":"examples/es/extremum_seeking/#extremum-seeking-optimization","title":"Extremum Seeking Optimization\u00b6","text":"<p>In this example we demonstrate extremum seeking optimization. The optimum of the test evaluate function would drift around a center point and we would be trying to follow the trend by applying extremum seeking technique.</p>"},{"location":"examples/es/extremum_seeking/#extremum-seeking-test-problem","title":"Extremum seeking test problem\u00b6","text":"<p>This test problem is a 10-D quadratic function, with its optimum drifting around the initial position. We also add some noise to make the problem more realistic.</p>"},{"location":"examples/es/extremum_seeking/#run-es-on-the-test-problem-yaml-method","title":"Run ES on the test problem (YAML method)\u00b6","text":""},{"location":"examples/es/extremum_seeking/#run-es-on-the-test-problem-api-method","title":"Run ES on the test problem (API method)\u00b6","text":""},{"location":"examples/es/extremum_seeking/#vocs","title":"VOCS\u00b6","text":"<p>We'll set the bounds for all the variables pi to [-2, 2].</p>"},{"location":"examples/es/extremum_seeking/#evaluator","title":"Evaluator\u00b6","text":""},{"location":"examples/es/extremum_seeking/#generator","title":"Generator\u00b6","text":""},{"location":"examples/es/extremum_seeking/#run-the-optimization","title":"Run the optimization\u00b6","text":""},{"location":"examples/es/extremum_seeking/#visualization","title":"Visualization\u00b6","text":""},{"location":"examples/multi_objective_bayes_opt/mggpo/","title":"Multi-objective Bayesian Optimization","text":"In\u00a0[1]: Copied! <pre># set values if testing\nimport os\nSMOKE_TEST = os.environ.get(\"SMOKE_TEST\")\nN_MC_SAMPLES = 1 if SMOKE_TEST else 128\nNUM_RESTARTS = 1 if SMOKE_TEST else 20\n\n# Ignore all warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nfrom copy import deepcopy\n\nimport pandas as pd\nimport numpy as np\nimport torch\n\nfrom xopt import Xopt, Evaluator\nfrom xopt.generators import MGGPOGenerator\nfrom xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs\n\n\nevaluator = Evaluator(function=evaluate_TNK)\nevaluator.max_workers = 10\n\n# test check options\nvocs = deepcopy(tnk_vocs)\ngen = MGGPOGenerator(vocs=vocs, reference_point = {\"y1\":1.5,\"y2\":1.5})\ngen.n_monte_carlo_samples = N_MC_SAMPLES\ngen.numerical_optimizer.n_restarts = NUM_RESTARTS\nX = Xopt(evaluator=evaluator, generator=gen, vocs=vocs)\nX.evaluate_data(pd.DataFrame({\"x1\": [1.0, 0.75], \"x2\": [0.75, 1.0]}))\n\nX\n</pre> # set values if testing import os SMOKE_TEST = os.environ.get(\"SMOKE_TEST\") N_MC_SAMPLES = 1 if SMOKE_TEST else 128 NUM_RESTARTS = 1 if SMOKE_TEST else 20  # Ignore all warnings import warnings warnings.filterwarnings(\"ignore\")  from copy import deepcopy  import pandas as pd import numpy as np import torch  from xopt import Xopt, Evaluator from xopt.generators import MGGPOGenerator from xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs   evaluator = Evaluator(function=evaluate_TNK) evaluator.max_workers = 10  # test check options vocs = deepcopy(tnk_vocs) gen = MGGPOGenerator(vocs=vocs, reference_point = {\"y1\":1.5,\"y2\":1.5}) gen.n_monte_carlo_samples = N_MC_SAMPLES gen.numerical_optimizer.n_restarts = NUM_RESTARTS X = Xopt(evaluator=evaluator, generator=gen, vocs=vocs) X.evaluate_data(pd.DataFrame({\"x1\": [1.0, 0.75], \"x2\": [0.75, 1.0]}))  X Out[1]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 2\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: xopt.resources.test_functions.tnk.evaluate_TNK\n  function_kwargs:\n    raise_probability: 0\n    random_sleep: 0\n    sleep: 0\n  max_workers: 10\n  vectorized: false\ngenerator:\n  computation_time: null\n  fixed_features: null\n  ga_generator:\n    _loaded_population: null\n    children: []\n    crossover_probability: 0.9\n    mutation_probability: 1.0\n    offspring:\n      c1:\n        '0': 0.6268878452\n        '1': 0.6268878452\n      c2:\n        '0': 0.3125\n        '1': 0.3125\n      x1:\n        '0': 1.0\n        '1': 0.75\n      x2:\n        '0': 0.75\n        '1': 1.0\n      xopt_error:\n        '0': false\n        '1': false\n      xopt_runtime:\n        '0': 5.0903e-05\n        '1': 9.801e-06\n      y1:\n        '0': 1.0\n        '1': 0.75\n      y2:\n        '0': 0.75\n        '1': 1.0\n    output_path: null\n    population: null\n    population_file: null\n    population_size: 64\n    toolbox: deap.base.Toolbox\n  gp_constructor:\n    covar_modules: {}\n    mean_modules: {}\n    name: standard\n    trainable_mean_keys: []\n    use_low_noise_prior: true\n  max_travel_distances: null\n  model: null\n  n_candidates: 1\n  n_monte_carlo_samples: 128\n  name: mggpo\n  numerical_optimizer:\n    max_iter: 2000\n    n_raw_samples: 20\n    n_restarts: 20\n    name: LBFGS\n  population_size: 64\n  reference_point:\n    y1: 1.5\n    y2: 1.5\n  turbo_controller: null\n  use_cuda: false\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants:\n    a: dummy_constant\n  constraints:\n    c1:\n    - GREATER_THAN\n    - 0.0\n    c2:\n    - LESS_THAN\n    - 0.5\n  objectives:\n    y1: MINIMIZE\n    y2: MINIMIZE\n  observables: []\n  variables:\n    x1:\n    - 0.0\n    - 3.14159\n    x2:\n    - 0.0\n    - 3.14159\n</pre> In\u00a0[2]: Copied! <pre>for i in range(10):\n    print(i)\n    X.step()\n</pre> for i in range(10):     print(i)     X.step() <pre>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</pre> In\u00a0[3]: Copied! <pre>X.generator.data\n</pre> X.generator.data Out[3]: x1 x2 y1 y2 c1 c2 xopt_runtime xopt_error 0 1.000000 0.750000 1.000000 0.750000 0.626888 0.312500 0.000051 False 1 0.750000 1.000000 0.750000 1.000000 0.626888 0.312500 0.000010 False 3 2.999502 0.387022 2.999502 0.387022 8.193182 6.260274 0.000042 False 4 2.914171 0.081353 2.914171 0.081353 7.408817 6.003488 0.000011 False 5 2.966572 1.150344 2.966572 1.150344 9.030411 6.506925 0.000009 False ... ... ... ... ... ... ... ... ... 98 0.172917 1.092768 0.172917 1.092768 0.304809 0.458357 0.000009 False 99 0.182336 1.091844 0.182336 1.091844 0.313412 0.451189 0.000008 False 100 0.189683 1.093791 0.189683 1.093791 0.324688 0.448884 0.000008 False 101 0.101629 0.963734 0.101629 0.963734 -0.049887 0.373748 0.000008 False 102 0.209454 1.007475 0.209454 1.007475 0.157924 0.341947 0.000008 False <p>102 rows \u00d7 8 columns</p> In\u00a0[4]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\ntheta = np.linspace(0, np.pi / 2)\nr = np.sqrt(1 + 0.1 * np.cos(16 * theta))\nx_1 = r * np.sin(theta)\nx_2_lower = r * np.cos(theta)\nx_2_upper = (0.5 - (x_1 - 0.5) ** 2) ** 0.5 + 0.5\n\nz = np.zeros_like(x_1)\n\n# ax2.plot(x_1, x_2_lower,'r')\nax.fill_between(x_1, z, x_2_lower, fc=\"white\")\ncircle = plt.Circle(\n    (0.5, 0.5), 0.5 ** 0.5, color=\"r\", alpha=0.25, zorder=0, label=\"Valid Region\"\n)\nax.add_patch(circle)\nhistory = pd.concat(\n    [X.data, tnk_vocs.feasibility_data(X.data)], axis=1, ignore_index=False\n)\n\nax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")\nax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")\n\nax.set_xlim(0, 3.14)\nax.set_ylim(0, 3.14)\nax.set_xlabel(\"x1\")\nax.set_ylabel(\"x2\")\nax.set_aspect(\"equal\")\n</pre> import matplotlib.pyplot as plt  fig, ax = plt.subplots()  theta = np.linspace(0, np.pi / 2) r = np.sqrt(1 + 0.1 * np.cos(16 * theta)) x_1 = r * np.sin(theta) x_2_lower = r * np.cos(theta) x_2_upper = (0.5 - (x_1 - 0.5) ** 2) ** 0.5 + 0.5  z = np.zeros_like(x_1)  # ax2.plot(x_1, x_2_lower,'r') ax.fill_between(x_1, z, x_2_lower, fc=\"white\") circle = plt.Circle(     (0.5, 0.5), 0.5 ** 0.5, color=\"r\", alpha=0.25, zorder=0, label=\"Valid Region\" ) ax.add_patch(circle) history = pd.concat(     [X.data, tnk_vocs.feasibility_data(X.data)], axis=1, ignore_index=False )  ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\") ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")  ax.set_xlim(0, 3.14) ax.set_ylim(0, 3.14) ax.set_xlabel(\"x1\") ax.set_ylabel(\"x2\") ax.set_aspect(\"equal\") In\u00a0[5]: Copied! <pre>from matplotlib import pyplot as plt  # plot model predictions\n\ndata = X.data\n\nbounds = X.generator.vocs.bounds\nmodel = X.generator.train_model(X.generator.data)\n\n# create mesh\nn = 50\nx = torch.linspace(*bounds.T[0], n)\ny = torch.linspace(*bounds.T[1], n)\nxx, yy = torch.meshgrid(x, y)\npts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()\n\nxx, yy = xx.numpy(), yy.numpy()\n\noutputs = X.generator.vocs.output_names\nwith torch.no_grad():\n    post = model.posterior(pts)\n\n    for i in range(len(vocs.output_names)):\n        mean = post.mean[...,i]\n        fig, ax = plt.subplots()\n        ax.plot(*data[[\"x1\", \"x2\"]].to_numpy().T, \"+C1\")\n        c = ax.pcolor(\n            xx, yy, mean.squeeze().reshape(n, n),\n            cmap=\"seismic\",\n            vmin=-10.0,\n            vmax=10.0)\n        fig.colorbar(c)\n        ax.set_title(f\"Posterior mean: {outputs[i]}\")\n</pre> from matplotlib import pyplot as plt  # plot model predictions  data = X.data  bounds = X.generator.vocs.bounds model = X.generator.train_model(X.generator.data)  # create mesh n = 50 x = torch.linspace(*bounds.T[0], n) y = torch.linspace(*bounds.T[1], n) xx, yy = torch.meshgrid(x, y) pts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()  xx, yy = xx.numpy(), yy.numpy()  outputs = X.generator.vocs.output_names with torch.no_grad():     post = model.posterior(pts)      for i in range(len(vocs.output_names)):         mean = post.mean[...,i]         fig, ax = plt.subplots()         ax.plot(*data[[\"x1\", \"x2\"]].to_numpy().T, \"+C1\")         c = ax.pcolor(             xx, yy, mean.squeeze().reshape(n, n),             cmap=\"seismic\",             vmin=-10.0,             vmax=10.0)         fig.colorbar(c)         ax.set_title(f\"Posterior mean: {outputs[i]}\") In\u00a0[6]: Copied! <pre># plot the acquisition function\nfrom xopt.generators.bayesian.objectives import feasibility\n\nbounds = X.generator.vocs.bounds\nmodel = X.generator.model\n\n# create mesh\nn = 25\nx = torch.linspace(*bounds.T[0], n)\ny = torch.linspace(*bounds.T[1], n)\nxx, yy = torch.meshgrid(x, y)\npts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()\n\nxx, yy = xx.numpy(), yy.numpy()\n\nacq_func = X.generator.get_acquisition(model)\nwith torch.no_grad():\n    acq_pts = pts.unsqueeze(1)\n    acq = acq_func(acq_pts)\n\n    fig, ax = plt.subplots()\n    c = ax.pcolor(xx, yy, acq.reshape(n, n), cmap=\"Blues\")\n    fig.colorbar(c)\n    ax.set_title(\"Acquisition function\")\n\n    ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")\n    ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")\n\n    ax.plot(*history[[\"x1\", \"x2\"]].to_numpy()[-1].T, \"+\")\n\n    feas = feasibility(pts.unsqueeze(1), model, tnk_vocs).flatten()\n\n    fig2, ax2 = plt.subplots()\n    c = ax2.pcolor(xx, yy, feas.reshape(n, n))\n    fig2.colorbar(c)\n    ax2.set_title(\"Feasible Region\")\n\ncandidate = pd.DataFrame(X.generator.generate(1), index=[0])\nprint(candidate[[\"x1\", \"x2\"]].to_numpy())\nax.plot(*candidate[[\"x1\", \"x2\"]].to_numpy()[0], \"o\")\n</pre> # plot the acquisition function from xopt.generators.bayesian.objectives import feasibility  bounds = X.generator.vocs.bounds model = X.generator.model  # create mesh n = 25 x = torch.linspace(*bounds.T[0], n) y = torch.linspace(*bounds.T[1], n) xx, yy = torch.meshgrid(x, y) pts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()  xx, yy = xx.numpy(), yy.numpy()  acq_func = X.generator.get_acquisition(model) with torch.no_grad():     acq_pts = pts.unsqueeze(1)     acq = acq_func(acq_pts)      fig, ax = plt.subplots()     c = ax.pcolor(xx, yy, acq.reshape(n, n), cmap=\"Blues\")     fig.colorbar(c)     ax.set_title(\"Acquisition function\")      ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")     ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")      ax.plot(*history[[\"x1\", \"x2\"]].to_numpy()[-1].T, \"+\")      feas = feasibility(pts.unsqueeze(1), model, tnk_vocs).flatten()      fig2, ax2 = plt.subplots()     c = ax2.pcolor(xx, yy, feas.reshape(n, n))     fig2.colorbar(c)     ax2.set_title(\"Feasible Region\")  candidate = pd.DataFrame(X.generator.generate(1), index=[0]) print(candidate[[\"x1\", \"x2\"]].to_numpy()) ax.plot(*candidate[[\"x1\", \"x2\"]].to_numpy()[0], \"o\") <pre>[[0.15402288 0.96373356]]\n</pre> Out[6]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f1c502276d0&gt;]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/multi_objective_bayes_opt/mggpo/#multi-objective-bayesian-optimization","title":"Multi-objective Bayesian Optimization\u00b6","text":"<p>TNK function $n=2$ variables: $x_i \\in [0, \\pi], i=1,2$</p> <p>Objectives:</p> <ul> <li>$f_i(x) = x_i$</li> </ul> <p>Constraints:</p> <ul> <li>$g_1(x) = -x_1^2 -x_2^2 + 1 + 0.1 \\cos\\left(16 \\arctan \\frac{x_1}{x_2}\\right) \\le 0$</li> <li>$g_2(x) = (x_1 - 1/2)^2 + (x_2-1/2)^2 \\le 0.5$</li> </ul>"},{"location":"examples/multi_objective_bayes_opt/mggpo/#plot-results","title":"plot results\u00b6","text":""},{"location":"examples/multi_objective_bayes_opt/mobo/","title":"Multi-objective Bayesian Optimization","text":"In\u00a0[3]: Copied! <pre># set values if testing\nimport os\nSMOKE_TEST = os.environ.get(\"SMOKE_TEST\")\nN_MC_SAMPLES = 1 if SMOKE_TEST else 128\nNUM_RESTARTS = 1 if SMOKE_TEST else 20\nN_STEPS = 1 if SMOKE_TEST else 30\n\n# Ignore all warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n\nimport pandas as pd\nimport numpy as np\nimport torch\n\nfrom xopt import Xopt, Evaluator\nfrom xopt.generators.bayesian import MOBOGenerator\nfrom xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs\n\n\nevaluator = Evaluator(function=evaluate_TNK)\nprint(tnk_vocs.dict())\n</pre> # set values if testing import os SMOKE_TEST = os.environ.get(\"SMOKE_TEST\") N_MC_SAMPLES = 1 if SMOKE_TEST else 128 NUM_RESTARTS = 1 if SMOKE_TEST else 20 N_STEPS = 1 if SMOKE_TEST else 30  # Ignore all warnings import warnings warnings.filterwarnings(\"ignore\")   import pandas as pd import numpy as np import torch  from xopt import Xopt, Evaluator from xopt.generators.bayesian import MOBOGenerator from xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs   evaluator = Evaluator(function=evaluate_TNK) print(tnk_vocs.dict()) <pre>{'variables': {'x1': [0.0, 3.14159], 'x2': [0.0, 3.14159]}, 'constraints': {'c1': ['GREATER_THAN', 0.0], 'c2': ['LESS_THAN', 0.5]}, 'objectives': {'y1': 'MINIMIZE', 'y2': 'MINIMIZE'}, 'constants': {'a': 'dummy_constant'}, 'linked_variables': {}}\n</pre> In\u00a0[4]: Copied! <pre>generator = MOBOGenerator(vocs=tnk_vocs, reference_point = {\"y1\":1.5,\"y2\":1.5})\ngenerator.n_monte_carlo_samples = N_MC_SAMPLES\ngenerator.numerical_optimizer.n_restarts = NUM_RESTARTS\n\nX = Xopt(generator=generator, evaluator=evaluator, vocs=tnk_vocs)\nX.evaluate_data(pd.DataFrame({\"x1\":[1.0, 0.75],\"x2\":[0.75, 1.0]}))\n\nfor i in range(N_STEPS):\n    print(i)\n    X.step()\n</pre> generator = MOBOGenerator(vocs=tnk_vocs, reference_point = {\"y1\":1.5,\"y2\":1.5}) generator.n_monte_carlo_samples = N_MC_SAMPLES generator.numerical_optimizer.n_restarts = NUM_RESTARTS  X = Xopt(generator=generator, evaluator=evaluator, vocs=tnk_vocs) X.evaluate_data(pd.DataFrame({\"x1\":[1.0, 0.75],\"x2\":[0.75, 1.0]}))  for i in range(N_STEPS):     print(i)     X.step() <pre>optim=OptimOptions(num_restarts=1, raw_samples=50, sequential=True, use_nearby_initial_points=True, max_travel_distances=None) acq=MOBOAcqOptions(proximal_lengthscales=[1.0, 1.0], use_transformed_proximal_weights=True, monte_carlo_samples=128, reference_point={'y1': 1.5, 'y2': 1.5}) model=ModelOptions(function=&lt;function create_standard_model at 0x00000198D148ACA0&gt;, kwargs=kwargs(use_conservative_prior_lengthscale=False, use_conservative_prior_mean=False, use_low_noise_prior=True)) n_initial=(2,)\n0\n</pre> <pre>C:\\ProgramData\\Miniconda3\\envs\\xopt\\lib\\site-packages\\gpytorch\\lazy\\lazy_tensor.py:1811: UserWarning: torch.triangular_solve is deprecated in favor of torch.linalg.solve_triangularand will be removed in a future PyTorch release.\ntorch.linalg.solve_triangular has its arguments reversed and does not return a copy of one of the inputs.\nX = torch.triangular_solve(B, A).solution\nshould be replaced with\nX = torch.linalg.solve_triangular(A, B). (Triggered internally at  C:\\cb\\pytorch_1000000000000\\work\\aten\\src\\ATen\\native\\BatchLinearAlgebra.cpp:2189.)\n  Linv = torch.triangular_solve(Eye, L, upper=False).solution\n</pre> <pre>1\n</pre> <pre>C:\\ProgramData\\Miniconda3\\envs\\xopt\\lib\\site-packages\\botorch\\optim\\optimize.py:287: RuntimeWarning: Optimization failed in `gen_candidates_scipy` with the following warning(s):\n[OptimizationWarning('Optimization failed within `scipy.optimize.minimize` with status 2.'), OptimizationWarning('Optimization failed within `scipy.optimize.minimize` with status 2.')]\nBecause you specified `batch_initial_conditions`, optimization will not be retried with new initial conditions and will proceed with the current solution. Suggested remediation: Try again with different `batch_initial_conditions`, or don't provide `batch_initial_conditions.`\n  warnings.warn(first_warn_msg, RuntimeWarning)\n</pre> <pre>2\n</pre> <pre>C:\\ProgramData\\Miniconda3\\envs\\xopt\\lib\\site-packages\\botorch\\optim\\optimize.py:287: RuntimeWarning: Optimization failed in `gen_candidates_scipy` with the following warning(s):\n[OptimizationWarning('Optimization failed within `scipy.optimize.minimize` with status 2.')]\nBecause you specified `batch_initial_conditions`, optimization will not be retried with new initial conditions and will proceed with the current solution. Suggested remediation: Try again with different `batch_initial_conditions`, or don't provide `batch_initial_conditions.`\n  warnings.warn(first_warn_msg, RuntimeWarning)\n</pre> <pre>3\n</pre> <pre>C:\\ProgramData\\Miniconda3\\envs\\xopt\\lib\\site-packages\\botorch\\optim\\optimize.py:287: RuntimeWarning: Optimization failed in `gen_candidates_scipy` with the following warning(s):\n[OptimizationWarning('Optimization failed within `scipy.optimize.minimize` with status 2.')]\nBecause you specified `batch_initial_conditions`, optimization will not be retried with new initial conditions and will proceed with the current solution. Suggested remediation: Try again with different `batch_initial_conditions`, or don't provide `batch_initial_conditions.`\n  warnings.warn(first_warn_msg, RuntimeWarning)\n</pre> <pre>4\n</pre> <pre>C:\\ProgramData\\Miniconda3\\envs\\xopt\\lib\\site-packages\\botorch\\optim\\optimize.py:287: RuntimeWarning: Optimization failed in `gen_candidates_scipy` with the following warning(s):\n[OptimizationWarning('Optimization failed within `scipy.optimize.minimize` with status 2.')]\nBecause you specified `batch_initial_conditions`, optimization will not be retried with new initial conditions and will proceed with the current solution. Suggested remediation: Try again with different `batch_initial_conditions`, or don't provide `batch_initial_conditions.`\n  warnings.warn(first_warn_msg, RuntimeWarning)\n</pre> <pre>5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n</pre> In\u00a0[5]: Copied! <pre>X.generator.data\n</pre> X.generator.data Out[5]: x1 x2 y1 y2 c1 c2 some_array xopt_runtime xopt_error a 1 1.000000 0.750000 1.000000 0.750000 0.626888 0.312500 [1, 2, 3] 0.000020 False NaN 2 0.750000 1.000000 0.750000 1.000000 0.626888 0.312500 [1, 2, 3] 0.000007 False NaN 3 0.428720 2.007932 0.428720 2.007932 3.313092 2.278940 [1, 2, 3] 0.000023 False dummy_constant 4 0.134244 0.387830 0.134244 0.387830 -0.889617 0.146360 [1, 2, 3] 0.000023 False dummy_constant 5 0.442316 0.924067 0.442316 0.924067 -0.015720 0.183160 [1, 2, 3] 0.000022 False dummy_constant 6 0.461993 0.935771 0.461993 0.935771 0.039728 0.191341 [1, 2, 3] 0.000020 False dummy_constant 7 0.874432 0.477673 0.874432 0.477673 0.007310 0.140698 [1, 2, 3] 0.000023 False dummy_constant 8 1.062458 0.216807 1.062458 0.216807 0.275509 0.396557 [1, 2, 3] 0.000019 False dummy_constant 9 0.928535 0.000880 0.928535 0.000880 -0.237810 0.432763 [1, 2, 3] 0.000023 False dummy_constant 10 0.725610 0.732733 0.725610 0.732733 -0.036287 0.105065 [1, 2, 3] 0.000018 False dummy_constant 11 0.738756 0.759102 0.738756 0.759102 0.024348 0.124138 [1, 2, 3] 0.000023 False dummy_constant 12 0.087102 1.020094 0.087102 1.020094 0.027537 0.440982 [1, 2, 3] 0.000020 False dummy_constant 13 1.033162 0.065898 1.033162 0.065898 0.019357 0.472706 [1, 2, 3] 0.000021 False dummy_constant 14 0.943209 0.275065 0.943209 0.275065 -0.017554 0.247030 [1, 2, 3] 0.000023 False dummy_constant 15 0.357045 0.974175 0.357045 0.974175 -0.002361 0.245278 [1, 2, 3] 0.000023 False dummy_constant 16 0.859666 0.547987 0.859666 0.547987 0.133427 0.131662 [1, 2, 3] 0.000022 False dummy_constant 17 0.095253 1.070040 0.095253 1.070040 0.139090 0.488766 [1, 2, 3] 0.000019 False dummy_constant 18 0.609088 0.874345 0.609088 0.874345 0.230685 0.152034 [1, 2, 3] 0.000020 False dummy_constant 19 0.640858 0.804962 0.640858 0.804962 0.082190 0.112843 [1, 2, 3] 0.000022 False dummy_constant 20 0.971735 0.269476 0.971735 0.269476 0.054362 0.275676 [1, 2, 3] 0.000021 False dummy_constant 21 0.013723 1.002836 0.013723 1.002836 -0.091745 0.489310 [1, 2, 3] 0.000022 False dummy_constant 22 1.062374 0.090652 1.062374 0.090652 0.116124 0.483830 [1, 2, 3] 0.000023 False dummy_constant 23 0.789056 0.629524 0.789056 0.629524 0.040832 0.100330 [1, 2, 3] 0.000019 False dummy_constant 24 2.642876 1.572709 2.642876 1.572709 8.525243 5.742624 [1, 2, 3] 0.000032 False dummy_constant 25 2.470885 0.621015 2.470885 0.621015 5.560736 3.899031 [1, 2, 3] 0.000022 False dummy_constant 26 0.925867 0.364200 0.925867 0.364200 -0.106042 0.199804 [1, 2, 3] 0.000020 False dummy_constant 27 0.919290 0.448723 0.919290 0.448723 -0.009058 0.178434 [1, 2, 3] 0.000020 False dummy_constant 28 0.044770 1.035918 0.044770 1.035918 -0.001927 0.494443 [1, 2, 3] 0.000019 False dummy_constant 29 0.072262 1.050962 0.072262 1.050962 0.064241 0.486518 [1, 2, 3] 0.000020 False dummy_constant 30 0.547049 0.860175 0.547049 0.860175 0.132699 0.131940 [1, 2, 3] 0.000022 False dummy_constant 31 0.826048 0.602091 0.826048 0.602091 0.124308 0.116730 [1, 2, 3] 0.000020 False dummy_constant 32 1.003558 0.153400 1.003558 0.153400 0.106191 0.373702 [1, 2, 3] 0.000024 False dummy_constant In\u00a0[6]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\ntheta = np.linspace(0, np.pi / 2)\nr = np.sqrt(1 + 0.1 * np.cos(16 * theta))\nx_1 = r * np.sin(theta)\nx_2_lower = r * np.cos(theta)\nx_2_upper = (0.5 - (x_1 - 0.5) ** 2) ** 0.5 + 0.5\n\nz = np.zeros_like(x_1)\n\n# ax2.plot(x_1, x_2_lower,'r')\nax.fill_between(x_1, z, x_2_lower, fc=\"white\")\ncircle = plt.Circle(\n    (0.5, 0.5), 0.5 ** 0.5, color=\"r\", alpha=0.25, zorder=0, label=\"Valid Region\"\n)\nax.add_patch(circle)\nhistory = pd.concat(\n    [X.data, tnk_vocs.feasibility_data(X.data)], axis=1, ignore_index=False\n)\n\n\nax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")\nax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")\n\nax.set_xlim(0, 3.14)\nax.set_ylim(0, 3.14)\nax.set_xlabel(\"x1\")\nax.set_ylabel(\"x2\")\nax.set_aspect(\"equal\")\n</pre> import matplotlib.pyplot as plt  fig, ax = plt.subplots()  theta = np.linspace(0, np.pi / 2) r = np.sqrt(1 + 0.1 * np.cos(16 * theta)) x_1 = r * np.sin(theta) x_2_lower = r * np.cos(theta) x_2_upper = (0.5 - (x_1 - 0.5) ** 2) ** 0.5 + 0.5  z = np.zeros_like(x_1)  # ax2.plot(x_1, x_2_lower,'r') ax.fill_between(x_1, z, x_2_lower, fc=\"white\") circle = plt.Circle(     (0.5, 0.5), 0.5 ** 0.5, color=\"r\", alpha=0.25, zorder=0, label=\"Valid Region\" ) ax.add_patch(circle) history = pd.concat(     [X.data, tnk_vocs.feasibility_data(X.data)], axis=1, ignore_index=False )   ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\") ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")  ax.set_xlim(0, 3.14) ax.set_ylim(0, 3.14) ax.set_xlabel(\"x1\") ax.set_ylabel(\"x2\") ax.set_aspect(\"equal\") In\u00a0[7]: Copied! <pre>ax = history.plot(\"x1\", \"x2\")\nax.set_ylim(0, 3.14)\nax.set_xlim(0, 3.14)\nax.set_aspect(\"equal\")\n</pre> ax = history.plot(\"x1\", \"x2\") ax.set_ylim(0, 3.14) ax.set_xlim(0, 3.14) ax.set_aspect(\"equal\") In\u00a0[8]: Copied! <pre># plot the acquisition function\nfrom xopt.generators.bayesian.objectives import feasibility\n\nbounds = X.generator.vocs.bounds\nmodel = X.generator.model\n\n# create mesh\nn = 200\nx = torch.linspace(*bounds.T[0], n)\ny = torch.linspace(*bounds.T[1], n)\nxx, yy = torch.meshgrid(x, y)\npts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()\n\nxx, yy = xx.numpy(), yy.numpy()\n\nacq_func = X.generator.get_acquisition(model)\nwith torch.no_grad():\n    acq_pts = pts.unsqueeze(1)\n    acq = acq_func(acq_pts)\n\n    fig, ax = plt.subplots()\n    c = ax.pcolor(xx, yy, acq.reshape(n, n), cmap=\"Blues\")\n    fig.colorbar(c)\n    ax.set_title(\"Acquisition function\")\n\n    ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")\n    ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")\n\n    ax.plot(*history[[\"x1\", \"x2\"]].to_numpy()[-1].T, \"+\")\n\n    feas = feasibility(pts.unsqueeze(1), model, tnk_vocs).flatten()\n\n    fig2, ax2 = plt.subplots()\n    c = ax2.pcolor(xx, yy, feas.reshape(n, n))\n    fig2.colorbar(c)\n    ax2.set_title(\"Feasible Region\")\n\ncandidate = pd.DataFrame(X.generator.generate(1), index=[0])\nprint(candidate[[\"x1\", \"x2\"]].to_numpy())\nax.plot(*candidate[[\"x1\", \"x2\"]].to_numpy()[0], \"o\")\n</pre> # plot the acquisition function from xopt.generators.bayesian.objectives import feasibility  bounds = X.generator.vocs.bounds model = X.generator.model  # create mesh n = 200 x = torch.linspace(*bounds.T[0], n) y = torch.linspace(*bounds.T[1], n) xx, yy = torch.meshgrid(x, y) pts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()  xx, yy = xx.numpy(), yy.numpy()  acq_func = X.generator.get_acquisition(model) with torch.no_grad():     acq_pts = pts.unsqueeze(1)     acq = acq_func(acq_pts)      fig, ax = plt.subplots()     c = ax.pcolor(xx, yy, acq.reshape(n, n), cmap=\"Blues\")     fig.colorbar(c)     ax.set_title(\"Acquisition function\")      ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")     ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")      ax.plot(*history[[\"x1\", \"x2\"]].to_numpy()[-1].T, \"+\")      feas = feasibility(pts.unsqueeze(1), model, tnk_vocs).flatten()      fig2, ax2 = plt.subplots()     c = ax2.pcolor(xx, yy, feas.reshape(n, n))     fig2.colorbar(c)     ax2.set_title(\"Feasible Region\")  candidate = pd.DataFrame(X.generator.generate(1), index=[0]) print(candidate[[\"x1\", \"x2\"]].to_numpy()) ax.plot(*candidate[[\"x1\", \"x2\"]].to_numpy()[0], \"o\") <pre>C:\\ProgramData\\Miniconda3\\envs\\xopt\\lib\\site-packages\\torch\\functional.py:478: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at  C:\\cb\\pytorch_1000000000000\\work\\aten\\src\\ATen\\native\\TensorShape.cpp:2895.)\n  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]\n</pre> <pre>[[0.24501697 0.99184235]]\n</pre> Out[8]: <pre>[&lt;matplotlib.lines.Line2D at 0x198e3ab0dc0&gt;]</pre> In\u00a0[9]: Copied! <pre>%%time\ncandidate = X.generator.generate(1)\n</pre> %%time candidate = X.generator.generate(1) <pre>CPU times: total: 12 s\nWall time: 1.5 s\n</pre>"},{"location":"examples/multi_objective_bayes_opt/mobo/#multi-objective-bayesian-optimization","title":"Multi-objective Bayesian Optimization\u00b6","text":"<p>TNK function $n=2$ variables: $x_i \\in [0, \\pi], i=1,2$</p> <p>Objectives:</p> <ul> <li>$f_i(x) = x_i$</li> </ul> <p>Constraints:</p> <ul> <li>$g_1(x) = -x_1^2 -x_2^2 + 1 + 0.1 \\cos\\left(16 \\arctan \\frac{x_1}{x_2}\\right) \\le 0$</li> <li>$g_2(x) = (x_1 - 1/2)^2 + (x_2-1/2)^2 \\le 0.5$</li> </ul>"},{"location":"examples/multi_objective_bayes_opt/mobo/#plot-results","title":"plot results\u00b6","text":""},{"location":"examples/multi_objective_bayes_opt/mobo/#plot-path-through-input-space","title":"Plot path through input space\u00b6","text":""},{"location":"examples/multi_objective_bayes_opt/mobo_from_yaml/","title":"Multi-objective Bayesian Optimization","text":"In\u00a0[1]: Copied! <pre>import os\nSMOKE_TEST = os.environ.get(\"SMOKE_TEST\")\nNUM_STEPS = 2 if SMOKE_TEST else 50\n\n# Ignore all warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport torch\nfrom xopt import Xopt\n\n\nYAML = \"\"\"\ngenerator:\n    name: mobo\n    reference_point: {y1: 1.5, y2: 1.5}\n\nevaluator:\n    function: xopt.resources.test_functions.tnk.evaluate_TNK\n\nvocs:\n    variables:\n        x1: [0, 3.14159]\n        x2: [0, 3.14159]\n    objectives: {y1: MINIMIZE, y2: MINIMIZE}\n    constraints:\n        c1: [GREATER_THAN, 0]\n        c2: [LESS_THAN, 0.5]\n    constants: {a: dummy_constant}\n\n\"\"\"\n</pre> import os SMOKE_TEST = os.environ.get(\"SMOKE_TEST\") NUM_STEPS = 2 if SMOKE_TEST else 50  # Ignore all warnings import warnings warnings.filterwarnings(\"ignore\")  import torch from xopt import Xopt   YAML = \"\"\" generator:     name: mobo     reference_point: {y1: 1.5, y2: 1.5}  evaluator:     function: xopt.resources.test_functions.tnk.evaluate_TNK  vocs:     variables:         x1: [0, 3.14159]         x2: [0, 3.14159]     objectives: {y1: MINIMIZE, y2: MINIMIZE}     constraints:         c1: [GREATER_THAN, 0]         c2: [LESS_THAN, 0.5]     constants: {a: dummy_constant}  \"\"\" In\u00a0[2]: Copied! <pre>X = Xopt.from_yaml(YAML)\n\n# for testing purposes only\nif SMOKE_TEST:\n    X.generator.numerical_optimizer.n_restarts = 1\n    X.generator.n_monte_carlo_samples = 1\n\nX.random_evaluate(5)\nfor i in range(NUM_STEPS):\n    print(i)\n    X.step()\n</pre> X = Xopt.from_yaml(YAML)  # for testing purposes only if SMOKE_TEST:     X.generator.numerical_optimizer.n_restarts = 1     X.generator.n_monte_carlo_samples = 1  X.random_evaluate(5) for i in range(NUM_STEPS):     print(i)     X.step() <pre>0\n1\n2\n3\n4\n5\n6\n7\n8\n</pre> <pre>\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nCell In[2], line 5\n      3 for i in range(NUM_STEPS):\n      4     print(i)\n----&gt; 5     X.step()\n\nFile ~\\Documents\\GitHub\\Xopt\\xopt\\base.py:217, in Xopt.step(self)\n    215 # generate samples and submit to evaluator\n    216 logger.debug(f\"Generating {n_generate} candidates\")\n--&gt; 217 new_samples = pd.DataFrame(self.generator.generate(n_generate))\n    219 # generator is done when it returns no new samples\n    220 if len(new_samples) == 0:\n\nFile ~\\Documents\\GitHub\\Xopt\\xopt\\generators\\bayesian\\bayesian_generator.py:80, in BayesianGenerator.generate(self, n_candidates)\n     76     return self.vocs.random_inputs(self.options.n_initial)\n     78 else:\n     79     # update internal model with internal data\n---&gt; 80     model = self.train_model(self.data)\n     82     # calculate optimization bounds\n     83     bounds = self._get_optimization_bounds()\n\nFile ~\\Documents\\GitHub\\Xopt\\xopt\\generators\\bayesian\\bayesian_generator.py:106, in BayesianGenerator.train_model(self, data, update_internal)\n    103 if data.empty:\n    104     raise ValueError(\"no data available to build model\")\n--&gt; 106 _model = self.gp_constructor.build_model(data, self._tkwargs)\n    108 # validate returned model\n    109 self._validate_model(_model)\n\nFile ~\\Documents\\GitHub\\Xopt\\xopt\\generators\\bayesian\\models\\standard.py:60, in StandardModelConstructor.build_model(self, data, tkwargs)\n     57 self.collect_data(data)\n     59 # build model\n---&gt; 60 return self.build_standard_model()\n\nFile ~\\Documents\\GitHub\\Xopt\\xopt\\generators\\bayesian\\models\\standard.py:98, in StandardModelConstructor.build_standard_model(self, **model_kwargs)\n     92     if mean_module is not None:\n     93         mean_module = CustomMean(\n     94             mean_module, self.input_transform, outcome_transform\n     95         )\n     97     models.append(\n---&gt; 98         self.build_single_task_gp(\n     99 self.train_X,\n    100 train_Y,\n    101 input_transform=self.input_transform,\n    102 outcome_transform=outcome_transform,\n    103 covar_module=covar_module,\n    104 mean_module=mean_module,\n    105 likelihood=self.likelihood,\n    106 )\n    107     )\n    109 return ModelListGP(*models)\n\nFile ~\\Documents\\GitHub\\Xopt\\xopt\\generators\\bayesian\\base_model.py:37, in ModelConstructor.build_single_task_gp(train_X, train_Y, **kwargs)\n     34 model = SingleTaskGP(train_X, train_Y, **kwargs)\n     36 mll = ExactMarginalLogLikelihood(model.likelihood, model)\n---&gt; 37 fit_gpytorch_mll(mll)\n     38 return model\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\botorch\\fit.py:105, in fit_gpytorch_mll(mll, closure, optimizer, closure_kwargs, optimizer_kwargs, **kwargs)\n    102 if optimizer is not None:  # defer to per-method defaults\n    103     kwargs[\"optimizer\"] = optimizer\n--&gt; 105 return FitGPyTorchMLL(\n    106     mll,\n    107     type(mll.likelihood),\n    108     type(mll.model),\n    109     closure=closure,\n    110     closure_kwargs=closure_kwargs,\n    111     optimizer_kwargs=optimizer_kwargs,\n    112     **kwargs,\n    113 )\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\botorch\\utils\\dispatcher.py:93, in Dispatcher.__call__(self, *args, **kwargs)\n     91 func = self.__getitem__(types=types)\n     92 try:\n---&gt; 93     return func(*args, **kwargs)\n     94 except MDNotImplementedError:\n     95     # Traverses registered methods in order, yields whenever a match is found\n     96     funcs = self.dispatch_iter(*types)\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\botorch\\fit.py:252, in _fit_fallback(mll, _, __, closure, optimizer, closure_kwargs, optimizer_kwargs, max_attempts, warning_handler, caught_exception_types, **ignore)\n    250 with catch_warnings(record=True) as warning_list, debug(True):\n    251     simplefilter(\"always\", category=OptimizationWarning)\n--&gt; 252     optimizer(mll, closure=closure, **optimizer_kwargs)\n    254 # Resolved warnings and determine whether or not to retry\n    255 done = True\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\botorch\\optim\\fit.py:120, in fit_gpytorch_mll_scipy(mll, parameters, bounds, closure, closure_kwargs, method, options, callback, timeout_sec)\n    117 if closure_kwargs is not None:\n    118     closure = partial(closure, **closure_kwargs)\n--&gt; 120 result = scipy_minimize(\n    121 closure=closure,\n    122 parameters=parameters,\n    123 bounds=bounds,\n    124 method=method,\n    125 options=options,\n    126 callback=callback,\n    127 timeout_sec=timeout_sec,\n    128 )\n    129 if result.status != OptimizationStatus.SUCCESS:\n    130     warn(\n    131         f\"`scipy_minimize` terminated with status {result.status}, displaying\"\n    132         f\" original message from `scipy.optimize.minimize`: {result.message}\",\n    133         OptimizationWarning,\n    134     )\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\botorch\\optim\\core.py:109, in scipy_minimize(closure, parameters, bounds, callback, x0, method, options, timeout_sec)\n    101         result = OptimizationResult(\n    102             step=next(call_counter),\n    103             fval=float(wrapped_closure(x)[0]),\n    104             status=OptimizationStatus.RUNNING,\n    105             runtime=monotonic() - start_time,\n    106         )\n    107         return callback(parameters, result)  # pyre-ignore [29]\n--&gt; 109 raw = minimize_with_timeout(\n    110 wrapped_closure,\n    111 wrapped_closure.state if x0 is None else x0.astype(np_float64, copy=False),\n    112 jac=True,\n    113 bounds=bounds_np,\n    114 method=method,\n    115 options=options,\n    116 callback=wrapped_callback,\n    117 timeout_sec=timeout_sec,\n    118 )\n    120 # Post-processing and outcome handling\n    121 wrapped_closure.state = asarray(raw.x)  # set parameter state to optimal values\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\botorch\\optim\\utils\\timeout.py:80, in minimize_with_timeout(fun, x0, args, method, jac, hess, hessp, bounds, constraints, tol, callback, options, timeout_sec)\n     77     wrapped_callback = callback\n     79 try:\n---&gt; 80     return optimize.minimize(\n     81 fun=fun,\n     82 x0=x0,\n     83 args=args,\n     84 method=method,\n     85 jac=jac,\n     86 hess=hess,\n     87 hessp=hessp,\n     88 bounds=bounds,\n     89 constraints=constraints,\n     90 tol=tol,\n     91 callback=wrapped_callback,\n     92 options=options,\n     93 )\n     94 except OptimizationTimeoutError as e:\n     95     msg = f\"Optimization timed out after {e.runtime} seconds.\"\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\scipy\\optimize\\_minimize.py:696, in minimize(fun, x0, args, method, jac, hess, hessp, bounds, constraints, tol, callback, options)\n    693     res = _minimize_newtoncg(fun, x0, args, jac, hess, hessp, callback,\n    694                              **options)\n    695 elif meth == 'l-bfgs-b':\n--&gt; 696     res = _minimize_lbfgsb(fun, x0, args, jac, bounds,\n    697                            callback=callback, **options)\n    698 elif meth == 'tnc':\n    699     res = _minimize_tnc(fun, x0, args, jac, bounds, callback=callback,\n    700                         **options)\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\scipy\\optimize\\_lbfgsb_py.py:359, in _minimize_lbfgsb(fun, x0, args, jac, bounds, disp, maxcor, ftol, gtol, eps, maxfun, maxiter, iprint, callback, maxls, finite_diff_rel_step, **unknown_options)\n    353 task_str = task.tobytes()\n    354 if task_str.startswith(b'FG'):\n    355     # The minimization routine wants f and g at the current x.\n    356     # Note that interruptions due to maxfun are postponed\n    357     # until the completion of the current minimization iteration.\n    358     # Overwrite f and g:\n--&gt; 359     f, g = func_and_grad(x)\n    360 elif task_str.startswith(b'NEW_X'):\n    361     # new iteration\n    362     n_iterations += 1\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\scipy\\optimize\\_differentiable_functions.py:285, in ScalarFunction.fun_and_grad(self, x)\n    283 if not np.array_equal(x, self.x):\n    284     self._update_x_impl(x)\n--&gt; 285 self._update_fun()\n    286 self._update_grad()\n    287 return self.f, self.g\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\scipy\\optimize\\_differentiable_functions.py:251, in ScalarFunction._update_fun(self)\n    249 def _update_fun(self):\n    250     if not self.f_updated:\n--&gt; 251         self._update_fun_impl()\n    252         self.f_updated = True\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\scipy\\optimize\\_differentiable_functions.py:155, in ScalarFunction.__init__.&lt;locals&gt;.update_fun()\n    154 def update_fun():\n--&gt; 155     self.f = fun_wrapped(self.x)\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\scipy\\optimize\\_differentiable_functions.py:137, in ScalarFunction.__init__.&lt;locals&gt;.fun_wrapped(x)\n    133 self.nfev += 1\n    134 # Send a copy because the user may overwrite it.\n    135 # Overwriting results in undefined behaviour because\n    136 # fun(self.x) will change self.x, with the two no longer linked.\n--&gt; 137 fx = fun(np.copy(x), *args)\n    138 # Make sure the function returns a true scalar\n    139 if not np.isscalar(fx):\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\scipy\\optimize\\_optimize.py:76, in MemoizeJac.__call__(self, x, *args)\n     74 def __call__(self, x, *args):\n     75 \"\"\" returns the function value \"\"\"\n---&gt; 76     self._compute_if_needed(x, *args)\n     77     return self._value\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\scipy\\optimize\\_optimize.py:70, in MemoizeJac._compute_if_needed(self, x, *args)\n     68 if not np.all(x == self.x) or self._value is None or self.jac is None:\n     69     self.x = np.asarray(x).copy()\n---&gt; 70     fg = self.fun(x, *args)\n     71     self.jac = fg[1]\n     72     self._value = fg[0]\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\botorch\\optim\\closures\\core.py:150, in NdarrayOptimizationClosure.__call__(self, state, **kwargs)\n    147     self.state = state\n    149 try:\n--&gt; 150     value_tensor, grad_tensors = self.closure(**kwargs)\n    151     value = self.as_array(value_tensor)\n    152     grads = self._get_gradient_ndarray(fill_value=self.fill_value)\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\botorch\\optim\\closures\\core.py:66, in ForwardBackwardClosure.__call__(self, **kwargs)\n     64 values = self.forward(**kwargs)\n     65 value = values if self.reducer is None else self.reducer(values)\n---&gt; 66 self.backward(value)\n     68 grads = tuple(param.grad for param in self.parameters.values())\n     69 if self.callback:\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\torch\\_tensor.py:487, in Tensor.backward(self, gradient, retain_graph, create_graph, inputs)\n    477 if has_torch_function_unary(self):\n    478     return handle_torch_function(\n    479         Tensor.backward,\n    480         (self,),\n   (...)\n    485         inputs=inputs,\n    486     )\n--&gt; 487 torch.autograd.backward(\n    488 self, gradient, retain_graph, create_graph, inputs=inputs\n    489 )\n\nFile ~\\mambaforge\\envs\\xopt-dev\\lib\\site-packages\\torch\\autograd\\__init__.py:200, in backward(tensors, grad_tensors, retain_graph, create_graph, grad_variables, inputs)\n    195     retain_graph = create_graph\n    197 # The reason we repeat same the comment below is that\n    198 # some Python versions print out the first line of a multi-line function\n    199 # calls in the traceback and some print out the last line\n--&gt; 200 Variable._execution_engine.run_backward(  # Calls into the C++ engine to run the backward pass\n    201 tensors, grad_tensors_, retain_graph, create_graph, inputs,\n    202 allow_unreachable=True, accumulate_grad=True)\n\nKeyboardInterrupt: </pre> In\u00a0[\u00a0]: Copied! <pre>X.generator.data\n</pre> X.generator.data In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nfig, ax = plt.subplots()\n\ntheta = np.linspace(0, np.pi / 2)\nr = np.sqrt(1 + 0.1 * np.cos(16 * theta))\nx_1 = r * np.sin(theta)\nx_2_lower = r * np.cos(theta)\nx_2_upper = (0.5 - (x_1 - 0.5) ** 2) ** 0.5 + 0.5\n\nz = np.zeros_like(x_1)\n\n# ax2.plot(x_1, x_2_lower,'r')\nax.fill_between(x_1, z, x_2_lower, fc=\"white\")\ncircle = plt.Circle(\n    (0.5, 0.5), 0.5 ** 0.5, color=\"r\", alpha=0.25, zorder=0, label=\"Valid Region\"\n)\nax.add_patch(circle)\nhistory = pd.concat(\n    [X.data, X.vocs.feasibility_data(X.data)], axis=1, ignore_index=False\n)\n\n\nax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")\nax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")\n\nax.set_xlim(0, 3.14)\nax.set_ylim(0, 3.14)\nax.set_xlabel(\"x1\")\nax.set_ylabel(\"x2\")\nax.set_aspect(\"equal\")\n</pre> import matplotlib.pyplot as plt import numpy as np import pandas as pd  fig, ax = plt.subplots()  theta = np.linspace(0, np.pi / 2) r = np.sqrt(1 + 0.1 * np.cos(16 * theta)) x_1 = r * np.sin(theta) x_2_lower = r * np.cos(theta) x_2_upper = (0.5 - (x_1 - 0.5) ** 2) ** 0.5 + 0.5  z = np.zeros_like(x_1)  # ax2.plot(x_1, x_2_lower,'r') ax.fill_between(x_1, z, x_2_lower, fc=\"white\") circle = plt.Circle(     (0.5, 0.5), 0.5 ** 0.5, color=\"r\", alpha=0.25, zorder=0, label=\"Valid Region\" ) ax.add_patch(circle) history = pd.concat(     [X.data, X.vocs.feasibility_data(X.data)], axis=1, ignore_index=False )   ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\") ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")  ax.set_xlim(0, 3.14) ax.set_ylim(0, 3.14) ax.set_xlabel(\"x1\") ax.set_ylabel(\"x2\") ax.set_aspect(\"equal\") In\u00a0[\u00a0]: Copied! <pre>ax = history.plot(\"x1\", \"x2\")\nax.set_ylim(0, 3.14)\nax.set_xlim(0, 3.14)\nax.set_aspect(\"equal\")\n</pre> ax = history.plot(\"x1\", \"x2\") ax.set_ylim(0, 3.14) ax.set_xlim(0, 3.14) ax.set_aspect(\"equal\") In\u00a0[\u00a0]: Copied! <pre># plot the acquisition function\nfrom xopt.generators.bayesian.objectives import feasibility\n\nbounds = X.generator.vocs.bounds\nmodel = X.generator.model\n\n# create mesh\nn = 100\nx = torch.linspace(*bounds.T[0], n)\ny = torch.linspace(*bounds.T[1], n)\nxx, yy = torch.meshgrid(x, y)\npts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()\n\nxx, yy = xx.numpy(), yy.numpy()\n\nacq_func = X.generator.get_acquisition(model)\nwith torch.no_grad():\n    acq_pts = pts.unsqueeze(1)\n    acq = acq_func(acq_pts)\n\n    fig, ax = plt.subplots(figsize=(8,8))\n    c = ax.pcolor(xx, yy, acq.reshape(n, n), cmap=\"Blues\")\n    fig.colorbar(c)\n    ax.set_title(\"Acquisition function\")\n\n    ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")\n    ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")\n\n    ax.plot(*history[[\"x1\", \"x2\"]].to_numpy()[-1].T, \"+\")\n\n    feas = feasibility(pts.unsqueeze(1), model, X.vocs).flatten()\n\n    fig2, ax2 = plt.subplots(figsize=(8,8))\n    c = ax2.pcolor(xx, yy, feas.reshape(n, n))\n    fig2.colorbar(c)\n    ax2.set_title(\"Feasible Region\")\n\ncandidate = pd.DataFrame(X.generator.generate(1), index=[0])\nprint(candidate[[\"x1\", \"x2\"]].to_numpy())\nax.plot(*candidate[[\"x1\", \"x2\"]].to_numpy()[0], \"o\")\n</pre> # plot the acquisition function from xopt.generators.bayesian.objectives import feasibility  bounds = X.generator.vocs.bounds model = X.generator.model  # create mesh n = 100 x = torch.linspace(*bounds.T[0], n) y = torch.linspace(*bounds.T[1], n) xx, yy = torch.meshgrid(x, y) pts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()  xx, yy = xx.numpy(), yy.numpy()  acq_func = X.generator.get_acquisition(model) with torch.no_grad():     acq_pts = pts.unsqueeze(1)     acq = acq_func(acq_pts)      fig, ax = plt.subplots(figsize=(8,8))     c = ax.pcolor(xx, yy, acq.reshape(n, n), cmap=\"Blues\")     fig.colorbar(c)     ax.set_title(\"Acquisition function\")      ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")     ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")      ax.plot(*history[[\"x1\", \"x2\"]].to_numpy()[-1].T, \"+\")      feas = feasibility(pts.unsqueeze(1), model, X.vocs).flatten()      fig2, ax2 = plt.subplots(figsize=(8,8))     c = ax2.pcolor(xx, yy, feas.reshape(n, n))     fig2.colorbar(c)     ax2.set_title(\"Feasible Region\")  candidate = pd.DataFrame(X.generator.generate(1), index=[0]) print(candidate[[\"x1\", \"x2\"]].to_numpy()) ax.plot(*candidate[[\"x1\", \"x2\"]].to_numpy()[0], \"o\")"},{"location":"examples/multi_objective_bayes_opt/mobo_from_yaml/#multi-objective-bayesian-optimization","title":"Multi-objective Bayesian Optimization\u00b6","text":"<p>TNK function $n=2$ variables: $x_i \\in [0, \\pi], i=1,2$</p> <p>Objectives:</p> <ul> <li>$f_i(x) = x_i$</li> </ul> <p>Constraints:</p> <ul> <li>$g_1(x) = -x_1^2 -x_2^2 + 1 + 0.1 \\cos\\left(16 \\arctan \\frac{x_1}{x_2}\\right) \\le 0$</li> <li>$g_2(x) = (x_1 - 1/2)^2 + (x_2-1/2)^2 \\le 0.5$</li> </ul>"},{"location":"examples/multi_objective_bayes_opt/mobo_from_yaml/#plot-results","title":"plot results\u00b6","text":""},{"location":"examples/multi_objective_bayes_opt/mobo_from_yaml/#plot-path-through-input-space","title":"Plot path through input space\u00b6","text":""},{"location":"examples/multi_objective_bayes_opt/multi_fidelity_mobo/","title":"Multi-fidelity Multi-objective Bayesian Optimization","text":"In\u00a0[1]: Copied! <pre># set values if testing\nimport os\nSMOKE_TEST = os.environ.get(\"SMOKE_TEST\")\nN_MC_SAMPLES = 1 if SMOKE_TEST else 128\nNUM_RESTARTS = 1 if SMOKE_TEST else 20\nBUDGET = 0.02 if SMOKE_TEST else 10\n\n# Ignore all warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport pandas as pd\nimport numpy as np\nimport torch\n\nfrom xopt import Xopt, Evaluator\nfrom xopt.generators.bayesian import MultiFidelityGenerator\nfrom xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs\n\nevaluator = Evaluator(function=evaluate_TNK)\nprint(tnk_vocs.dict())\n</pre> # set values if testing import os SMOKE_TEST = os.environ.get(\"SMOKE_TEST\") N_MC_SAMPLES = 1 if SMOKE_TEST else 128 NUM_RESTARTS = 1 if SMOKE_TEST else 20 BUDGET = 0.02 if SMOKE_TEST else 10  # Ignore all warnings import warnings warnings.filterwarnings(\"ignore\")  import pandas as pd import numpy as np import torch  from xopt import Xopt, Evaluator from xopt.generators.bayesian import MultiFidelityGenerator from xopt.resources.test_functions.tnk import evaluate_TNK, tnk_vocs  evaluator = Evaluator(function=evaluate_TNK) print(tnk_vocs.dict()) <pre>{'variables': {'x1': [0.0, 3.14159], 'x2': [0.0, 3.14159]}, 'constraints': {'c1': ['GREATER_THAN', 0.0], 'c2': ['LESS_THAN', 0.5]}, 'objectives': {'y1': 'MINIMIZE', 'y2': 'MINIMIZE'}, 'constants': {'a': 'dummy_constant'}, 'observables': []}\n</pre> In\u00a0[2]: Copied! <pre>from copy import deepcopy\nmy_vocs = deepcopy(tnk_vocs)\nmy_vocs.constraints = {}\ngenerator = MultiFidelityGenerator(vocs=my_vocs, reference_point = {\"y1\":1.5,\"y2\":1.5})\n\n# set cost function according to approximate scaling of laser plasma accelerator\n# problem, see https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.5.013063\ngenerator.cost_function = lambda s: s**3.5\ngenerator.numerical_optimizer.n_restarts = NUM_RESTARTS\ngenerator.n_monte_carlo_samples = N_MC_SAMPLES\n\nX = Xopt(generator=generator, evaluator=evaluator, vocs=my_vocs)\n\n# evaluate at some explicit initial points\nX.evaluate_data(pd.DataFrame({\"x1\":[1.0, 0.75],\"x2\":[0.75, 1.0],\"s\":[0.0,0.1]}))\n\nX\n</pre> from copy import deepcopy my_vocs = deepcopy(tnk_vocs) my_vocs.constraints = {} generator = MultiFidelityGenerator(vocs=my_vocs, reference_point = {\"y1\":1.5,\"y2\":1.5})  # set cost function according to approximate scaling of laser plasma accelerator # problem, see https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.5.013063 generator.cost_function = lambda s: s**3.5 generator.numerical_optimizer.n_restarts = NUM_RESTARTS generator.n_monte_carlo_samples = N_MC_SAMPLES  X = Xopt(generator=generator, evaluator=evaluator, vocs=my_vocs)  # evaluate at some explicit initial points X.evaluate_data(pd.DataFrame({\"x1\":[1.0, 0.75],\"x2\":[0.75, 1.0],\"s\":[0.0,0.1]}))  X Out[2]: <pre>\n            Xopt\n________________________________\nVersion: 2.0a1+117.g26fa0eea.dirty\nData size: 2\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: xopt.resources.test_functions.tnk.evaluate_TNK\n  function_kwargs:\n    raise_probability: 0\n    random_sleep: 0\n    sleep: 0\n  max_workers: 1\n  vectorized: false\ngenerator:\n  computation_time: null\n  cost_function: __main__.&lt;lambda&gt;\n  fidelity_parameter: s\n  fixed_features: null\n  max_travel_distances: null\n  model: null\n  model_constructor:\n    covar_modules: {}\n    mean_modules: {}\n    name: standard\n    trainable_mean_keys: []\n    use_low_noise_prior: true\n  n_candidates: 1\n  n_monte_carlo_samples: 1\n  name: multi_fidelity\n  numerical_optimizer:\n    max_iter: 2000\n    n_raw_samples: 20\n    n_restarts: 1\n    name: LBFGS\n  reference_point:\n    s: 0.0\n    y1: 1.5\n    y2: 1.5\n  turbo_controller: null\n  use_cuda: false\nmax_evaluations: null\nserialize_torch: false\nstrict: true\nvocs:\n  constants:\n    a: dummy_constant\n  constraints: {}\n  objectives:\n    s: MAXIMIZE\n    y1: MINIMIZE\n    y2: MINIMIZE\n  observables: []\n  variables:\n    s:\n    - 0\n    - 1\n    x1:\n    - 0.0\n    - 3.14159\n    x2:\n    - 0.0\n    - 3.14159\n</pre> In\u00a0[3]: Copied! <pre>budget = BUDGET\nwhile X.generator.calculate_total_cost() &lt; budget:\n    X.step()\n    print(f\"n_samples: {len(X.data)} \"\n          f\"budget used: {X.generator.calculate_total_cost():.4} \"\n          f\"hypervolume: {X.generator.calculate_hypervolume():.4}\")\n</pre> budget = BUDGET while X.generator.calculate_total_cost() &lt; budget:     X.step()     print(f\"n_samples: {len(X.data)} \"           f\"budget used: {X.generator.calculate_total_cost():.4} \"           f\"hypervolume: {X.generator.calculate_hypervolume():.4}\") <pre>n_samples: 3 budget used: 0.01032 hypervolume: 0.07687\nn_samples: 4 budget used: 0.01803 hypervolume: 0.07687\nn_samples: 5 budget used: 0.02803 hypervolume: 0.331\n</pre> In\u00a0[4]: Copied! <pre>X.data\n</pre> X.data Out[4]: x1 x2 s y1 y2 c1 c2 xopt_runtime xopt_error 0 1.000000 0.750000 0.000000 1.000000 0.750000 0.626888 0.312500 0.000055 False 1 0.750000 1.000000 0.100000 0.750000 1.000000 0.626888 0.312500 0.000017 False 3 0.096651 1.369407 0.268270 0.096651 1.369407 0.841714 0.918559 0.000018 False 4 0.000000 2.951848 0.249139 0.000000 2.951848 7.613409 6.261560 0.000020 False 5 0.000000 0.677480 0.268270 0.000000 0.677480 -0.641021 0.281499 0.000018 False In\u00a0[5]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\ntheta = np.linspace(0, np.pi / 2)\nr = np.sqrt(1 + 0.1 * np.cos(16 * theta))\nx_1 = r * np.sin(theta)\nx_2_lower = r * np.cos(theta)\nx_2_upper = (0.5 - (x_1 - 0.5) ** 2) ** 0.5 + 0.5\n\nz = np.zeros_like(x_1)\n\n# ax2.plot(x_1, x_2_lower,'r')\nax.fill_between(x_1, z, x_2_lower, fc=\"white\")\ncircle = plt.Circle(\n    (0.5, 0.5), 0.5 ** 0.5, color=\"r\", alpha=0.25, zorder=0, label=\"Valid Region\"\n)\nax.add_patch(circle)\nhistory = pd.concat(\n    [X.data, tnk_vocs.feasibility_data(X.data)], axis=1, ignore_index=False\n)\n\nax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")\nax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")\n\nax.set_xlim(0, 3.14)\nax.set_ylim(0, 3.14)\nax.set_xlabel(\"x1\")\nax.set_ylabel(\"x2\")\nax.set_aspect(\"equal\")\n</pre> import matplotlib.pyplot as plt  fig, ax = plt.subplots()  theta = np.linspace(0, np.pi / 2) r = np.sqrt(1 + 0.1 * np.cos(16 * theta)) x_1 = r * np.sin(theta) x_2_lower = r * np.cos(theta) x_2_upper = (0.5 - (x_1 - 0.5) ** 2) ** 0.5 + 0.5  z = np.zeros_like(x_1)  # ax2.plot(x_1, x_2_lower,'r') ax.fill_between(x_1, z, x_2_lower, fc=\"white\") circle = plt.Circle(     (0.5, 0.5), 0.5 ** 0.5, color=\"r\", alpha=0.25, zorder=0, label=\"Valid Region\" ) ax.add_patch(circle) history = pd.concat(     [X.data, tnk_vocs.feasibility_data(X.data)], axis=1, ignore_index=False )  ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\") ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")  ax.set_xlim(0, 3.14) ax.set_ylim(0, 3.14) ax.set_xlabel(\"x1\") ax.set_ylabel(\"x2\") ax.set_aspect(\"equal\") In\u00a0[6]: Copied! <pre>ax = history.hist([\"x1\", \"x2\", \"s\"],bins=20)\n</pre> ax = history.hist([\"x1\", \"x2\", \"s\"],bins=20) In\u00a0[7]: Copied! <pre>history.plot(y=[\"x1\", \"x2\", \"s\"])\n</pre> history.plot(y=[\"x1\", \"x2\", \"s\"]) Out[7]: <pre>&lt;Axes: &gt;</pre> In\u00a0[9]: Copied! <pre># plot the acquisition function\n\nbounds = X.generator.vocs.bounds\nmodel = X.generator.model\n\n# create mesh over non-fidelity parameters\nn = 50\nx = torch.linspace(*bounds.T[1], n)\ny = torch.linspace(*bounds.T[2], n)\nxx, yy = torch.meshgrid(x, y)\n\n# plot function(s) at a single fidelity parameter\nfidelities = [0.0, 0.5, 1.0]\nfor fidelity in fidelities:\n    pts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()\n    pts = torch.cat((torch.ones(pts.shape[0],1)*fidelity, pts), dim=-1)\n\n    acq_func = X.generator.get_acquisition(model)\n    with torch.no_grad():\n        acq_pts = pts.unsqueeze(1)\n        acq = acq_func(acq_pts)\n\n        fig, ax = plt.subplots()\n\n        xxn, yyn = xx.numpy(), yy.numpy()\n\n        c = ax.pcolor(xxn, yyn, acq.reshape(n, n), cmap=\"Blues\")\n        fig.colorbar(c)\n        ax.set_title(f\"Acquisition function - s: {fidelity}\")\n\n        ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")\n        ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")\n\n        ax.plot(*history[[\"x1\", \"x2\"]].to_numpy()[-1].T, \"+\")\n\n\ncandidate = pd.DataFrame(X.generator.generate(1), index=[0])\nprint(candidate[[\"x1\", \"x2\"]].to_numpy())\nax.plot(*candidate[[\"x1\", \"x2\"]].to_numpy()[0], \"o\")\n</pre> # plot the acquisition function  bounds = X.generator.vocs.bounds model = X.generator.model  # create mesh over non-fidelity parameters n = 50 x = torch.linspace(*bounds.T[1], n) y = torch.linspace(*bounds.T[2], n) xx, yy = torch.meshgrid(x, y)  # plot function(s) at a single fidelity parameter fidelities = [0.0, 0.5, 1.0] for fidelity in fidelities:     pts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()     pts = torch.cat((torch.ones(pts.shape[0],1)*fidelity, pts), dim=-1)      acq_func = X.generator.get_acquisition(model)     with torch.no_grad():         acq_pts = pts.unsqueeze(1)         acq = acq_func(acq_pts)          fig, ax = plt.subplots()          xxn, yyn = xx.numpy(), yy.numpy()          c = ax.pcolor(xxn, yyn, acq.reshape(n, n), cmap=\"Blues\")         fig.colorbar(c)         ax.set_title(f\"Acquisition function - s: {fidelity}\")          ax.plot(*history[[\"x1\", \"x2\"]][history[\"feasible\"]].to_numpy().T, \".C1\")         ax.plot(*history[[\"x1\", \"x2\"]][~history[\"feasible\"]].to_numpy().T, \".C2\")          ax.plot(*history[[\"x1\", \"x2\"]].to_numpy()[-1].T, \"+\")   candidate = pd.DataFrame(X.generator.generate(1), index=[0]) print(candidate[[\"x1\", \"x2\"]].to_numpy()) ax.plot(*candidate[[\"x1\", \"x2\"]].to_numpy()[0], \"o\") <pre>[[0.20851033 0.12429363]]\n</pre> Out[9]: <pre>[&lt;matplotlib.lines.Line2D at 0x16d9cbc1d30&gt;]</pre> In\u00a0[\u00a0]: Copied! <pre># examine lengthscale of the first objective\nlist(model.models[0].named_parameters())\n</pre> # examine lengthscale of the first objective list(model.models[0].named_parameters())"},{"location":"examples/multi_objective_bayes_opt/multi_fidelity_mobo/#multi-fidelity-multi-objective-bayesian-optimization","title":"Multi-fidelity Multi-objective Bayesian Optimization\u00b6","text":"<p>Here we attempt to solve for the constrained Pareto front of the TNK multi-objective optimization problem using Multi-Fidelity Multi-Objective Bayesian optimization. For simplicity we assume that the objective and constraint functions at lower fidelities is exactly equal to the functions at higher fidelities (this is obviously not a requirement, although for the best results lower fidelity calculations should correlate with higher fidelity ones). The algorithm should learn this relationship and use information gathered at lower fidelities to gather samples to improve the hypervolume of the Pareto front at the maximum fidelity.</p> <p>TNK function $n=2$ variables: $x_i \\in [0, \\pi], i=1,2$</p> <p>Objectives:</p> <ul> <li>$f_i(x) = x_i$</li> </ul> <p>Constraints:</p> <ul> <li>$g_1(x) = -x_1^2 -x_2^2 + 1 + 0.1 \\cos\\left(16 \\arctan \\frac{x_1}{x_2}\\right) \\le 0$</li> <li>$g_2(x) = (x_1 - 1/2)^2 + (x_2-1/2)^2 \\le 0.5$</li> </ul>"},{"location":"examples/multi_objective_bayes_opt/multi_fidelity_mobo/#set-up-the-multi-fidelity-multi-objective-optimization-algorithm","title":"Set up the Multi-Fidelity Multi-objective optimization algorithm\u00b6","text":"<p>Here we create the Multi-Fidelity generator object which can solve both single and multi-objective optimization problems depending on the number of objectives in VOCS. We specify a cost function as a function of fidelity parameter $s=[0,1]$ as $C(s) = s^{3.5}$ as an example from a real life multi-fidelity simulation problem.</p>"},{"location":"examples/multi_objective_bayes_opt/multi_fidelity_mobo/#run-optimization-routine","title":"Run optimization routine\u00b6","text":"<p>Instead of ending the optimization routine after an explict number of samples we end optimization once a given optimization budget has been exceeded. WARNING: This will slightly exceed the given budget</p>"},{"location":"examples/multi_objective_bayes_opt/multi_fidelity_mobo/#show-results","title":"Show results\u00b6","text":""},{"location":"examples/multi_objective_bayes_opt/multi_fidelity_mobo/#plot-results","title":"Plot results\u00b6","text":"<p>Here we plot the resulting observations in input space, colored by feasibility (neglecting the fact that these data points are at varying fidelities).</p>"},{"location":"examples/multi_objective_bayes_opt/multi_fidelity_mobo/#plot-path-through-input-space","title":"Plot path through input space\u00b6","text":""},{"location":"examples/multi_objective_bayes_opt/multi_fidelity_mobo/#plot-the-acqusisition-function","title":"Plot the acqusisition function\u00b6","text":"<p>Here we plot the acquisition function at a small set of fidelities $[0, 0.5, 1.0]$.</p>"},{"location":"examples/rcds/rcds/","title":"RCDS","text":"In\u00a0[1]: Copied! <pre># If you encounter the \"Initializing libomp.dylib, but found libomp.dylib already initialized.\" error\n# Please run this cell\n\nimport os\n\nos.environ['KMP_DUPLICATE_LIB_OK']='True'\n</pre> # If you encounter the \"Initializing libomp.dylib, but found libomp.dylib already initialized.\" error # Please run this cell  import os  os.environ['KMP_DUPLICATE_LIB_OK']='True' In\u00a0[2]: Copied! <pre>import time\nimport numpy as np\nfrom xopt.generators.rcds.rcds import RCDSGenerator\nfrom xopt.vocs import VOCS\nfrom xopt.evaluator import Evaluator\nfrom xopt import Xopt\nimport pandas as pd\nfrom tqdm.auto import tqdm\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</pre> import time import numpy as np from xopt.generators.rcds.rcds import RCDSGenerator from xopt.vocs import VOCS from xopt.evaluator import Evaluator from xopt import Xopt import pandas as pd from tqdm.auto import tqdm import warnings warnings.filterwarnings(\"ignore\") In\u00a0[3]: Copied! <pre>def f_RCDS_minimize(input_dict):\n    p = []\n    for i in range(2):\n        p.append(input_dict[f'p{i}'])\n    \n    obj = np.linalg.norm(p)\n    outcome_dict = {'f': obj}\n    \n    return outcome_dict\n</pre> def f_RCDS_minimize(input_dict):     p = []     for i in range(2):         p.append(input_dict[f'p{i}'])          obj = np.linalg.norm(p)     outcome_dict = {'f': obj}          return outcome_dict In\u00a0[4]: Copied! <pre>YAML = \"\"\"\nmax_evaluations: 100\ngenerator:\n    name: rcds\n    x0: null\n    init_mat: null\n    noise: 0.00001\n    step: 0.01\n    tol: 0.00001\nevaluator:\n    function: __main__.f_RCDS_minimize\nvocs:\n    variables:\n        p0: [0, 1]\n        p1: [0, 1]\n    objectives:\n        f: MINIMIZE\n\"\"\"\n\nX = Xopt.from_yaml(YAML)\nX\n</pre> YAML = \"\"\" max_evaluations: 100 generator:     name: rcds     x0: null     init_mat: null     noise: 0.00001     step: 0.01     tol: 0.00001 evaluator:     function: __main__.f_RCDS_minimize vocs:     variables:         p0: [0, 1]         p1: [0, 1]     objectives:         f: MINIMIZE \"\"\"  X = Xopt.from_yaml(YAML) X Out[4]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: __main__.f_RCDS_minimize\n  function_kwargs: {}\n  max_workers: 1\n  vectorized: false\ngenerator:\n  init_mat: null\n  name: rcds\n  noise: 1.0e-05\n  step: 0.01\n  tol: 1.0e-05\n  x0: null\nmax_evaluations: 100\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants: {}\n  constraints: {}\n  objectives:\n    f: MINIMIZE\n  observables: []\n  variables:\n    p0:\n    - 0.0\n    - 1.0\n    p1:\n    - 0.0\n    - 1.0\n</pre> In\u00a0[5]: Copied! <pre>X.run()\n</pre> X.run() <p>Now you can go directly to the Visualization section and check out the results.</p> In\u00a0[6]: Copied! <pre>n_var = 2\n</pre> n_var = 2 In\u00a0[7]: Copied! <pre>variables = {}\nfor i in range(n_var):\n    variables[f'p{i}'] = [0, 1]\n\nvocs = VOCS(\n    variables=variables,\n    objectives={'f': 'MINIMIZE'},\n)\n</pre> variables = {} for i in range(n_var):     variables[f'p{i}'] = [0, 1]  vocs = VOCS(     variables=variables,     objectives={'f': 'MINIMIZE'}, ) In\u00a0[8]: Copied! <pre>vocs\n</pre> vocs Out[8]: <pre>VOCS(variables={'p0': [0.0, 1.0], 'p1': [0.0, 1.0]}, constraints={}, objectives={'f': 'MINIMIZE'}, constants={}, observables=[])</pre> In\u00a0[9]: Copied! <pre>evaluator = Evaluator(function=f_RCDS_minimize)\n</pre> evaluator = Evaluator(function=f_RCDS_minimize) In\u00a0[10]: Copied! <pre>generator = RCDSGenerator(vocs=vocs)\n</pre> generator = RCDSGenerator(vocs=vocs) In\u00a0[11]: Copied! <pre>generator.dict()\n</pre> generator.dict() Out[11]: <pre>{'x0': None, 'init_mat': None, 'noise': 1e-05, 'step': 0.01, 'tol': 1e-05}</pre> In\u00a0[12]: Copied! <pre>X = Xopt.from_yaml(YAML)\n</pre> X = Xopt.from_yaml(YAML) In\u00a0[13]: Copied! <pre>for i in tqdm(range(X.max_evaluations)):\n    X.step()\n</pre>  for i in tqdm(range(X.max_evaluations)):     X.step() In\u00a0[14]: Copied! <pre>X.data.plot(y='f')\n</pre> X.data.plot(y='f') Out[14]: <pre>&lt;Axes: &gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/rcds/rcds/#rcds-optimization","title":"RCDS Optimization\u00b6","text":"<p>In this example we demonstrate RCDS optimization.</p>"},{"location":"examples/rcds/rcds/#rcds-test-problem","title":"RCDS test problem\u00b6","text":"<p>This test problem is a 2-D quadratic function.</p>"},{"location":"examples/rcds/rcds/#run-rcds-on-the-test-problem-yaml-method","title":"Run RCDS on the test problem (YAML method)\u00b6","text":""},{"location":"examples/rcds/rcds/#run-rcds-on-the-test-problem-api-method","title":"Run RCDS on the test problem (API method)\u00b6","text":""},{"location":"examples/rcds/rcds/#vocs","title":"VOCS\u00b6","text":"<p>We'll set the bounds for all the variables pi to [0, 1].</p>"},{"location":"examples/rcds/rcds/#evaluator","title":"Evaluator\u00b6","text":""},{"location":"examples/rcds/rcds/#generator","title":"Generator\u00b6","text":""},{"location":"examples/rcds/rcds/#run-the-optimization","title":"Run the optimization\u00b6","text":""},{"location":"examples/rcds/rcds/#visualization","title":"Visualization\u00b6","text":""},{"location":"examples/scipy/neldermead/","title":"Nelder-Mead Generator adapted from SciPy","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\n\nfrom xopt import Xopt\nimport numpy as np\n\n#from xopt import output_notebook\n#output_notebook()\n\nimport matplotlib.pyplot as plt\n</pre> import pandas as pd  from xopt import Xopt import numpy as np  #from xopt import output_notebook #output_notebook()  import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>YAML = \"\"\"\ngenerator:\n  name: neldermead\n  initial_point: {x0: -1, x1: -1}\n  adaptive: true\n  xatol: 0.0001\n  fatol: 0.0001  \nevaluator:\n  function: xopt.resources.test_functions.rosenbrock.evaluate_rosenbrock\nvocs:\n  variables:\n    x0: [-5, 5]\n    x1: [-5, 5]\n  objectives: {y: MINIMIZE}\n\"\"\"\nX = Xopt.from_yaml(YAML)\n</pre> YAML = \"\"\" generator:   name: neldermead   initial_point: {x0: -1, x1: -1}   adaptive: true   xatol: 0.0001   fatol: 0.0001   evaluator:   function: xopt.resources.test_functions.rosenbrock.evaluate_rosenbrock vocs:   variables:     x0: [-5, 5]     x1: [-5, 5]   objectives: {y: MINIMIZE} \"\"\" X = Xopt.from_yaml(YAML) In\u00a0[3]: Copied! <pre>XMIN = [1,1] # True minimum\n</pre> XMIN = [1,1] # True minimum In\u00a0[4]: Copied! <pre>X.run()\nX.data\n</pre> X.run() X.data Out[4]: x0 x1 y xopt_runtime xopt_error 0 -1.000000 -1.000000 4.040000e+02 0.000015 False 2 -1.050000 -1.000000 4.462531e+02 0.000012 False 3 -1.000000 -1.050000 4.242500e+02 0.000011 False 4 -0.950000 -1.050000 3.850281e+02 0.000011 False 5 -0.900000 -1.075000 3.589325e+02 0.000011 False ... ... ... ... ... ... 122 0.999877 0.999764 2.587916e-08 0.000011 False 123 0.999999 0.999995 5.309344e-10 0.000012 False 124 1.000045 1.000097 7.751675e-09 0.000011 False 125 0.999963 0.999925 1.412126e-09 0.000011 False 126 0.999963 0.999925 1.412126e-09 0.000011 False <p>126 rows \u00d7 5 columns</p> In\u00a0[5]: Copied! <pre># Evaluation progression\nX.data['y'].plot(marker='.')\nplt.yscale('log')\nplt.xlabel('iteration')\nplt.ylabel('Rosenbrock value')\n</pre> # Evaluation progression X.data['y'].plot(marker='.') plt.yscale('log') plt.xlabel('iteration') plt.ylabel('Rosenbrock value') Out[5]: <pre>Text(0, 0.5, 'Rosenbrock value')</pre> In\u00a0[6]: Copied! <pre># Minimum\ndict(X.data.iloc[X.data[\"y\"].argmin()])\n</pre> # Minimum dict(X.data.iloc[X.data[\"y\"].argmin()]) Out[6]: <pre>{'x0': 0.9999988592114838,\n 'x1': 0.9999954170486077,\n 'y': 5.309343918637161e-10,\n 'xopt_runtime': 1.1600999982874782e-05,\n 'xopt_error': False}</pre> In\u00a0[7]: Copied! <pre>from xopt.resources.test_functions.rosenbrock import rosenbrock\n</pre> from xopt.resources.test_functions.rosenbrock import rosenbrock In\u00a0[8]: Copied! <pre>fig, ax = plt.subplots(figsize=(8,8))\n\nXgrid, Ygrid = np.meshgrid(np.linspace(-2, 2, 201), np.linspace(-2, 2, 201) )\n\nZgrid = np.vectorize(lambda x, y: rosenbrock([x, y]))(Xgrid, Ygrid)\nZgrid = np.log(Zgrid+1)\n\nax.pcolormesh(Xgrid, Ygrid, Zgrid)\nax.contour(Xgrid, Ygrid, Zgrid, levels=10, colors='black')\nax.set_xlabel('x0')\nax.set_ylabel('x1')\n\n\n# Add all evaluations\nax.plot(X.data[\"x0\"], X.data[\"x1\"], color='red', alpha=0.5, marker='.')\nax.scatter(XMIN[0], XMIN[1], 50, marker='o', color='orange', label=\"True minimum\")\nax.set_xlim(-2, 2)\nax.set_ylim(-2, 2)\n#plt.legend()\nax.set_title(\"Xopt's Nelder-Mead progression\")\n</pre> fig, ax = plt.subplots(figsize=(8,8))  Xgrid, Ygrid = np.meshgrid(np.linspace(-2, 2, 201), np.linspace(-2, 2, 201) )  Zgrid = np.vectorize(lambda x, y: rosenbrock([x, y]))(Xgrid, Ygrid) Zgrid = np.log(Zgrid+1)  ax.pcolormesh(Xgrid, Ygrid, Zgrid) ax.contour(Xgrid, Ygrid, Zgrid, levels=10, colors='black') ax.set_xlabel('x0') ax.set_ylabel('x1')   # Add all evaluations ax.plot(X.data[\"x0\"], X.data[\"x1\"], color='red', alpha=0.5, marker='.') ax.scatter(XMIN[0], XMIN[1], 50, marker='o', color='orange', label=\"True minimum\") ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) #plt.legend() ax.set_title(\"Xopt's Nelder-Mead progression\") Out[8]: <pre>Text(0.5, 1.0, \"Xopt's Nelder-Mead progression\")</pre> In\u00a0[9]: Copied! <pre># Manually step the algorithm and collect simplexes\nX = Xopt.from_yaml(YAML)\nsimplexes = []\nwhile not X.generator.is_done:\n    X.step()\n    simplexes.append(X.generator.simplex)\n</pre> # Manually step the algorithm and collect simplexes X = Xopt.from_yaml(YAML) simplexes = [] while not X.generator.is_done:     X.step()     simplexes.append(X.generator.simplex)  In\u00a0[10]: Copied! <pre>def plot_simplex(simplex, ax=None):\n    x0 = simplex[\"x0\"]\n    x1 = simplex[\"x1\"]\n    x0 = np.append(x0, x0[0])\n    x1 = np.append(x1, x1[0])\n    ax.plot(x0, x1)\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.pcolormesh(Xgrid, Ygrid, Zgrid)\n#ax.contour(Xgrid, Ygrid, Zgrid, levels=10, colors='black')\nax.set_xlim(-2, 2)\nax.set_ylim(-2, 2)  \nax.set_xlabel('x0')\nax.set_ylabel('x1')\nax.set_title('Nelder-Mead simplex progression')\n\nax.scatter(XMIN[0], XMIN[1], 50, marker='o', color='orange', label=\"True minimum\")\n\nfor simplex in simplexes:\n    plot_simplex(simplex, ax)\n</pre> def plot_simplex(simplex, ax=None):     x0 = simplex[\"x0\"]     x1 = simplex[\"x1\"]     x0 = np.append(x0, x0[0])     x1 = np.append(x1, x1[0])     ax.plot(x0, x1)  fig, ax = plt.subplots(figsize=(8,8)) ax.pcolormesh(Xgrid, Ygrid, Zgrid) #ax.contour(Xgrid, Ygrid, Zgrid, levels=10, colors='black') ax.set_xlim(-2, 2) ax.set_ylim(-2, 2)   ax.set_xlabel('x0') ax.set_ylabel('x1') ax.set_title('Nelder-Mead simplex progression')  ax.scatter(XMIN[0], XMIN[1], 50, marker='o', color='orange', label=\"True minimum\")  for simplex in simplexes:     plot_simplex(simplex, ax) In\u00a0[11]: Copied! <pre>from scipy.optimize import fmin\n</pre> from scipy.optimize import fmin In\u00a0[12]: Copied! <pre>result = fmin(rosenbrock, [-1, -1])\nresult\n</pre> result = fmin(rosenbrock, [-1, -1]) result <pre>Optimization terminated successfully.\n         Current function value: 0.000000\n         Iterations: 67\n         Function evaluations: 125\n</pre> Out[12]: <pre>array([0.99999886, 0.99999542])</pre> In\u00a0[13]: Copied! <pre>X = Xopt.from_yaml(YAML)\n</pre> X = Xopt.from_yaml(YAML) In\u00a0[14]: Copied! <pre>X.run()\n# Almost exactly the same number evaluations. \nlen(X.data)\n</pre> X.run() # Almost exactly the same number evaluations.  len(X.data)  Out[14]: <pre>126</pre> In\u00a0[15]: Copied! <pre># results are the same\nxbest = X.data.iloc[X.data[\"y\"].argmin()]\nxbest['x0'] == result[0], xbest['x1'] == result[1]\n</pre> # results are the same xbest = X.data.iloc[X.data[\"y\"].argmin()] xbest['x0'] == result[0], xbest['x1'] == result[1] Out[15]: <pre>(True, True)</pre> In\u00a0[16]: Copied! <pre>from xopt.generators.scipy.neldermead import NelderMeadGenerator\nfrom xopt import Evaluator, VOCS\n</pre> from xopt.generators.scipy.neldermead import NelderMeadGenerator from xopt import Evaluator, VOCS In\u00a0[17]: Copied! <pre>NelderMeadGenerator.__fields__\n</pre> NelderMeadGenerator.__fields__ <pre>/tmp/ipykernel_3749/30297736.py:1: PydanticDeprecatedSince20: The `__fields__` attribute is deprecated, use `model_fields` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.4/migration/\n  NelderMeadGenerator.__fields__\n</pre> Out[17]: <pre>{'vocs': FieldInfo(annotation=VOCS, required=True, description='generator VOCS', exclude=True),\n 'data': FieldInfo(annotation=Union[DataFrame, NoneType], required=False, description='generator data', exclude=True),\n 'initial_point': FieldInfo(annotation=Dict[str, float], required=False),\n 'initial_simplex': FieldInfo(annotation=Dict[str, Union[List[float], numpy.ndarray]], required=False),\n 'adaptive': FieldInfo(annotation=bool, required=False, default=True),\n 'xatol': FieldInfo(annotation=float, required=False, default=0.0001),\n 'fatol': FieldInfo(annotation=float, required=False, default=0.0001)}</pre> In\u00a0[18]: Copied! <pre>Xbest = [33, 44]\n\ndef f(inputs, verbose=False):\n\n    if verbose:\n        print(f'evaluate f({x})')\n    x0 = inputs[\"x0\"]\n    x1 = inputs[\"x1\"]\n    \n    #if x0 &lt; 10:\n    #    raise ValueError('test XXXX')\n\n    y = (x0-Xbest[0])**2  + (x1-Xbest[1])**2\n\n    return {\"y\":y}\n\nev = Evaluator(function=f)\nvocs = VOCS(variables={\"x0\": [-100, 100], \"x1\": [-100,100]}, objectives={\"y\":\"MINIMIZE\"})\nvocs.json()\n</pre> Xbest = [33, 44]  def f(inputs, verbose=False):      if verbose:         print(f'evaluate f({x})')     x0 = inputs[\"x0\"]     x1 = inputs[\"x1\"]          #if x0 &lt; 10:     #    raise ValueError('test XXXX')      y = (x0-Xbest[0])**2  + (x1-Xbest[1])**2      return {\"y\":y}  ev = Evaluator(function=f) vocs = VOCS(variables={\"x0\": [-100, 100], \"x1\": [-100,100]}, objectives={\"y\":\"MINIMIZE\"}) vocs.json() <pre>/tmp/ipykernel_3749/284194303.py:19: PydanticDeprecatedSince20: The `json` method is deprecated; use `model_dump_json` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.4/migration/\n  vocs.json()\n</pre> Out[18]: <pre>'{\"variables\":{\"x0\":[-100.0,100.0],\"x1\":[-100.0,100.0]},\"constraints\":{},\"objectives\":{\"y\":\"MINIMIZE\"},\"constants\":{},\"observables\":[]}'</pre> In\u00a0[19]: Copied! <pre># check output\nf(vocs.random_inputs()[0])\n</pre> # check output f(vocs.random_inputs()[0]) Out[19]: <pre>{'y': array([13764.5142295])}</pre> In\u00a0[20]: Copied! <pre>G = NelderMeadGenerator(vocs=vocs)\nG.generate(1)\n</pre> G = NelderMeadGenerator(vocs=vocs) G.generate(1) Out[20]: <pre>[{'x0': 17.560712216355114, 'x1': -28.268819697575374}]</pre> In\u00a0[21]: Copied! <pre># This will throw an exception \ntry:\n    G.generate(1)\nexcept Exception as ex:\n    print(ex)\n</pre> # This will throw an exception  try:     G.generate(1) except Exception as ex:     print(ex) <pre>Generation is locked via ._lock. Please call `add_data` before any further generate(1)\n</pre> In\u00a0[22]: Copied! <pre># This will unlock\nG.add_data([ev.evaluate(G._inputs[0])])\nG.generate(1)\n</pre> # This will unlock G.add_data([ev.evaluate(G._inputs[0])]) G.generate(1) Out[22]: <pre>[{'x0': 18.43874782717287, 'x1': -28.268819697575374}]</pre> In\u00a0[23]: Copied! <pre># Create Xopt object\nX = Xopt(evaluator=ev, vocs=vocs, generator=NelderMeadGenerator(vocs=vocs))\n\n# Optional: give an initial pioint\nX.generator.initial_point = {'x0':0, 'x1':0}\n</pre> # Create Xopt object X = Xopt(evaluator=ev, vocs=vocs, generator=NelderMeadGenerator(vocs=vocs))  # Optional: give an initial pioint X.generator.initial_point = {'x0':0, 'x1':0} In\u00a0[24]: Copied! <pre>X.run()\n</pre> X.run() In\u00a0[25]: Copied! <pre># This shows the latest simplex\nX.generator.simplex\n</pre> # This shows the latest simplex X.generator.simplex Out[25]: <pre>{'x0': array([32.99996111, 32.99996171, 33.00002688]),\n 'x1': array([44.00000851, 44.00006811, 44.00003045])}</pre> In\u00a0[26]: Copied! <pre>X.data['y'].plot()\nplt.yscale('log')\n</pre> X.data['y'].plot() plt.yscale('log') In\u00a0[27]: Copied! <pre>fig, ax = plt.subplots()\nX.data.plot('x0', 'x1', ax=ax, color='black', alpha=0.5)\nax.scatter(Xbest[0], Xbest[1], marker='x', color='red')\n</pre> fig, ax = plt.subplots() X.data.plot('x0', 'x1', ax=ax, color='black', alpha=0.5) ax.scatter(Xbest[0], Xbest[1], marker='x', color='red')     Out[27]: <pre>&lt;matplotlib.collections.PathCollection at 0x7f6901adf250&gt;</pre> In\u00a0[28]: Copied! <pre># This is the raw internal simplex points\na = X.generator._state\na\n</pre> # This is the raw internal simplex points a = X.generator._state a Out[28]: <pre>array([[32.99996111, 44.00000851],\n       [32.99996171, 44.00006811],\n       [33.00002688, 44.00003045]])</pre> In\u00a0[29]: Copied! <pre># Check JSON representation of options\nX.generator.json()\n</pre> # Check JSON representation of options X.generator.json() <pre>/tmp/ipykernel_3749/3513096500.py:2: PydanticDeprecatedSince20: The `json` method is deprecated; use `model_dump_json` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.4/migration/\n  X.generator.json()\n</pre> Out[29]: <pre>'{\"initial_point\":{\"x0\":0.0,\"x1\":0.0},\"initial_simplex\":null,\"adaptive\":true,\"xatol\":0.0001,\"fatol\":0.0001}'</pre> In\u00a0[30]: Copied! <pre># Set the initial simplex to be the latest, \nX.generator.initial_simplex = X.generator.simplex\nX.generator.xatol = 1e-9\nX.generator.fatol = 1e-9\nX.generator._is_done = False # Unlock\nX.run()\n\n\nX.data['y'].plot()\nplt.yscale('log')\n</pre> # Set the initial simplex to be the latest,  X.generator.initial_simplex = X.generator.simplex X.generator.xatol = 1e-9 X.generator.fatol = 1e-9 X.generator._is_done = False # Unlock X.run()   X.data['y'].plot() plt.yscale('log') In\u00a0[31]: Copied! <pre>YAML = \"\"\"\ngenerator:\n  name: neldermead\nevaluator:\n  function: xopt.resources.test_functions.rosenbrock.evaluate_rosenbrock\nvocs:\n  variables:\n    x1: [-5, 5]\n    x2: [-5, 5]\n    x3: [-5, 5]\n    x4: [-5, 5]\n    x5: [-5, 5]\n  objectives:\n    y: MINIMIZE\n\"\"\"\nX = Xopt.from_yaml(YAML)\n</pre> YAML = \"\"\" generator:   name: neldermead evaluator:   function: xopt.resources.test_functions.rosenbrock.evaluate_rosenbrock vocs:   variables:     x1: [-5, 5]     x2: [-5, 5]     x3: [-5, 5]     x4: [-5, 5]     x5: [-5, 5]   objectives:     y: MINIMIZE \"\"\" X = Xopt.from_yaml(YAML) In\u00a0[32]: Copied! <pre>X.run()\nX.data['y'].plot()\nplt.yscale('log')\n</pre> X.run() X.data['y'].plot() plt.yscale('log') In\u00a0[33]: Copied! <pre>fig, ax = plt.subplots(figsize=(8,8))\n\nXgrid, Ygrid = np.meshgrid(np.linspace(-2, 2, 201), np.linspace(-2, 2, 201) )\n\nZgrid = np.vectorize(lambda x, y: rosenbrock([x, y, 1, 1, 1]))(Xgrid, Ygrid)  # The minimum is at 1,1,1,1,1\nZgrid = np.log(Zgrid+1)\n\nax.pcolormesh(Xgrid, Ygrid, Zgrid)\nax.contour(Xgrid, Ygrid, Zgrid, levels=10, colors='black')\nax.set_xlabel('x0')\nax.set_ylabel('x1')\n\n\n# Add all evaluations\nax.plot(X.data[\"x1\"], X.data[\"x2\"], color='red', alpha=0.5, marker='.')\nax.scatter(XMIN[0], XMIN[1], 50, marker='o', color='orange', label=\"True minimum\")\nax.set_xlim(-2, 2)\nax.set_ylim(-2, 2)\n#plt.legend()\nax.set_title(\"Xopt's Nelder-Mead progression\")\n</pre> fig, ax = plt.subplots(figsize=(8,8))  Xgrid, Ygrid = np.meshgrid(np.linspace(-2, 2, 201), np.linspace(-2, 2, 201) )  Zgrid = np.vectorize(lambda x, y: rosenbrock([x, y, 1, 1, 1]))(Xgrid, Ygrid)  # The minimum is at 1,1,1,1,1 Zgrid = np.log(Zgrid+1)  ax.pcolormesh(Xgrid, Ygrid, Zgrid) ax.contour(Xgrid, Ygrid, Zgrid, levels=10, colors='black') ax.set_xlabel('x0') ax.set_ylabel('x1')   # Add all evaluations ax.plot(X.data[\"x1\"], X.data[\"x2\"], color='red', alpha=0.5, marker='.') ax.scatter(XMIN[0], XMIN[1], 50, marker='o', color='orange', label=\"True minimum\") ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) #plt.legend() ax.set_title(\"Xopt's Nelder-Mead progression\") Out[33]: <pre>Text(0.5, 1.0, \"Xopt's Nelder-Mead progression\")</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/scipy/neldermead/#nelder-mead-generator-adapted-from-scipy","title":"Nelder-Mead Generator adapted from SciPy\u00b6","text":"<p>Most of the algorithms in scipy.optimize are self-contained functions that operate on the user-provided <code>func</code>. Xopt has adapted the Nelder-Mead directly from scipy.optimize to be in a generator form. This allows for the manual stepping through the algorithm.</p>"},{"location":"examples/scipy/neldermead/#nelder-mead-optimization-of-the-rosenbrock-function-with-xopt","title":"Nelder-Mead optimization of the Rosenbrock function with Xopt\u00b6","text":""},{"location":"examples/scipy/neldermead/#visualize","title":"Visualize\u00b6","text":""},{"location":"examples/scipy/neldermead/#compare-with-scipyoptimizefmin-nelder-mead","title":"Compare with scipy.optimize.fmin Nelder-Mead\u00b6","text":"<p>Notice that fmin is much faster here. This is because the function runs very fast, so the internal Xopt bookkeeping overhead dominates.</p>"},{"location":"examples/scipy/neldermead/#neldermeadgenerator-object","title":"NelderMeadGenerator object\u00b6","text":""},{"location":"examples/scipy/neldermead/#5-dimensional-rosenbrock","title":"5-dimensional Rosenbrock\u00b6","text":"<p><code>evaluate_rosenbrock</code> works for arbitrary dimensions, so adding more variables to <code>vocs</code> transforms this problem.</p>"},{"location":"examples/single_objective_bayes_opt/bax_tutorial/","title":"Basic Optimization using BAX","text":"In\u00a0[1]: Copied! <pre># Ignore all warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport os\nos.environ['KMP_DUPLICATE_LIB_OK'] = 'True'\n\nimport torch\n\nfrom xopt import Xopt\nfrom xopt.vocs import VOCS\nfrom xopt.generators.bayesian.bax_generator import BaxGenerator\n\nfrom xopt.evaluator import Evaluator\n\nimport numpy as np\nimport random\n\n\n#random seeds for reproducibility \nrand_seed = 2\n\ntorch.manual_seed(rand_seed)\nnp.random.seed(rand_seed) #only affects initial random observations through Xopt\nrandom.seed(rand_seed)\n</pre> # Ignore all warnings import warnings warnings.filterwarnings(\"ignore\")  import os os.environ['KMP_DUPLICATE_LIB_OK'] = 'True'  import torch  from xopt import Xopt from xopt.vocs import VOCS from xopt.generators.bayesian.bax_generator import BaxGenerator  from xopt.evaluator import Evaluator  import numpy as np import random   #random seeds for reproducibility  rand_seed = 2  torch.manual_seed(rand_seed) np.random.seed(rand_seed) #only affects initial random observations through Xopt random.seed(rand_seed) In\u00a0[2]: Copied! <pre>import math\n\n# define variables and function objectives\nvocs = VOCS(\n    variables={\"x\": [0, 2 * math.pi]},\n    objectives={\"y1\": \"MAXIMIZE\"},\n)\n</pre> import math  # define variables and function objectives vocs = VOCS(     variables={\"x\": [0, 2 * math.pi]},     objectives={\"y1\": \"MAXIMIZE\"}, ) In\u00a0[3]: Copied! <pre># define a test function to optimize\nimport numpy as np\n\ndef sin_function(input_dict):\n    return {\"y1\": np.sin(input_dict[\"x\"])}\n</pre> # define a test function to optimize import numpy as np  def sin_function(input_dict):     return {\"y1\": np.sin(input_dict[\"x\"])} In\u00a0[4]: Copied! <pre>from xopt.generators.bayesian.bax.algorithms import GridMinimize\n\n#Prepare BAX algorithm and generator options\nalgorithm = GridMinimize(n_mesh_points=50)\n\n#construct BAX generator\ngenerator = BaxGenerator(vocs=vocs, algorithm=algorithm)\n</pre> from xopt.generators.bayesian.bax.algorithms import GridMinimize  #Prepare BAX algorithm and generator options algorithm = GridMinimize(n_mesh_points=50)  #construct BAX generator generator = BaxGenerator(vocs=vocs, algorithm=algorithm) In\u00a0[5]: Copied! <pre>#construct evaluator\nevaluator = Evaluator(function=sin_function)\n\n#construct Xopt optimizer\nX = Xopt(evaluator=evaluator, generator=generator, vocs=vocs)\n</pre> #construct evaluator evaluator = Evaluator(function=sin_function)  #construct Xopt optimizer X = Xopt(evaluator=evaluator, generator=generator, vocs=vocs) In\u00a0[6]: Copied! <pre># evaluate initial points\nX.random_evaluate(3)\n\n# inspect the gathered data\nX.data\n</pre> # evaluate initial points X.random_evaluate(3)  # inspect the gathered data X.data Out[6]: x y1 xopt_runtime xopt_error 0 3.543749 -0.391403 0.000018 False 1 6.120286 -0.162180 0.000003 False 2 2.829554 0.306999 0.000002 False In\u00a0[7]: Copied! <pre>import torch\nimport matplotlib.pyplot as plt\nn_steps = 3\n\n# test points for plotting\ntest_x = torch.linspace(*X.vocs.bounds.flatten(),50).double()\n\nfor i in range(5):\n    # get the Gaussian process model from the generator\n    model = X.generator.train_model()\n\n    # get acquisition function from generator\n    acq = X.generator.get_acquisition(model)\n\n    # calculate model posterior and acquisition function at each test point\n    # NOTE: need to add a dimension to the input tensor for evaluating the\n    # posterior and another for the acquisition function, see\n    # https://botorch.org/docs/batching for details\n    # NOTE: we use the `torch.no_grad()` environment to speed up computation by\n    # skipping calculations for backpropagation\n    with torch.no_grad():\n        posterior = model.posterior(test_x.unsqueeze(1))\n        acq_val = acq(test_x.reshape(-1,1,1))\n\n    # get mean function and confidence regions\n    mean = posterior.mean\n    l,u = posterior.mvn.confidence_region()\n\n    # plot model and acquisition function\n    fig,ax = plt.subplots(3,1,sharex=\"all\")\n    fig.set_size_inches(8,6)\n\n    # plot model posterior\n    ax[0].plot(test_x, mean, label=\"Posterior mean\")\n    ax[0].fill_between(test_x, l, u,alpha=0.25, label=\"Posterior confidence region\")\n\n    # add data to model plot\n    ax[0].plot(X.data[\"x\"],X.data[\"y1\"],\"C1o\", label=\"Training data\")\n\n    # plot true function\n    true_f = sin_function({\"x\": test_x})[\"y1\"]\n    ax[0].plot(test_x, true_f,'--', label=\"Ground truth\")\n\n    if i == 0:\n        ax[0].legend(ncols=2)\n\n    # plot the function samples and their optima found by BAX\n    test_points = X.generator.algorithm_results[\"test_points\"]\n    posterior_samples = X.generator.algorithm_results[\"posterior_samples\"]\n    execution_paths = X.generator.algorithm_results[\"execution_paths\"]\n\n    label1 = 'Function Samples'\n    label2 = 'Sample Optima'\n    for i in range(X.generator.algorithm.n_samples):\n        samples, = ax[1].plot(test_points, posterior_samples[i], c='C0', alpha=0.3,\n                              label=label1)\n        optima = ax[1].scatter(*execution_paths[i], c='r', marker='x', s=80,\n                               label=label2,zorder=10)\n        label1 = None\n        label2 = None \n    \n    # add legend\n    if i == 0:\n        ax[1].legend()\n\n    # plot acquisition function\n    ax[2].plot(test_x, acq_val.flatten())\n\n    ax[0].set_ylabel(\"y1\")\n    ax[1].set_ylabel(\"y1\")\n    ax[2].set_ylabel(r\"$\\alpha(x)$\")\n    ax[2].set_xlabel(\"x\")\n\n    # do the optimization step\n    X.step()\n</pre> import torch import matplotlib.pyplot as plt n_steps = 3  # test points for plotting test_x = torch.linspace(*X.vocs.bounds.flatten(),50).double()  for i in range(5):     # get the Gaussian process model from the generator     model = X.generator.train_model()      # get acquisition function from generator     acq = X.generator.get_acquisition(model)      # calculate model posterior and acquisition function at each test point     # NOTE: need to add a dimension to the input tensor for evaluating the     # posterior and another for the acquisition function, see     # https://botorch.org/docs/batching for details     # NOTE: we use the `torch.no_grad()` environment to speed up computation by     # skipping calculations for backpropagation     with torch.no_grad():         posterior = model.posterior(test_x.unsqueeze(1))         acq_val = acq(test_x.reshape(-1,1,1))      # get mean function and confidence regions     mean = posterior.mean     l,u = posterior.mvn.confidence_region()      # plot model and acquisition function     fig,ax = plt.subplots(3,1,sharex=\"all\")     fig.set_size_inches(8,6)      # plot model posterior     ax[0].plot(test_x, mean, label=\"Posterior mean\")     ax[0].fill_between(test_x, l, u,alpha=0.25, label=\"Posterior confidence region\")      # add data to model plot     ax[0].plot(X.data[\"x\"],X.data[\"y1\"],\"C1o\", label=\"Training data\")      # plot true function     true_f = sin_function({\"x\": test_x})[\"y1\"]     ax[0].plot(test_x, true_f,'--', label=\"Ground truth\")      if i == 0:         ax[0].legend(ncols=2)      # plot the function samples and their optima found by BAX     test_points = X.generator.algorithm_results[\"test_points\"]     posterior_samples = X.generator.algorithm_results[\"posterior_samples\"]     execution_paths = X.generator.algorithm_results[\"execution_paths\"]      label1 = 'Function Samples'     label2 = 'Sample Optima'     for i in range(X.generator.algorithm.n_samples):         samples, = ax[1].plot(test_points, posterior_samples[i], c='C0', alpha=0.3,                               label=label1)         optima = ax[1].scatter(*execution_paths[i], c='r', marker='x', s=80,                                label=label2,zorder=10)         label1 = None         label2 = None           # add legend     if i == 0:         ax[1].legend()      # plot acquisition function     ax[2].plot(test_x, acq_val.flatten())      ax[0].set_ylabel(\"y1\")     ax[1].set_ylabel(\"y1\")     ax[2].set_ylabel(r\"$\\alpha(x)$\")     ax[2].set_xlabel(\"x\")      # do the optimization step     X.step()  In\u00a0[8]: Copied! <pre># access the collected data\nX.data\n</pre> # access the collected data X.data Out[8]: x y1 xopt_runtime xopt_error 0 3.543749 -0.391403 0.000018 False 1 6.120286 -0.162180 0.000003 False 2 2.829554 0.306999 0.000002 False 4 4.359615 -0.938418 0.000013 False 5 4.741395 -0.999579 0.000011 False 6 4.886320 -0.984912 0.000012 False 7 4.693164 -0.999815 0.000012 False 8 4.740927 -0.999593 0.000011 False In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/single_objective_bayes_opt/bax_tutorial/#basic-optimization-using-bax","title":"Basic Optimization using BAX\u00b6","text":"<p>In this notebook we demonstrate the use of Xopt to perform Bayesian Algorithm Execution (BAX) as a means of minimizing the output of a simple test function. BAX is a generalization of Bayesian Optimization that seeks to acquire observations that provide our model with maximal information about our property of interest. In this simple example, our property of interest is the minimum function output and its location in input-space. See https://arxiv.org/pdf/2209.04587.pdf for details.</p>"},{"location":"examples/single_objective_bayes_opt/bax_tutorial/#imports-and-random-seeding-for-reproducibility","title":"Imports and random seeding for reproducibility\u00b6","text":""},{"location":"examples/single_objective_bayes_opt/bax_tutorial/#define-the-test-problem","title":"Define the test problem\u00b6","text":"<p>Here we define a simple optimization problem, where we attempt to minimize the sin function in the domian [0,2*pi]. Note that the function used to evaluate the objective function takes a dictionary as input and returns a dictionary as the output.</p>"},{"location":"examples/single_objective_bayes_opt/bax_tutorial/#prepare-bax-generator-for-xopt","title":"Prepare BAX generator for Xopt\u00b6","text":"<p>Create a generator that uses the ExpectedInformationGain (InfoBAX) acquisition function to perform Bayesian Optimization. Note that we use minimization on a grid, so specifying the number of mesh points can negatively impact decision making time (especially in higher dimensional feature spaces).</p>"},{"location":"examples/single_objective_bayes_opt/bax_tutorial/#create-evaluator-and-xopt-objects","title":"Create Evaluator and Xopt objects\u00b6","text":"<p>Create the Evaluator (which allows Xopt to interface with our test function) and finish constructing our Xopt object.</p>"},{"location":"examples/single_objective_bayes_opt/bax_tutorial/#generate-and-evaluate-initial-points","title":"Generate and evaluate initial points\u00b6","text":"<p>To begin optimization, we must generate some random initial data points. The first call to <code>X.step()</code> will generate and evaluate a number of randomly points specified by the generator. Note that if we add data to xopt before calling <code>X.step()</code> by assigning the data to <code>X.data</code>, calls to <code>X.step()</code> will ignore the random generation and proceed to generating points via Bayesian optimization.</p>"},{"location":"examples/single_objective_bayes_opt/bax_tutorial/#do-bayesian-optimization-steps","title":"Do bayesian optimization steps\u00b6","text":"<p>To perform optimization we simply call <code>X.step()</code> in a loop. This allows us to do intermediate tasks in between optimization steps, such as examining the model and acquisition function at each step (as we demonstrate here).</p>"},{"location":"examples/single_objective_bayes_opt/benchmarking/","title":"Normal Model with Standard transforms and no constraints","text":"In\u00a0[1]: Copied! <pre># Ignore all warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport torch\nfrom copy import deepcopy\nfrom xopt.generators.bayesian import UpperConfidenceBoundGenerator\nfrom xopt.vocs import VOCS\n\nvocs = VOCS(\n    variables = {\"x\":[0,1]},\n    objectives = {\"y\":\"MAXIMIZE\"},\n    constraints = {\"c\": [\"LESS_THAN\", 0]}\n)\n</pre> # Ignore all warnings import warnings warnings.filterwarnings(\"ignore\")  import matplotlib.pyplot as plt import pandas as pd import torch from copy import deepcopy from xopt.generators.bayesian import UpperConfidenceBoundGenerator from xopt.vocs import VOCS  vocs = VOCS(     variables = {\"x\":[0,1]},     objectives = {\"y\":\"MAXIMIZE\"},     constraints = {\"c\": [\"LESS_THAN\", 0]} )  In\u00a0[2]: Copied! <pre># define test functions\ndef y(x):\n    return torch.sin(2*3.14*x)\n\ndef c(x):\n    return 10.0*torch.cos(2*3.14*x + 0.25)\n\ntest_x = torch.linspace(*torch.tensor(vocs.bounds.flatten()), 100)\n\n# define training data to pass to the generator\ntrain_x = torch.tensor((0.2,0.5, 0.6))\ntrain_y = y(train_x)\ntrain_c = c(train_x)\n\ndata = pd.DataFrame(\n    {\"x\": train_x.numpy(), \"y\": train_y.numpy(), \"c\": train_c}\n)\n\ndef plot_ground_truth():\n    fig,ax = plt.subplots()\n    ax.plot(test_x, y(test_x),'--C0')\n    ax.plot(test_x, c(test_x),'--C1')\n    ax.plot(train_x, train_y,'oC0')\n    ax.plot(train_x, train_c,'oC1')\n\n    return ax\nplot_ground_truth()\n</pre> # define test functions def y(x):     return torch.sin(2*3.14*x)  def c(x):     return 10.0*torch.cos(2*3.14*x + 0.25)  test_x = torch.linspace(*torch.tensor(vocs.bounds.flatten()), 100)  # define training data to pass to the generator train_x = torch.tensor((0.2,0.5, 0.6)) train_y = y(train_x) train_c = c(train_x)  data = pd.DataFrame(     {\"x\": train_x.numpy(), \"y\": train_y.numpy(), \"c\": train_c} )  def plot_ground_truth():     fig,ax = plt.subplots()     ax.plot(test_x, y(test_x),'--C0')     ax.plot(test_x, c(test_x),'--C1')     ax.plot(train_x, train_y,'oC0')     ax.plot(train_x, train_c,'oC1')      return ax plot_ground_truth() Out[2]: <pre>&lt;Axes: &gt;</pre> In\u00a0[3]: Copied! <pre>from xopt.utils import visualize_model\n\n# plot the generator model and acquisition function\ntest_vocs = deepcopy(vocs)\ntest_vocs.constraints = {}\ngenerator = UpperConfidenceBoundGenerator(vocs=test_vocs)\ngenerator.add_data(data)\n\nvisualize_model(generator)\n</pre> from xopt.utils import visualize_model  # plot the generator model and acquisition function test_vocs = deepcopy(vocs) test_vocs.constraints = {} generator = UpperConfidenceBoundGenerator(vocs=test_vocs) generator.add_data(data)  visualize_model(generator) Out[3]: <pre>(&lt;Figure size 400x200 with 2 Axes&gt;,\n array([&lt;Axes: ylabel='y'&gt;, &lt;Axes: xlabel='x', ylabel='$\\\\alpha(x)$'&gt;],\n       dtype=object))</pre> In\u00a0[4]: Copied! <pre># plot the generator model and acquisition function\ngenerator = UpperConfidenceBoundGenerator(vocs=deepcopy(vocs))\ngenerator.add_data(data)\nvisualize_model(generator)\n</pre> # plot the generator model and acquisition function generator = UpperConfidenceBoundGenerator(vocs=deepcopy(vocs)) generator.add_data(data) visualize_model(generator)  Out[4]: <pre>(&lt;Figure size 400x400 with 3 Axes&gt;,\n array([&lt;Axes: ylabel='y'&gt;, &lt;Axes: ylabel='c'&gt;,\n        &lt;Axes: xlabel='x', ylabel='$\\\\alpha(x)$'&gt;], dtype=object))</pre> In\u00a0[5]: Copied! <pre># plot the generator model and acquisition function\ntvocs = deepcopy(vocs)\ntvocs.constraints = {\"c\": [\"GREATER_THAN\", 0]}\n\ngenerator = UpperConfidenceBoundGenerator(vocs=tvocs)\ngenerator.add_data(data)\nvisualize_model(generator)\n</pre> # plot the generator model and acquisition function tvocs = deepcopy(vocs) tvocs.constraints = {\"c\": [\"GREATER_THAN\", 0]}  generator = UpperConfidenceBoundGenerator(vocs=tvocs) generator.add_data(data) visualize_model(generator) Out[5]: <pre>(&lt;Figure size 400x400 with 3 Axes&gt;,\n array([&lt;Axes: ylabel='y'&gt;, &lt;Axes: ylabel='c'&gt;,\n        &lt;Axes: xlabel='x', ylabel='$\\\\alpha(x)$'&gt;], dtype=object))</pre> In\u00a0[6]: Copied! <pre># plot the generator model and acquisition function\nfrom xopt.generators.bayesian import BayesianExplorationGenerator\ngenerator = BayesianExplorationGenerator(vocs=vocs)\ngenerator.add_data(data)\nvisualize_model(generator)\n</pre> # plot the generator model and acquisition function from xopt.generators.bayesian import BayesianExplorationGenerator generator = BayesianExplorationGenerator(vocs=vocs) generator.add_data(data) visualize_model(generator) Out[6]: <pre>(&lt;Figure size 400x400 with 3 Axes&gt;,\n array([&lt;Axes: ylabel='y'&gt;, &lt;Axes: ylabel='c'&gt;,\n        &lt;Axes: xlabel='x', ylabel='$\\\\alpha(x)$'&gt;], dtype=object))</pre> In\u00a0[7]: Copied! <pre>generator = BayesianExplorationGenerator(vocs=vocs)\n\ndata = pd.DataFrame(\n    {\"x\": train_x.numpy(), \"y\": train_y.numpy(), \"c\": torch.zeros_like(train_y).numpy()}\n)\ngenerator.add_data(data)\nvisualize_model(generator)\n</pre> generator = BayesianExplorationGenerator(vocs=vocs)  data = pd.DataFrame(     {\"x\": train_x.numpy(), \"y\": train_y.numpy(), \"c\": torch.zeros_like(train_y).numpy()} ) generator.add_data(data) visualize_model(generator) Out[7]: <pre>(&lt;Figure size 400x400 with 3 Axes&gt;,\n array([&lt;Axes: ylabel='y'&gt;, &lt;Axes: ylabel='c'&gt;,\n        &lt;Axes: xlabel='x', ylabel='$\\\\alpha(x)$'&gt;], dtype=object))</pre> In\u00a0[8]: Copied! <pre>test_vocs = deepcopy(vocs)\ntest_vocs.constraints = {}\ngenerator = BayesianExplorationGenerator(vocs=test_vocs)\n\ndata = pd.DataFrame(\n    {\"x\": train_x.numpy(), \"y\": train_y.numpy(), \"c\": torch.zeros_like(train_y).numpy()}\n)\ngenerator.add_data(data)\nvisualize_model(generator)\n</pre> test_vocs = deepcopy(vocs) test_vocs.constraints = {} generator = BayesianExplorationGenerator(vocs=test_vocs)  data = pd.DataFrame(     {\"x\": train_x.numpy(), \"y\": train_y.numpy(), \"c\": torch.zeros_like(train_y).numpy()} ) generator.add_data(data) visualize_model(generator)  Out[8]: <pre>(&lt;Figure size 400x200 with 2 Axes&gt;,\n array([&lt;Axes: ylabel='y'&gt;, &lt;Axes: xlabel='x', ylabel='$\\\\alpha(x)$'&gt;],\n       dtype=object))</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/single_objective_bayes_opt/benchmarking/#normal-model-with-standard-transforms-and-no-constraints","title":"Normal Model with Standard transforms and no constraints\u00b6","text":"<ul> <li>acquisition function is UCB with beta = 2</li> </ul>"},{"location":"examples/single_objective_bayes_opt/benchmarking/#normal-model-with-standard-transforms-and-constraints","title":"Normal Model with Standard transforms and constraints\u00b6","text":""},{"location":"examples/single_objective_bayes_opt/bo_tutorial/","title":"Bayesian optimization tutorial","text":"In\u00a0[1]: Copied! <pre>from xopt.vocs import VOCS\nimport math\n\n# define variables and function objectives\nvocs = VOCS(\n    variables={\"x\": [0, 2 * math.pi]},\n    objectives={\"f\": \"MINIMIZE\"},\n)\n</pre> from xopt.vocs import VOCS import math  # define variables and function objectives vocs = VOCS(     variables={\"x\": [0, 2 * math.pi]},     objectives={\"f\": \"MINIMIZE\"}, ) In\u00a0[2]: Copied! <pre># define a test function to optimize\nimport numpy as np\n\ndef sin_function(input_dict):\n    return {\"f\": np.sin(input_dict[\"x\"])}\n</pre> # define a test function to optimize import numpy as np  def sin_function(input_dict):     return {\"f\": np.sin(input_dict[\"x\"])} In\u00a0[3]: Copied! <pre>from xopt.evaluator import Evaluator\nfrom xopt.generators.bayesian import UpperConfidenceBoundGenerator\nfrom xopt import Xopt\n\nevaluator = Evaluator(function=sin_function)\ngenerator = UpperConfidenceBoundGenerator(vocs=vocs)\nX = Xopt(evaluator=evaluator, generator=generator, vocs=vocs)\n</pre> from xopt.evaluator import Evaluator from xopt.generators.bayesian import UpperConfidenceBoundGenerator from xopt import Xopt  evaluator = Evaluator(function=sin_function) generator = UpperConfidenceBoundGenerator(vocs=vocs) X = Xopt(evaluator=evaluator, generator=generator, vocs=vocs) In\u00a0[4]: Copied! <pre># call X.random_evaluate() to generate + evaluate 3 initial points\nX.random_evaluate(2)\n\n# inspect the gathered data\nX.data\n</pre> # call X.random_evaluate() to generate + evaluate 3 initial points X.random_evaluate(2)  # inspect the gathered data X.data Out[4]: x f xopt_runtime xopt_error 0 3.627527 -0.467035 0.000024 False 1 0.564473 0.534970 0.000003 False In\u00a0[5]: Copied! <pre>import torch\nimport matplotlib.pyplot as plt\n\nn_steps = 5\n\n# test points for plotting\ntest_x = torch.linspace(*X.vocs.bounds.flatten(), 50).double()\n\nfor i in range(n_steps):\n    # get the Gaussian process model from the generator\n    model = X.generator.train_model()\n\n    # get acquisition function from generator\n    acq = X.generator.get_acquisition(model)\n\n    # calculate model posterior and acquisition function at each test point\n    # NOTE: need to add a dimension to the input tensor for evaluating the\n    # posterior and another for the acquisition function, see\n    # https://botorch.org/docs/batching for details\n    # NOTE: we use the `torch.no_grad()` environment to speed up computation by\n    # skipping calculations for backpropagation\n    with torch.no_grad():\n        posterior = model.posterior(test_x.unsqueeze(1))\n        acq_val = acq(test_x.reshape(-1, 1, 1))\n\n    # get mean function and confidence regions\n    mean = posterior.mean\n    l,u = posterior.mvn.confidence_region()\n\n    # plot model and acquisition function\n    fig,ax = plt.subplots(2, 1, sharex=\"all\")\n\n    # plot model posterior\n    ax[0].plot(test_x, mean, label=\"Posterior mean\")\n    ax[0].fill_between(test_x, l, u, alpha=0.25, label=\"Posterior confidence region\")\n\n    # add data to model plot\n    ax[0].plot(X.data[\"x\"],X.data[\"f\"],\"C1o\", label=\"Training data\")\n\n    # plot true function\n    true_f = sin_function({\"x\": test_x})[\"f\"]\n    ax[0].plot(test_x, true_f,'--', label=\"Ground truth\")\n\n    # add legend\n    ax[0].legend()\n\n    # plot acquisition function\n    ax[1].plot(test_x, acq_val.flatten())\n\n    ax[0].set_ylabel(\"f\")\n    ax[1].set_ylabel(r\"$\\alpha(x)$\")\n    ax[1].set_xlabel(\"x\")\n\n    # do the optimization step\n    X.step()\n</pre> import torch import matplotlib.pyplot as plt  n_steps = 5  # test points for plotting test_x = torch.linspace(*X.vocs.bounds.flatten(), 50).double()  for i in range(n_steps):     # get the Gaussian process model from the generator     model = X.generator.train_model()      # get acquisition function from generator     acq = X.generator.get_acquisition(model)      # calculate model posterior and acquisition function at each test point     # NOTE: need to add a dimension to the input tensor for evaluating the     # posterior and another for the acquisition function, see     # https://botorch.org/docs/batching for details     # NOTE: we use the `torch.no_grad()` environment to speed up computation by     # skipping calculations for backpropagation     with torch.no_grad():         posterior = model.posterior(test_x.unsqueeze(1))         acq_val = acq(test_x.reshape(-1, 1, 1))      # get mean function and confidence regions     mean = posterior.mean     l,u = posterior.mvn.confidence_region()      # plot model and acquisition function     fig,ax = plt.subplots(2, 1, sharex=\"all\")      # plot model posterior     ax[0].plot(test_x, mean, label=\"Posterior mean\")     ax[0].fill_between(test_x, l, u, alpha=0.25, label=\"Posterior confidence region\")      # add data to model plot     ax[0].plot(X.data[\"x\"],X.data[\"f\"],\"C1o\", label=\"Training data\")      # plot true function     true_f = sin_function({\"x\": test_x})[\"f\"]     ax[0].plot(test_x, true_f,'--', label=\"Ground truth\")      # add legend     ax[0].legend()      # plot acquisition function     ax[1].plot(test_x, acq_val.flatten())      ax[0].set_ylabel(\"f\")     ax[1].set_ylabel(r\"$\\alpha(x)$\")     ax[1].set_xlabel(\"x\")      # do the optimization step     X.step()  <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> In\u00a0[6]: Copied! <pre># access the collected data\nX.data\n</pre> # access the collected data X.data Out[6]: x f xopt_runtime xopt_error 0 3.627527 -0.467035 0.000024 False 1 0.564473 0.534970 0.000003 False 3 6.235003 -0.048164 0.000013 False 4 4.604057 -0.994138 0.000012 False 5 5.026595 -0.951042 0.000012 False 6 4.765379 -0.998596 0.000011 False 7 4.733925 -0.999768 0.000012 False In\u00a0[7]: Copied! <pre>X.generator.get_optimum()\n</pre> X.generator.get_optimum() Out[7]: x 0 4.720875 In\u00a0[8]: Copied! <pre>X.generator.dict()\n</pre> X.generator.dict() <pre>/tmp/ipykernel_3276/1542263183.py:1: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.4/migration/\n  X.generator.dict()\n</pre> Out[8]: <pre>{'model': ModelListGP(\n   (models): ModuleList(\n     (0): SingleTaskGP(\n       (likelihood): GaussianLikelihood(\n         (noise_covar): HomoskedasticNoise(\n           (noise_prior): GammaPrior()\n           (raw_noise_constraint): GreaterThan(1.000E-04)\n         )\n       )\n       (mean_module): ConstantMean()\n       (covar_module): ScaleKernel(\n         (base_kernel): MaternKernel(\n           (lengthscale_prior): GammaPrior()\n           (raw_lengthscale_constraint): Positive()\n         )\n         (outputscale_prior): GammaPrior()\n         (raw_outputscale_constraint): Positive()\n       )\n       (outcome_transform): Standardize()\n       (input_transform): Normalize()\n     )\n   )\n   (likelihood): LikelihoodList(\n     (likelihoods): ModuleList(\n       (0): GaussianLikelihood(\n         (noise_covar): HomoskedasticNoise(\n           (noise_prior): GammaPrior()\n           (raw_noise_constraint): GreaterThan(1.000E-04)\n         )\n       )\n     )\n   )\n ),\n 'n_monte_carlo_samples': 128,\n 'turbo_controller': None,\n 'use_cuda': False,\n 'gp_constructor': {'name': 'standard',\n  'use_low_noise_prior': True,\n  'covar_modules': {},\n  'mean_modules': {},\n  'trainable_mean_keys': []},\n 'numerical_optimizer': {'name': 'LBFGS',\n  'n_raw_samples': 20,\n  'n_restarts': 20,\n  'max_iter': 2000},\n 'max_travel_distances': None,\n 'fixed_features': None,\n 'computation_time':    training  acquisition_optimization\n 0  0.115502                  0.051392\n 1  0.108203                  0.035386\n 2  0.111601                  0.056706\n 3  0.110692                  0.103134\n 4  0.122124                  0.069001,\n 'n_candidates': 1,\n 'beta': 2.0}</pre> In\u00a0[8]: Copied! <pre>\n</pre>"},{"location":"examples/single_objective_bayes_opt/bo_tutorial/#basic-bayesian-optimization","title":"Basic Bayesian Optimization\u00b6","text":"<p>In this tutorial we demonstrate the use of Xopt to preform Bayesian Optimization on a simple test problem.</p>"},{"location":"examples/single_objective_bayes_opt/bo_tutorial/#define-the-test-problem","title":"Define the test problem\u00b6","text":"<p>Here we define a simple optimization problem, where we attempt to minimize the sin function in the domian [0,2*pi]. Note that the function used to evaluate the objective function takes a dictionary as input and returns a dictionary as the output.</p>"},{"location":"examples/single_objective_bayes_opt/bo_tutorial/#create-xopt-objects","title":"Create Xopt objects\u00b6","text":"<p>Create the evaluator to evaluate our test function and create a generator that uses the Upper Confidence Bound acquisition function to perform Bayesian Optimization.</p>"},{"location":"examples/single_objective_bayes_opt/bo_tutorial/#generate-and-evaluate-initial-points","title":"Generate and evaluate initial points\u00b6","text":"<p>To begin optimization, we must generate some random initial data points. The first call to <code>X.step()</code> will generate and evaluate a number of randomly points specified by the generator. Note that if we add data to xopt before calling <code>X.step()</code> by assigning the data to <code>X.data</code>, calls to <code>X.step()</code> will ignore the random generation and proceed to generating points via Bayesian optimization.</p>"},{"location":"examples/single_objective_bayes_opt/bo_tutorial/#do-bayesian-optimization-steps","title":"Do bayesian optimization steps\u00b6","text":"<p>To perform optimization we simply call <code>X.step()</code> in a loop. This allows us to do intermediate tasks in between optimization steps, such as examining the model and acquisition function at each step (as we demonstrate here).</p>"},{"location":"examples/single_objective_bayes_opt/bo_tutorial/#getting-the-optimization-result","title":"Getting the optimization result\u00b6","text":"<p>To get the best point (without evaluating it) we ask the generator to predict the optimum based on the posterior mean.</p>"},{"location":"examples/single_objective_bayes_opt/bo_tutorial/#customizing-optimization","title":"Customizing optimization\u00b6","text":"<p>Each generator has a set of options that can be modified to effect optimization behavior</p>"},{"location":"examples/single_objective_bayes_opt/constrained_bo_tutorial/","title":"Constrained optimization","text":"In\u00a0[1]: Copied! <pre>import time\n\nfrom xopt.vocs import VOCS\nimport math\n\n# define variables, function objective and constraining function\nvocs = VOCS(\n    variables={\"x\": [0, 2 * math.pi]},\n    objectives={\"f\": \"MINIMIZE\"},\n    constraints={\"c\": [\"LESS_THAN\", 0]}\n)\n</pre> import time  from xopt.vocs import VOCS import math  # define variables, function objective and constraining function vocs = VOCS(     variables={\"x\": [0, 2 * math.pi]},     objectives={\"f\": \"MINIMIZE\"},     constraints={\"c\": [\"LESS_THAN\", 0]} ) In\u00a0[2]: Copied! <pre># define a test function to optimize\nimport numpy as np\n\ndef test_function(input_dict):\n    return {\"f\": np.sin(input_dict[\"x\"]),\"c\": np.cos(input_dict[\"x\"])}\n</pre> # define a test function to optimize import numpy as np  def test_function(input_dict):     return {\"f\": np.sin(input_dict[\"x\"]),\"c\": np.cos(input_dict[\"x\"])} In\u00a0[3]: Copied! <pre>from xopt.evaluator import Evaluator\nfrom xopt.generators.bayesian import UpperConfidenceBoundGenerator\nfrom xopt import Xopt\n\nevaluator = Evaluator(function=test_function)\ngenerator = UpperConfidenceBoundGenerator(vocs=vocs)\nX = Xopt(evaluator=evaluator, generator=generator, vocs=vocs)\n</pre> from xopt.evaluator import Evaluator from xopt.generators.bayesian import UpperConfidenceBoundGenerator from xopt import Xopt  evaluator = Evaluator(function=test_function) generator = UpperConfidenceBoundGenerator(vocs=vocs) X = Xopt(evaluator=evaluator, generator=generator, vocs=vocs) <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/upper_confidence_bound.py:26: UserWarning: Using UpperConfidenceBoundGenerator with constraints may lead to numerical issues if the base acquisition function has negative values.\n  warnings.warn(\n</pre> In\u00a0[4]: Copied! <pre># call X.random_evaluate() to generate + evaluate 3 initial points\nX.random_evaluate(2)\n\n# inspect the gathered data\nX.data\n</pre> # call X.random_evaluate() to generate + evaluate 3 initial points X.random_evaluate(2)  # inspect the gathered data X.data Out[4]: x f c xopt_runtime xopt_error 0 1.779511 0.978298 -0.207203 0.000029 False 1 1.672000 0.994883 -0.101031 0.000003 False In\u00a0[5]: Copied! <pre>import time\nfrom xopt.utils import visualize_model\n\nn_steps = 5\n\n# test points for plotting\ntest_x = np.linspace(*X.vocs.bounds.flatten(), 50)\n\nfor i in range(n_steps):\n    start = time.perf_counter()\n    fig,ax = visualize_model(X.generator)\n    print(time.perf_counter() - start)\n\n    # add ground truth functions to plots\n    out = test_function({\"x\": test_x})\n    ax[0].plot(test_x, out[\"f\"], \"C0-.\",label=\"Ground truth\")\n    ax[1].plot(test_x, out[\"c\"], \"C1-.\")\n\n    ax[0].legend()\n\n    # do the optimization step\n    X.step()\n</pre> import time from xopt.utils import visualize_model  n_steps = 5  # test points for plotting test_x = np.linspace(*X.vocs.bounds.flatten(), 50)  for i in range(n_steps):     start = time.perf_counter()     fig,ax = visualize_model(X.generator)     print(time.perf_counter() - start)      # add ground truth functions to plots     out = test_function({\"x\": test_x})     ax[0].plot(test_x, out[\"f\"], \"C0-.\",label=\"Ground truth\")     ax[1].plot(test_x, out[\"c\"], \"C1-.\")      ax[0].legend()      # do the optimization step     X.step()  <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/custom_botorch/constrained_acquisition.py:89: UserWarning: The base acquisition function has negative values and a softplus transformation will be applied. This may cause numerical issues for large negative values.\n  warnings.warn(\n</pre> <pre>0.6921182879999606\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/custom_botorch/constrained_acquisition.py:89: UserWarning: The base acquisition function has negative values and a softplus transformation will be applied. This may cause numerical issues for large negative values.\n  warnings.warn(\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>0.3613567849999981\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/custom_botorch/constrained_acquisition.py:89: UserWarning: The base acquisition function has negative values and a softplus transformation will be applied. This may cause numerical issues for large negative values.\n  warnings.warn(\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>0.31745709300003\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/custom_botorch/constrained_acquisition.py:89: UserWarning: The base acquisition function has negative values and a softplus transformation will be applied. This may cause numerical issues for large negative values.\n  warnings.warn(\n</pre> <pre>0.5041543680000586\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/custom_botorch/constrained_acquisition.py:89: UserWarning: The base acquisition function has negative values and a softplus transformation will be applied. This may cause numerical issues for large negative values.\n  warnings.warn(\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>0.34552035499996236\n</pre> In\u00a0[6]: Copied! <pre># access the collected data\nX.data\n</pre> # access the collected data X.data Out[6]: x f c xopt_runtime xopt_error 0 1.779511 0.978298 -0.207203 0.000029 False 1 1.672000 0.994883 -0.101031 0.000003 False 3 2.077877 0.874166 -0.485627 0.000016 False 4 2.969605 0.171141 -0.985247 0.000016 False 5 4.690494 -0.999760 -0.021893 0.000015 False 6 4.697787 -0.999893 -0.014602 0.000016 False 7 4.697770 -0.999893 -0.014618 0.000016 False"},{"location":"examples/single_objective_bayes_opt/constrained_bo_tutorial/#constrained-bayesian-optimization","title":"Constrained Bayesian Optimization\u00b6","text":"<p>In this tutorial we demonstrate the use of Xopt to preform Bayesian Optimization on a simple test problem subject to a single constraint.</p>"},{"location":"examples/single_objective_bayes_opt/constrained_bo_tutorial/#define-the-test-problem","title":"Define the test problem\u00b6","text":"<p>Here we define a simple optimization problem, where we attempt to minimize the sin function in the domian [0,2*pi], subject to a cos constraining function.</p>"},{"location":"examples/single_objective_bayes_opt/constrained_bo_tutorial/#create-xopt-objects","title":"Create Xopt objects\u00b6","text":"<p>Create the evaluator to evaluate our test function and create a generator that uses the Upper Confidence Bound acquisition function to perform Bayesian Optimization.</p>"},{"location":"examples/single_objective_bayes_opt/constrained_bo_tutorial/#generate-and-evaluate-initial-points","title":"Generate and evaluate initial points\u00b6","text":"<p>To begin optimization, we must generate some random initial data points. The first call to <code>X.step()</code> will generate and evaluate a number of randomly points specified by the generator. Note that if we add data to xopt before calling <code>X.step()</code> by assigning the data to <code>X.data</code>, calls to <code>X.step()</code> will ignore the random generation and proceed to generating points via Bayesian optimization.</p>"},{"location":"examples/single_objective_bayes_opt/constrained_bo_tutorial/#do-bayesian-optimization-steps","title":"Do bayesian optimization steps\u00b6","text":"<p>To perform optimization we simply call <code>X.step()</code> in a loop. This allows us to do intermediate tasks in between optimization steps, such as examining the model and acquisition function at each step (as we demonstrate here).</p>"},{"location":"examples/single_objective_bayes_opt/custom_model/","title":"Custom GP modeling for BO","text":"In\u00a0[1]: Copied! <pre># Ignore all warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport torch\nfrom xopt.vocs import VOCS\n\nmy_vocs = VOCS(\n    variables = {\"x\":[0,1]},\n    objectives = {\"y\":\"MAXIMIZE\"},\n    constraints = {\"c\": [\"LESS_THAN\", 0]}\n)\n</pre> # Ignore all warnings import warnings warnings.filterwarnings(\"ignore\")  import matplotlib.pyplot as plt import pandas as pd import torch from xopt.vocs import VOCS  my_vocs = VOCS(     variables = {\"x\":[0,1]},     objectives = {\"y\":\"MAXIMIZE\"},     constraints = {\"c\": [\"LESS_THAN\", 0]} )  In\u00a0[2]: Copied! <pre># define test functions\ndef y(x):\n    return torch.sin(2*3.14*x)\n\ndef c(x):\n    return 5.0*torch.cos(2*3.14*x + 0.25)\n\ntest_x = torch.linspace(*torch.tensor(my_vocs.bounds.flatten()), 100)\n\n# define training data to pass to the generator\ntrain_x = torch.tensor((0.2,0.5, 0.6))\ntrain_y = y(train_x)\ntrain_c = c(train_x)\n\ntraining_data = pd.DataFrame(\n    {\"x\": train_x.numpy(), \"y\": train_y.numpy(), \"c\": train_c}\n)\n\ndef plot_ground_truth():\n    fig,ax = plt.subplots()\n    ax.plot(test_x, y(test_x),'--C0')\n    ax.plot(test_x, c(test_x),'--C1')\n    ax.plot(train_x, train_y,'oC0')\n    ax.plot(train_x, train_c,'oC1')\n\n    return ax\nplot_ground_truth()\n</pre> # define test functions def y(x):     return torch.sin(2*3.14*x)  def c(x):     return 5.0*torch.cos(2*3.14*x + 0.25)  test_x = torch.linspace(*torch.tensor(my_vocs.bounds.flatten()), 100)  # define training data to pass to the generator train_x = torch.tensor((0.2,0.5, 0.6)) train_y = y(train_x) train_c = c(train_x)  training_data = pd.DataFrame(     {\"x\": train_x.numpy(), \"y\": train_y.numpy(), \"c\": train_c} )  def plot_ground_truth():     fig,ax = plt.subplots()     ax.plot(test_x, y(test_x),'--C0')     ax.plot(test_x, c(test_x),'--C1')     ax.plot(train_x, train_y,'oC0')     ax.plot(train_x, train_c,'oC1')      return ax plot_ground_truth() Out[2]: <pre>&lt;Axes: &gt;</pre> In\u00a0[3]: Copied! <pre>from xopt.generators.bayesian.expected_improvement import ExpectedImprovementGenerator\nfrom xopt.generators.bayesian.models.standard import StandardModelConstructor\nfrom gpytorch.kernels import PeriodicKernel, ScaleKernel\n\n\n# note the creation of options beforehand\n# specify a periodic kernel for each output (objectives and constraints)\ncovar_module = {\"y\": ScaleKernel(PeriodicKernel())}\ngp_constructor = StandardModelConstructor(\n    covar_modules=covar_module\n)\ngenerator = ExpectedImprovementGenerator(\n    vocs=my_vocs, gp_constructor=gp_constructor\n)\ngenerator\n</pre> from xopt.generators.bayesian.expected_improvement import ExpectedImprovementGenerator from xopt.generators.bayesian.models.standard import StandardModelConstructor from gpytorch.kernels import PeriodicKernel, ScaleKernel   # note the creation of options beforehand # specify a periodic kernel for each output (objectives and constraints) covar_module = {\"y\": ScaleKernel(PeriodicKernel())} gp_constructor = StandardModelConstructor(     covar_modules=covar_module ) generator = ExpectedImprovementGenerator(     vocs=my_vocs, gp_constructor=gp_constructor ) generator <pre>Verifying model name='standard' use_low_noise_prior=True covar_modules={'y': ScaleKernel(\n  (base_kernel): PeriodicKernel(\n    (raw_lengthscale_constraint): Positive()\n    (raw_period_length_constraint): Positive()\n  )\n  (raw_outputscale_constraint): Positive()\n)} mean_modules={} trainable_mean_keys=[]\n</pre> Out[3]: <pre>ExpectedImprovementGenerator(vocs=VOCS(variables={'x': [0.0, 1.0]}, constraints={'c': ['LESS_THAN', 0.0]}, objectives={'y': 'MAXIMIZE'}, constants={}, observables=[]), data=None, model=None, n_monte_carlo_samples=128, turbo_controller=None, use_cuda=False, gp_constructor=StandardModelConstructor(name='standard', use_low_noise_prior=True, covar_modules={'y': ScaleKernel(\n  (base_kernel): PeriodicKernel(\n    (raw_lengthscale_constraint): Positive()\n    (raw_period_length_constraint): Positive()\n  )\n  (raw_outputscale_constraint): Positive()\n)}, mean_modules={}, trainable_mean_keys=[]), numerical_optimizer=LBFGSOptimizer(name='LBFGS', n_raw_samples=20, n_restarts=20, max_iter=2000), max_travel_distances=None, fixed_features=None, computation_time=None, n_candidates=1)</pre> In\u00a0[4]: Copied! <pre># view custom model from data\ngenerator.add_data(training_data)\nmodel = generator.train_model()\n\nfig,ax = plt.subplots(2,1, sharex=\"all\")\nfig.set_size_inches(6,6)\nwith torch.no_grad():\n    post = model.posterior(test_x.reshape(-1,1,1).double())\n\n    for i in range(post.event_shape[-1]):\n        mean = post.mean[...,i].squeeze()\n        l,u = post.mvn.confidence_region()\n        ax[0].plot(test_x, mean,f\"C{i}\", label=generator.vocs.output_names[i])\n        ax[0].fill_between(test_x, l[...,i].squeeze(), u[...,i].squeeze(), alpha=0.5)\n\n    # plot ground truth\n    ax[0].plot(test_x, y(test_x),'C0--', label=\"y ground truth\")\n    ax[0].plot(test_x, c(test_x),'C1--', label=\"c ground truth\")\n\n    # plot training data\n    ax[0].plot(train_x, train_y,\"C0o\", label=\"y data\")\n    ax[0].plot(train_x, train_c,\"C1o\", label=\"c data\")\n    ax[0].legend()\n\n\n    acq = generator.get_acquisition(model)(test_x.reshape(-1,1,1).double())\n\n    ax[1].plot(test_x, acq, label='Acquisition Function')\n    ax[1].legend()\n</pre> # view custom model from data generator.add_data(training_data) model = generator.train_model()  fig,ax = plt.subplots(2,1, sharex=\"all\") fig.set_size_inches(6,6) with torch.no_grad():     post = model.posterior(test_x.reshape(-1,1,1).double())      for i in range(post.event_shape[-1]):         mean = post.mean[...,i].squeeze()         l,u = post.mvn.confidence_region()         ax[0].plot(test_x, mean,f\"C{i}\", label=generator.vocs.output_names[i])         ax[0].fill_between(test_x, l[...,i].squeeze(), u[...,i].squeeze(), alpha=0.5)      # plot ground truth     ax[0].plot(test_x, y(test_x),'C0--', label=\"y ground truth\")     ax[0].plot(test_x, c(test_x),'C1--', label=\"c ground truth\")      # plot training data     ax[0].plot(train_x, train_y,\"C0o\", label=\"y data\")     ax[0].plot(train_x, train_c,\"C1o\", label=\"c data\")     ax[0].legend()       acq = generator.get_acquisition(model)(test_x.reshape(-1,1,1).double())      ax[1].plot(test_x, acq, label='Acquisition Function')     ax[1].legend() In\u00a0[5]: Copied! <pre>model\n</pre> model Out[5]: <pre>ModelListGP(\n  (models): ModuleList(\n    (0): SingleTaskGP(\n      (likelihood): GaussianLikelihood(\n        (noise_covar): HomoskedasticNoise(\n          (noise_prior): GammaPrior()\n          (raw_noise_constraint): GreaterThan(1.000E-04)\n        )\n      )\n      (mean_module): ConstantMean()\n      (covar_module): ScaleKernel(\n        (base_kernel): PeriodicKernel(\n          (raw_lengthscale_constraint): Positive()\n          (raw_period_length_constraint): Positive()\n        )\n        (raw_outputscale_constraint): Positive()\n      )\n      (outcome_transform): Standardize()\n      (input_transform): Normalize()\n    )\n    (1): SingleTaskGP(\n      (likelihood): GaussianLikelihood(\n        (noise_covar): HomoskedasticNoise(\n          (noise_prior): GammaPrior()\n          (raw_noise_constraint): GreaterThan(1.000E-04)\n        )\n      )\n      (mean_module): ConstantMean()\n      (covar_module): ScaleKernel(\n        (base_kernel): MaternKernel(\n          (lengthscale_prior): GammaPrior()\n          (raw_lengthscale_constraint): Positive()\n        )\n        (outputscale_prior): GammaPrior()\n        (raw_outputscale_constraint): Positive()\n      )\n      (outcome_transform): Standardize()\n      (input_transform): Normalize()\n    )\n  )\n  (likelihood): LikelihoodList(\n    (likelihoods): ModuleList(\n      (0-1): 2 x GaussianLikelihood(\n        (noise_covar): HomoskedasticNoise(\n          (noise_prior): GammaPrior()\n          (raw_noise_constraint): GreaterThan(1.000E-04)\n        )\n      )\n    )\n  )\n)</pre> In\u00a0[6]: Copied! <pre># get the next point from the generator\ngenerator.generate(1)\n</pre> # get the next point from the generator generator.generate(1) Out[6]: <pre>[{'x': 0.28143704435686256}]</pre> In\u00a0[7]: Copied! <pre>class ConstraintPrior(torch.nn.Module):\n    def forward(self, X):\n        return c(X).squeeze(dim=-1)\n\ngp_constructor = StandardModelConstructor(\n    mean_modules={\"c\":ConstraintPrior()}\n)\ngenerator = ExpectedImprovementGenerator(\n    vocs=my_vocs, gp_constructor=gp_constructor)\n</pre> class ConstraintPrior(torch.nn.Module):     def forward(self, X):         return c(X).squeeze(dim=-1)  gp_constructor = StandardModelConstructor(     mean_modules={\"c\":ConstraintPrior()} ) generator = ExpectedImprovementGenerator(     vocs=my_vocs, gp_constructor=gp_constructor) <pre>Verifying model name='standard' use_low_noise_prior=True covar_modules={} mean_modules={'c': ConstraintPrior()} trainable_mean_keys=[]\n</pre> In\u00a0[8]: Copied! <pre># view custom model from data\ngenerator.add_data(training_data)\nmodel = generator.train_model()\ntest_x = torch.linspace(0,5, 100)\n\n\nfig,ax = plt.subplots(2,1, sharex=\"all\")\nfig.set_size_inches(6,6)\nwith torch.no_grad():\n    post = model.posterior(test_x.reshape(-1,1,1).double())\n\n    for i in range(post.event_shape[-1]):\n        mean = post.mean[...,i].squeeze()\n        l,u = post.mvn.confidence_region()\n        ax[0].plot(test_x, mean,f\"C{i}\", label=generator.vocs.output_names[i])\n        ax[0].fill_between(test_x, l[...,i].squeeze(), u[...,i].squeeze(), alpha=0.5)\n\n    # plot ground truth\n    ax[0].plot(test_x, y(test_x),'C0--', label=\"y ground truth\")\n    ax[0].plot(test_x, c(test_x),'C1--', label=\"c ground truth\")\n\n    # plot training data\n    ax[0].plot(train_x, train_y,\"C0o\", label=\"y data\")\n    ax[0].plot(train_x, train_c,\"C1o\", label=\"c data\")\n    ax[0].legend()\n\n\n    acq = generator.get_acquisition(model)(test_x.reshape(-1,1,1).double())\n\n    ax[1].plot(test_x, acq, label='Acquisition Function')\n    ax[1].legend()\n</pre> # view custom model from data generator.add_data(training_data) model = generator.train_model() test_x = torch.linspace(0,5, 100)   fig,ax = plt.subplots(2,1, sharex=\"all\") fig.set_size_inches(6,6) with torch.no_grad():     post = model.posterior(test_x.reshape(-1,1,1).double())      for i in range(post.event_shape[-1]):         mean = post.mean[...,i].squeeze()         l,u = post.mvn.confidence_region()         ax[0].plot(test_x, mean,f\"C{i}\", label=generator.vocs.output_names[i])         ax[0].fill_between(test_x, l[...,i].squeeze(), u[...,i].squeeze(), alpha=0.5)      # plot ground truth     ax[0].plot(test_x, y(test_x),'C0--', label=\"y ground truth\")     ax[0].plot(test_x, c(test_x),'C1--', label=\"c ground truth\")      # plot training data     ax[0].plot(train_x, train_y,\"C0o\", label=\"y data\")     ax[0].plot(train_x, train_c,\"C1o\", label=\"c data\")     ax[0].legend()       acq = generator.get_acquisition(model)(test_x.reshape(-1,1,1).double())      ax[1].plot(test_x, acq, label='Acquisition Function')     ax[1].legend() In\u00a0[9]: Copied! <pre>model\n</pre> model Out[9]: <pre>ModelListGP(\n  (models): ModuleList(\n    (0): SingleTaskGP(\n      (likelihood): GaussianLikelihood(\n        (noise_covar): HomoskedasticNoise(\n          (noise_prior): GammaPrior()\n          (raw_noise_constraint): GreaterThan(1.000E-04)\n        )\n      )\n      (mean_module): ConstantMean()\n      (covar_module): ScaleKernel(\n        (base_kernel): MaternKernel(\n          (lengthscale_prior): GammaPrior()\n          (raw_lengthscale_constraint): Positive()\n        )\n        (outputscale_prior): GammaPrior()\n        (raw_outputscale_constraint): Positive()\n      )\n      (outcome_transform): Standardize()\n      (input_transform): Normalize()\n    )\n    (1): SingleTaskGP(\n      (likelihood): GaussianLikelihood(\n        (noise_covar): HomoskedasticNoise(\n          (noise_prior): GammaPrior()\n          (raw_noise_constraint): GreaterThan(1.000E-04)\n        )\n      )\n      (mean_module): CustomMean(\n        (_model): ConstraintPrior()\n        (input_transformer): Normalize()\n        (outcome_transformer): Standardize()\n      )\n      (covar_module): ScaleKernel(\n        (base_kernel): MaternKernel(\n          (lengthscale_prior): GammaPrior()\n          (raw_lengthscale_constraint): Positive()\n        )\n        (outputscale_prior): GammaPrior()\n        (raw_outputscale_constraint): Positive()\n      )\n      (outcome_transform): Standardize()\n      (input_transform): Normalize()\n    )\n  )\n  (likelihood): LikelihoodList(\n    (likelihoods): ModuleList(\n      (0-1): 2 x GaussianLikelihood(\n        (noise_covar): HomoskedasticNoise(\n          (noise_prior): GammaPrior()\n          (raw_noise_constraint): GreaterThan(1.000E-04)\n        )\n      )\n    )\n  )\n)</pre> In\u00a0[10]: Copied! <pre>list(model.named_parameters())\n</pre> list(model.named_parameters()) Out[10]: <pre>[('models.0.likelihood.noise_covar.raw_noise',\n  Parameter containing:\n  tensor([-23.1611], dtype=torch.float64, requires_grad=True)),\n ('models.0.mean_module.raw_constant',\n  Parameter containing:\n  tensor(-0.2223, dtype=torch.float64, requires_grad=True)),\n ('models.0.covar_module.raw_outputscale',\n  Parameter containing:\n  tensor(3.0724, dtype=torch.float64, requires_grad=True)),\n ('models.0.covar_module.base_kernel.raw_lengthscale',\n  Parameter containing:\n  tensor([[-0.7308]], dtype=torch.float64, requires_grad=True)),\n ('models.1.likelihood.noise_covar.raw_noise',\n  Parameter containing:\n  tensor([-23.2184], dtype=torch.float64, requires_grad=True)),\n ('models.1.covar_module.raw_outputscale',\n  Parameter containing:\n  tensor(-6.7635, dtype=torch.float64, requires_grad=True)),\n ('models.1.covar_module.base_kernel.raw_lengthscale',\n  Parameter containing:\n  tensor([[-0.5597]], dtype=torch.float64, requires_grad=True))]</pre> In\u00a0[10]: Copied! <pre>\n</pre>"},{"location":"examples/single_objective_bayes_opt/custom_model/#custom-gp-modeling-for-bo","title":"Custom GP modeling for BO\u00b6","text":""},{"location":"examples/single_objective_bayes_opt/custom_model/#custom-kernel-definition","title":"Custom kernel definition\u00b6","text":"<p>In this example we know that the target optimization function is periodic, so it makes sense to use a periodic kernel for the GP model with no noise. Here we define a function to create that model.</p>"},{"location":"examples/single_objective_bayes_opt/custom_model/#custom-prior-mean-function","title":"Custom prior mean function\u00b6","text":"<p>Here we assume we have some knowledge of the ground truth function, which we can take advantage of to speed up optimization. This \"prior mean\" function is specified by a pytorch module.</p>"},{"location":"examples/single_objective_bayes_opt/fixed_features/","title":"Bayesian optimization with fixed features","text":"In\u00a0[1]: Copied! <pre># set values if testing\nimport os\nSMOKE_TEST = os.environ.get(\"SMOKE_TEST\")\nNUM_MC_SAMPLES = 1 if SMOKE_TEST else 128\nNUM_RESTARTS = 1 if SMOKE_TEST else 20\n\n# Ignore all warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nfrom xopt import Xopt, Evaluator\nfrom xopt.generators.bayesian import UpperConfidenceBoundGenerator\nfrom xopt.resources.test_functions.rosenbrock import evaluate_rosenbrock,make_rosenbrock_vocs\n\n# make rosenbrock function vocs in 2D\nvocs = make_rosenbrock_vocs(2)\n\n# define a fixed value for the BO generator\nfixed_features = {\"x0\":-1.0}\ngenerator = UpperConfidenceBoundGenerator(\n    vocs=vocs, fixed_features=fixed_features\n)\ngenerator.numerical_optimizer.n_restarts = NUM_RESTARTS\ngenerator.n_monte_carlo_samples = NUM_MC_SAMPLES\n\nevaluator = Evaluator(function=evaluate_rosenbrock)\n\nX = Xopt(generator=generator, evaluator=evaluator, vocs=vocs)\nX\n</pre> # set values if testing import os SMOKE_TEST = os.environ.get(\"SMOKE_TEST\") NUM_MC_SAMPLES = 1 if SMOKE_TEST else 128 NUM_RESTARTS = 1 if SMOKE_TEST else 20  # Ignore all warnings import warnings warnings.filterwarnings(\"ignore\")  from xopt import Xopt, Evaluator from xopt.generators.bayesian import UpperConfidenceBoundGenerator from xopt.resources.test_functions.rosenbrock import evaluate_rosenbrock,make_rosenbrock_vocs  # make rosenbrock function vocs in 2D vocs = make_rosenbrock_vocs(2)  # define a fixed value for the BO generator fixed_features = {\"x0\":-1.0} generator = UpperConfidenceBoundGenerator(     vocs=vocs, fixed_features=fixed_features ) generator.numerical_optimizer.n_restarts = NUM_RESTARTS generator.n_monte_carlo_samples = NUM_MC_SAMPLES  evaluator = Evaluator(function=evaluate_rosenbrock)  X = Xopt(generator=generator, evaluator=evaluator, vocs=vocs) X Out[1]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: xopt.resources.test_functions.rosenbrock.evaluate_rosenbrock\n  function_kwargs:\n    dummy: 1\n    label: y\n  max_workers: 1\n  vectorized: false\ngenerator:\n  beta: 2.0\n  computation_time: null\n  fixed_features:\n    x0: -1.0\n  gp_constructor:\n    covar_modules: {}\n    mean_modules: {}\n    name: standard\n    trainable_mean_keys: []\n    use_low_noise_prior: true\n  max_travel_distances: null\n  model: null\n  n_candidates: 1\n  n_monte_carlo_samples: 128\n  name: upper_confidence_bound\n  numerical_optimizer:\n    max_iter: 2000\n    n_raw_samples: 20\n    n_restarts: 20\n    name: LBFGS\n  turbo_controller: null\n  use_cuda: false\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants: {}\n  constraints: {}\n  objectives:\n    y: MINIMIZE\n  observables: []\n  variables:\n    x0:\n    - -2.0\n    - 2.0\n    x1:\n    - -2.0\n    - 2.0\n</pre> In\u00a0[2]: Copied! <pre>X.random_evaluate(10)\n</pre> X.random_evaluate(10) Out[2]: x0 x1 y xopt_runtime xopt_error 0 0.400239 1.826686 278.080425 0.000018 False 1 -1.931571 0.955717 778.794842 0.000006 False 2 1.227998 0.648671 73.892780 0.000004 False 3 1.608743 1.553291 107.444180 0.000009 False 4 -1.499950 -1.670724 1543.339701 0.000004 False 5 1.260623 -1.892431 1212.222636 0.000003 False 6 -1.387960 1.408377 32.540634 0.000003 False 7 -0.061701 1.441555 207.839075 0.000003 False 8 -0.198629 1.387024 183.031459 0.000003 False 9 -0.588209 1.169718 70.375189 0.000003 False In\u00a0[3]: Copied! <pre>for i in range(5):\n    X.step()\n</pre> for i in range(5):     X.step() In\u00a0[4]: Copied! <pre>X.data\n</pre> X.data Out[4]: x0 x1 y xopt_runtime xopt_error 0 0.400239 1.826686 278.080425 0.000018 False 1 -1.931571 0.955717 778.794842 0.000006 False 2 1.227998 0.648671 73.892780 0.000004 False 3 1.608743 1.553291 107.444180 0.000009 False 4 -1.499950 -1.670724 1543.339701 0.000004 False 5 1.260623 -1.892431 1212.222636 0.000003 False 6 -1.387960 1.408377 32.540634 0.000003 False 7 -0.061701 1.441555 207.839075 0.000003 False 8 -0.198629 1.387024 183.031459 0.000003 False 9 -0.588209 1.169718 70.375189 0.000003 False 11 -1.000000 2.000000 104.000000 0.000014 False 12 -1.000000 1.484229 27.447800 0.000014 False 13 -1.000000 1.204465 8.180597 0.000015 False 14 -1.000000 0.876819 5.517345 0.000015 False 15 -1.000000 1.032047 4.102700 0.000015 False In\u00a0[5]: Copied! <pre>from matplotlib import pyplot as plt  # plot model predictions\nimport torch\ndata = X.data\n\nbounds = X.generator.vocs.bounds\nmodel = X.generator.train_model(generator.data)\n\n# create mesh\nn = 100\nx = torch.linspace(*bounds.T[0], n)\ny = torch.linspace(*bounds.T[1], n)\nxx, yy = torch.meshgrid(x, y)\npts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()\n\nxx,yy = xx.numpy(), yy.numpy()\n\noutputs = generator.vocs.output_names\nwith torch.no_grad():\n    post = model.posterior(pts)\n\n    for i in range(len(vocs.output_names)):\n        mean = post.mean[...,i]\n        fig, ax = plt.subplots()\n        ax.plot(*data[[\"x0\", \"x1\"]].to_numpy()[:10].T, \"+C1\",\n                label=\"random samples\",\n                zorder=10\n                )\n        ax.plot(*data[[\"x0\", \"x1\"]].to_numpy()[10:].T, \"+C3\",\n                label=\"GP samples\",\n                zorder=10)\n\n\n        c = ax.pcolor(\n            xx, yy, mean.squeeze().reshape(n, n)\n        )\n        fig.colorbar(c)\n        ax.set_title(f\"Posterior mean: {outputs[i]}\")\n        ax.axvline(-1.0,ls=\"--\")\n        ax.set_xlabel(\"x0\")\n        ax.set_ylabel(\"x1\")\n        ax.legend()\n</pre> from matplotlib import pyplot as plt  # plot model predictions import torch data = X.data  bounds = X.generator.vocs.bounds model = X.generator.train_model(generator.data)  # create mesh n = 100 x = torch.linspace(*bounds.T[0], n) y = torch.linspace(*bounds.T[1], n) xx, yy = torch.meshgrid(x, y) pts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()  xx,yy = xx.numpy(), yy.numpy()  outputs = generator.vocs.output_names with torch.no_grad():     post = model.posterior(pts)      for i in range(len(vocs.output_names)):         mean = post.mean[...,i]         fig, ax = plt.subplots()         ax.plot(*data[[\"x0\", \"x1\"]].to_numpy()[:10].T, \"+C1\",                 label=\"random samples\",                 zorder=10                 )         ax.plot(*data[[\"x0\", \"x1\"]].to_numpy()[10:].T, \"+C3\",                 label=\"GP samples\",                 zorder=10)           c = ax.pcolor(             xx, yy, mean.squeeze().reshape(n, n)         )         fig.colorbar(c)         ax.set_title(f\"Posterior mean: {outputs[i]}\")         ax.axvline(-1.0,ls=\"--\")         ax.set_xlabel(\"x0\")         ax.set_ylabel(\"x1\")         ax.legend() In\u00a0[5]: Copied! <pre>\n</pre>"},{"location":"examples/single_objective_bayes_opt/fixed_features/#bayesian-optimization-with-fixed-features","title":"Bayesian optimization with fixed features\u00b6","text":"<p>In some contexts a variable/feature needs to be fixed during optimization. However, we can leverage previous measurements near the fixed variable value to potentially jump-start optimization using observed model covariances established by the GP kernel . In this example, we start with a number of random observations in 2D input space and then proceed with BO at a fixed value for one of the variables. This notebook uses the 2D Rosenbrock test function as an example.</p>"},{"location":"examples/single_objective_bayes_opt/fixed_features/#generate-some-initial-random-samples-in-2d-space","title":"Generate some initial random samples in 2D space\u00b6","text":""},{"location":"examples/single_objective_bayes_opt/fixed_features/#run-bo-steps-with-fixed-features","title":"Run BO steps with fixed features\u00b6","text":""},{"location":"examples/single_objective_bayes_opt/fixed_features/#visualize-model-and-evaluations","title":"Visualize model and evaluations\u00b6","text":"<p>Note that for the BO samples, they all are on the line $x_0=-1$</p>"},{"location":"examples/single_objective_bayes_opt/heteroskedastic_noise_tutorial/","title":"Heteroskedastic modeling","text":"In\u00a0[1]: Copied! <pre>from xopt.vocs import VOCS\nimport math\n\n# define variables and function objectives\nvocs = VOCS(\n    variables={\"x\": [0, 2 * math.pi]},\n    objectives={\"f\": \"MINIMIZE\"},\n)\n</pre> from xopt.vocs import VOCS import math  # define variables and function objectives vocs = VOCS(     variables={\"x\": [0, 2 * math.pi]},     objectives={\"f\": \"MINIMIZE\"}, ) In\u00a0[2]: Copied! <pre># define a test function to optimize\n# the test function also returns an estimation of the variance, which is\n# used to create a Heteroskedastic noise model for the gp\nimport numpy as np\n\ndef sin_function(input_dict):\n    return {\"f\": np.sin(input_dict[\"x\"]), \"f_var\":0.001*input_dict[\"x\"]}\n</pre> # define a test function to optimize # the test function also returns an estimation of the variance, which is # used to create a Heteroskedastic noise model for the gp import numpy as np  def sin_function(input_dict):     return {\"f\": np.sin(input_dict[\"x\"]), \"f_var\":0.001*input_dict[\"x\"]} In\u00a0[3]: Copied! <pre>from xopt.evaluator import Evaluator\nfrom xopt.generators.bayesian import UpperConfidenceBoundGenerator\nfrom xopt import Xopt\n\nevaluator = Evaluator(function=sin_function)\ngenerator = UpperConfidenceBoundGenerator(vocs=vocs)\nX = Xopt(evaluator=evaluator, generator=generator, vocs=vocs)\n</pre> from xopt.evaluator import Evaluator from xopt.generators.bayesian import UpperConfidenceBoundGenerator from xopt import Xopt  evaluator = Evaluator(function=sin_function) generator = UpperConfidenceBoundGenerator(vocs=vocs) X = Xopt(evaluator=evaluator, generator=generator, vocs=vocs) In\u00a0[4]: Copied! <pre># call X.random_evaluate() to generate + evaluate 3 initial points\nX.random_evaluate(4)\n\n# inspect the gathered data\nX.data\n</pre> # call X.random_evaluate() to generate + evaluate 3 initial points X.random_evaluate(4)  # inspect the gathered data X.data Out[4]: x f f_var xopt_runtime xopt_error 0 4.150040 -0.846005 0.004150 0.000025 False 1 1.824985 0.967868 0.001825 0.000003 False 2 4.197086 -0.870144 0.004197 0.000002 False 3 0.234709 0.232560 0.000235 0.000002 False In\u00a0[5]: Copied! <pre>import torch\nimport matplotlib.pyplot as plt\n\nn_steps = 5\n\n# test points for plotting\ntest_x = torch.linspace(*X.vocs.bounds.flatten(), 50).double()\n\nfor i in range(n_steps):\n    # get the Gaussian process model from the generator\n\n    model = X.generator.train_model()\n\n    # get acquisition function from generator\n    acq = X.generator.get_acquisition(model)\n\n    # calculate model posterior and acquisition function at each test point\n    # NOTE: need to add a dimension to the input tensor for evaluating the\n    # posterior and another for the acquisition function, see\n    # https://botorch.org/docs/batching for details\n    # NOTE: we use the `torch.no_grad()` environment to speed up computation by\n    # skipping calculations for backpropagation\n    with torch.no_grad():\n        posterior = model.posterior(test_x.unsqueeze(1))\n        acq_val = acq(test_x.reshape(-1, 1, 1))\n\n    # get mean function and confidence regions\n    mean = posterior.mean\n    l,u = posterior.mvn.confidence_region()\n\n    # plot model and acquisition function\n    fig,ax = plt.subplots(2, 1, sharex=\"all\")\n\n    # plot model posterior\n    ax[0].plot(test_x, mean, label=\"Posterior mean\")\n    ax[0].fill_between(test_x, l, u, alpha=0.25, label=\"Posterior confidence region\")\n\n    # add data to model plot\n    ax[0].plot(X.data[\"x\"],X.data[\"f\"],\"C1o\", label=\"Training data\")\n\n    # plot true function\n    true_f = sin_function({\"x\": test_x})[\"f\"]\n    ax[0].plot(test_x, true_f,'--', label=\"Ground truth\")\n\n    # add legend\n    #ax[0].legend()\n\n    # plot acquisition function\n    ax[1].plot(test_x, acq_val.flatten())\n\n    ax[0].set_ylabel(\"f\")\n    ax[1].set_ylabel(r\"$\\alpha(x)$\")\n    ax[1].set_xlabel(\"x\")\n\n    # do the optimization step\n    X.step()\n</pre> import torch import matplotlib.pyplot as plt  n_steps = 5  # test points for plotting test_x = torch.linspace(*X.vocs.bounds.flatten(), 50).double()  for i in range(n_steps):     # get the Gaussian process model from the generator      model = X.generator.train_model()      # get acquisition function from generator     acq = X.generator.get_acquisition(model)      # calculate model posterior and acquisition function at each test point     # NOTE: need to add a dimension to the input tensor for evaluating the     # posterior and another for the acquisition function, see     # https://botorch.org/docs/batching for details     # NOTE: we use the `torch.no_grad()` environment to speed up computation by     # skipping calculations for backpropagation     with torch.no_grad():         posterior = model.posterior(test_x.unsqueeze(1))         acq_val = acq(test_x.reshape(-1, 1, 1))      # get mean function and confidence regions     mean = posterior.mean     l,u = posterior.mvn.confidence_region()      # plot model and acquisition function     fig,ax = plt.subplots(2, 1, sharex=\"all\")      # plot model posterior     ax[0].plot(test_x, mean, label=\"Posterior mean\")     ax[0].fill_between(test_x, l, u, alpha=0.25, label=\"Posterior confidence region\")      # add data to model plot     ax[0].plot(X.data[\"x\"],X.data[\"f\"],\"C1o\", label=\"Training data\")      # plot true function     true_f = sin_function({\"x\": test_x})[\"f\"]     ax[0].plot(test_x, true_f,'--', label=\"Ground truth\")      # add legend     #ax[0].legend()      # plot acquisition function     ax[1].plot(test_x, acq_val.flatten())      ax[0].set_ylabel(\"f\")     ax[1].set_ylabel(r\"$\\alpha(x)$\")     ax[1].set_xlabel(\"x\")      # do the optimization step     X.step()  <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> In\u00a0[6]: Copied! <pre># access the collected data\nX.data\n</pre> # access the collected data X.data Out[6]: x f f_var xopt_runtime xopt_error 0 4.150040 -8.460052e-01 0.004150 0.000025 False 1 1.824985 9.678676e-01 0.001825 0.000003 False 2 4.197086 -8.701435e-01 0.004197 0.000002 False 3 0.234709 2.325596e-01 0.000235 0.000002 False 5 6.283185 -2.449294e-16 0.006283 0.000014 False 6 4.870610 -9.875091e-01 0.004871 0.000013 False 7 4.650327 -9.980748e-01 0.004650 0.000013 False 8 4.691946 -9.997911e-01 0.004692 0.000013 False 9 4.688337 -9.997108e-01 0.004688 0.000013 False In\u00a0[7]: Copied! <pre>X.generator.get_optimum()\n</pre> X.generator.get_optimum() Out[7]: x 0 4.67226 In\u00a0[8]: Copied! <pre>X.generator.dict()\n</pre> X.generator.dict() Out[8]: <pre>{'model': ModelListGP(\n   (models): ModuleList(\n     (0): XoptHeteroskedasticSingleTaskGP(\n       (likelihood): _GaussianLikelihoodBase(\n         (noise_covar): HeteroskedasticNoise(\n           (noise_model): SingleTaskGP(\n             (likelihood): GaussianLikelihood(\n               (noise_covar): HomoskedasticNoise(\n                 (noise_prior): SmoothedBoxPrior()\n                 (raw_noise_constraint): GreaterThan(1.000E-04)\n               )\n             )\n             (mean_module): ConstantMean()\n             (covar_module): ScaleKernel(\n               (base_kernel): MaternKernel(\n                 (lengthscale_prior): GammaPrior()\n                 (raw_lengthscale_constraint): Positive()\n               )\n               (outputscale_prior): GammaPrior()\n               (raw_outputscale_constraint): Positive()\n             )\n             (outcome_transform): Log()\n             (input_transform): Normalize()\n           )\n           (_noise_constraint): GreaterThan(1.000E-04)\n         )\n       )\n       (mean_module): ConstantMean()\n       (covar_module): ScaleKernel(\n         (base_kernel): MaternKernel(\n           (lengthscale_prior): GammaPrior()\n           (raw_lengthscale_constraint): Positive()\n         )\n         (outputscale_prior): GammaPrior()\n         (raw_outputscale_constraint): Positive()\n       )\n       (input_transform): Normalize()\n       (outcome_transform): Standardize()\n     )\n   )\n   (likelihood): LikelihoodList(\n     (likelihoods): ModuleList(\n       (0): _GaussianLikelihoodBase(\n         (noise_covar): HeteroskedasticNoise(\n           (noise_model): SingleTaskGP(\n             (likelihood): GaussianLikelihood(\n               (noise_covar): HomoskedasticNoise(\n                 (noise_prior): SmoothedBoxPrior()\n                 (raw_noise_constraint): GreaterThan(1.000E-04)\n               )\n             )\n             (mean_module): ConstantMean()\n             (covar_module): ScaleKernel(\n               (base_kernel): MaternKernel(\n                 (lengthscale_prior): GammaPrior()\n                 (raw_lengthscale_constraint): Positive()\n               )\n               (outputscale_prior): GammaPrior()\n               (raw_outputscale_constraint): Positive()\n             )\n             (outcome_transform): Log()\n             (input_transform): Normalize()\n           )\n           (_noise_constraint): GreaterThan(1.000E-04)\n         )\n       )\n     )\n   )\n ),\n 'n_monte_carlo_samples': 128,\n 'turbo_controller': None,\n 'use_cuda': False,\n 'gp_constructor': {'name': 'standard',\n  'use_low_noise_prior': True,\n  'covar_modules': {},\n  'mean_modules': {},\n  'trainable_mean_keys': []},\n 'numerical_optimizer': {'name': 'LBFGS',\n  'n_raw_samples': 20,\n  'n_restarts': 20,\n  'max_iter': 2000},\n 'max_travel_distances': None,\n 'fixed_features': None,\n 'computation_time':    training  acquisition_optimization\n 0  0.525076                  0.050468\n 1  0.440514                  0.039988\n 2  0.590823                  0.049868\n 3  0.653819                  0.049470\n 4  0.662924                  0.049078,\n 'n_candidates': 1,\n 'beta': 2.0}</pre> In\u00a0[8]: Copied! <pre>\n</pre>"},{"location":"examples/single_objective_bayes_opt/heteroskedastic_noise_tutorial/#bayesian-optimization-with-heteroskedastic-noise-gp-modeling","title":"Bayesian Optimization with Heteroskedastic Noise GP Modeling\u00b6","text":"<p>In this tutorial we demonstrate the use of Xopt to preform Bayesian Optimization on a simple test problem. The problem exibits non-uniform (heteroskedastic) noise which we account for in the GP model. This requires explicit specification of the measurement variance.</p>"},{"location":"examples/single_objective_bayes_opt/heteroskedastic_noise_tutorial/#define-the-test-problem","title":"Define the test problem\u00b6","text":"<p>Here we define a simple optimization problem, where we attempt to minimize the sin function in the domian [0,2*pi]. Note that the function used to evaluate the objective function takes a dictionary as input and returns a dictionary as the output.</p>"},{"location":"examples/single_objective_bayes_opt/heteroskedastic_noise_tutorial/#specifying-measurement-variance","title":"Specifying measurement variance\u00b6","text":"<p>We specify variance in the objective function by appending <code>_var</code> to it. This info will collected by the model constructor to make a heteroskedastic model.</p>"},{"location":"examples/single_objective_bayes_opt/heteroskedastic_noise_tutorial/#create-xopt-objects","title":"Create Xopt objects\u00b6","text":"<p>Create the evaluator to evaluate our test function and create a generator that uses the Upper Confidence Bound acquisition function to perform Bayesian Optimization.</p>"},{"location":"examples/single_objective_bayes_opt/heteroskedastic_noise_tutorial/#generate-and-evaluate-initial-points","title":"Generate and evaluate initial points\u00b6","text":"<p>To begin optimization, we must generate some random initial data points. The first call to <code>X.step()</code> will generate and evaluate a number of randomly points specified by the generator. Note that if we add data to xopt before calling <code>X.step()</code> by assigning the data to <code>X.data</code>, calls to <code>X.step()</code> will ignore the random generation and proceed to generating points via Bayesian optimization.</p>"},{"location":"examples/single_objective_bayes_opt/heteroskedastic_noise_tutorial/#do-bayesian-optimization-steps","title":"Do bayesian optimization steps\u00b6","text":"<p>To perform optimization we simply call <code>X.step()</code> in a loop. This allows us to do intermediate tasks in between optimization steps, such as examining the model and acquisition function at each step (as we demonstrate here).</p>"},{"location":"examples/single_objective_bayes_opt/heteroskedastic_noise_tutorial/#getting-the-optimization-result","title":"Getting the optimization result\u00b6","text":"<p>To get the best point (without evaluating it) we ask the generator to predict the optimum based on the posterior mean.</p>"},{"location":"examples/single_objective_bayes_opt/heteroskedastic_noise_tutorial/#customizing-optimization","title":"Customizing optimization\u00b6","text":"<p>Each generator has a set of options that can be modified to effect optimization behavior</p>"},{"location":"examples/single_objective_bayes_opt/multi_fidelity_simple/","title":"Multi-fidelity BO","text":"In\u00a0[1]: Copied! <pre># set values if testing\nimport os\nSMOKE_TEST = os.environ.get(\"SMOKE_TEST\")\nN_MC_SAMPLES = 1 if SMOKE_TEST else 128\nN_RESTARTS = 1 if SMOKE_TEST else 20\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\n\nimport pandas as pd\nimport torch\n\ndef test_function(input_dict):\n    x = input_dict[\"x\"]\n    s = input_dict[\"s\"]\n    return {\"f\":np.sin(x + (1.0 - s)) * np.exp((-s+1)/2)}\n\n\n# define vocs\nfrom xopt import VOCS\nvocs = VOCS(\n    variables={\n        \"x\": [0, 2*math.pi],\n    },\n    objectives={\"f\": \"MINIMIZE\"},\n)\n</pre> # set values if testing import os SMOKE_TEST = os.environ.get(\"SMOKE_TEST\") N_MC_SAMPLES = 1 if SMOKE_TEST else 128 N_RESTARTS = 1 if SMOKE_TEST else 20  import matplotlib.pyplot as plt import numpy as np import math  import pandas as pd import torch  def test_function(input_dict):     x = input_dict[\"x\"]     s = input_dict[\"s\"]     return {\"f\":np.sin(x + (1.0 - s)) * np.exp((-s+1)/2)}   # define vocs from xopt import VOCS vocs = VOCS(     variables={         \"x\": [0, 2*math.pi],     },     objectives={\"f\": \"MINIMIZE\"}, ) In\u00a0[2]: Copied! <pre>test_x = np.linspace(*vocs.bounds, 1000)\nfidelities = [0.0,0.5,1.0]\n\nfig,ax = plt.subplots()\nfor ele in fidelities:\n    f = test_function({\"x\":test_x, \"s\":ele})[\"f\"]\n    ax.plot(test_x, f,label=f\"s:{ele}\")\n\nax.legend()\n</pre> test_x = np.linspace(*vocs.bounds, 1000) fidelities = [0.0,0.5,1.0]  fig,ax = plt.subplots() for ele in fidelities:     f = test_function({\"x\":test_x, \"s\":ele})[\"f\"]     ax.plot(test_x, f,label=f\"s:{ele}\")  ax.legend() Out[2]: <pre>&lt;matplotlib.legend.Legend at 0x7f8d8161d370&gt;</pre> In\u00a0[3]: Copied! <pre># create xopt object\nfrom xopt.generators.bayesian import MultiFidelityGenerator\nfrom xopt import Evaluator, Xopt\n\n# get and modify default generator options\ngenerator = MultiFidelityGenerator(vocs=vocs)\n\n# specify a custom cost function based on the fidelity parameter\ngenerator.cost_function = lambda s: s + 0.001\n\ngenerator.numerical_optimizer.n_restarts = N_RESTARTS\ngenerator.n_monte_carlo_samples = N_MC_SAMPLES\n\n# pass options to the generator\nevaluator = Evaluator(function=test_function)\n\nX = Xopt(vocs=vocs, generator=generator, evaluator=evaluator)\nX\n</pre> # create xopt object from xopt.generators.bayesian import MultiFidelityGenerator from xopt import Evaluator, Xopt  # get and modify default generator options generator = MultiFidelityGenerator(vocs=vocs)  # specify a custom cost function based on the fidelity parameter generator.cost_function = lambda s: s + 0.001  generator.numerical_optimizer.n_restarts = N_RESTARTS generator.n_monte_carlo_samples = N_MC_SAMPLES  # pass options to the generator evaluator = Evaluator(function=test_function)  X = Xopt(vocs=vocs, generator=generator, evaluator=evaluator) X Out[3]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: __main__.test_function\n  function_kwargs: {}\n  max_workers: 1\n  vectorized: false\ngenerator:\n  computation_time: null\n  cost_function: __main__.&lt;lambda&gt;\n  fidelity_parameter: s\n  fixed_features: null\n  gp_constructor:\n    covar_modules: {}\n    mean_modules: {}\n    name: standard\n    trainable_mean_keys: []\n    use_low_noise_prior: true\n  max_travel_distances: null\n  model: null\n  n_candidates: 1\n  n_monte_carlo_samples: 128\n  name: multi_fidelity\n  numerical_optimizer:\n    max_iter: 2000\n    n_raw_samples: 20\n    n_restarts: 20\n    name: LBFGS\n  reference_point:\n    f: 100.0\n    s: 0.0\n  turbo_controller: null\n  use_cuda: false\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants: {}\n  constraints: {}\n  objectives:\n    f: MINIMIZE\n    s: MAXIMIZE\n  observables: []\n  variables:\n    s:\n    - 0\n    - 1\n    x:\n    - 0.0\n    - 6.283185307179586\n</pre> In\u00a0[4]: Copied! <pre># evaluate initial points at mixed fidelities to seed optimization\nX.evaluate_data(pd.DataFrame({\n    \"x\":[math.pi / 4, math.pi / 2., math.pi],\"s\":[0.0, 0.25, 0.0]\n}))\n</pre> # evaluate initial points at mixed fidelities to seed optimization X.evaluate_data(pd.DataFrame({     \"x\":[math.pi / 4, math.pi / 2., math.pi],\"s\":[0.0, 0.25, 0.0] })) Out[4]: x s f xopt_runtime xopt_error 0 0.785398 0.00 1.610902 0.000020 False 1 1.570796 0.25 1.064601 0.000003 False 2 3.141593 0.00 -1.387351 0.000003 False In\u00a0[5]: Copied! <pre># get the total cost of previous observations based on the cost function\nX.generator.calculate_total_cost()\n</pre> # get the total cost of previous observations based on the cost function X.generator.calculate_total_cost() Out[5]: <pre>tensor(0.2530, dtype=torch.float64)</pre> In\u00a0[6]: Copied! <pre># run optimization until the cost budget is exhausted\n# we subtract one unit to make sure we don't go over our eval budget\nbudget = 10\nwhile X.generator.calculate_total_cost() &lt; budget - 1:\n    X.step()\n    print(f\"n_samples: {len(X.data)} \"\n          f\"budget used: {X.generator.calculate_total_cost():.4} \"\n          f\"hypervolume: {X.generator.calculate_hypervolume():.4}\")\n</pre> # run optimization until the cost budget is exhausted # we subtract one unit to make sure we don't go over our eval budget budget = 10 while X.generator.calculate_total_cost() &lt; budget - 1:     X.step()     print(f\"n_samples: {len(X.data)} \"           f\"budget used: {X.generator.calculate_total_cost():.4} \"           f\"hypervolume: {X.generator.calculate_hypervolume():.4}\")  <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 4 budget used: 0.6207 hypervolume: 36.52\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 5 budget used: 1.141 hypervolume: 51.67\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 6 budget used: 1.86 hypervolume: 71.19\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 7 budget used: 2.818 hypervolume: 95.24\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 8 budget used: 3.819 hypervolume: 100.0\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 9 budget used: 4.82 hypervolume: 100.0\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 10 budget used: 5.821 hypervolume: 100.9\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 11 budget used: 6.822 hypervolume: 100.9\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 12 budget used: 6.832 hypervolume: 100.9\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 13 budget used: 7.03 hypervolume: 101.0\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 14 budget used: 7.471 hypervolume: 101.1\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 15 budget used: 8.15 hypervolume: 101.2\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> <pre>n_samples: 16 budget used: 9.151 hypervolume: 101.2\n</pre> In\u00a0[7]: Copied! <pre>X.data\n</pre> X.data Out[7]: x s f xopt_runtime xopt_error 0 0.785398 0.000000 1.610902e+00 0.000020 False 1 1.570796 0.250000 1.064601e+00 0.000003 False 2 3.141593 0.000000 -1.387351e+00 0.000003 False 4 2.210171 0.366655 4.030945e-01 0.000018 False 5 1.648344 0.519838 1.078704e+00 0.000019 False 6 1.134972 0.717239 1.138396e+00 0.000018 False 7 0.508818 0.957069 5.355503e-01 0.000019 False 8 0.000000 1.000000 0.000000e+00 0.000017 False 9 6.283185 1.000000 -2.449294e-16 0.000017 False 10 4.240903 1.000000 -8.908944e-01 0.000018 False 11 2.440856 1.000000 6.447812e-01 0.000017 False 12 4.574912 0.009000 -1.078892e+00 0.000018 False 13 3.726954 0.197185 -1.469084e+00 0.000017 False 14 4.012537 0.440159 -1.310078e+00 0.000019 False 15 4.170895 0.678342 -1.146218e+00 0.000018 False 16 5.110722 1.000000 -9.217087e-01 0.000019 False In\u00a0[8]: Copied! <pre># augment the bounds to add the fidelity parameter\nbounds = X.generator.vocs.bounds[::-1]\n\nmodel = X.generator.model\n\n# create mesh\nn = 50\nx = torch.linspace(*bounds.T[0], n)\ny = torch.linspace(*bounds.T[1], n)\nxx, yy = torch.meshgrid(x, y)\npts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()\n\nxx, yy = xx.numpy(), yy.numpy()\n\nacq_func = X.generator.get_acquisition(model)\n\nvariable_names = X.generator.vocs.variable_names\nwith torch.no_grad():\n    print(pts.shape)\n    # get the model posterior\n    post = model.posterior(pts.unsqueeze(-2))\n    f_mean = post.mean[..., 0]\n    s_mean = post.mean[..., 1]\n\n\n    acq_pts = pts.unsqueeze(1)\n    acq = acq_func(acq_pts)\n\n    fig, ax0 = plt.subplots()\n    c = ax0.pcolor(xx, yy, f_mean.reshape(n, n))\n    fig.colorbar(c)\n    ax0.set_title(\"f-Mean prediction\")\n\n    fig, ax1 = plt.subplots()\n    c = ax1.pcolor(xx, yy, s_mean.reshape(n, n))\n    fig.colorbar(c)\n    ax1.set_title(\"s-Mean prediction\")\n\n    fig, ax2 = plt.subplots()\n    c = ax2.pcolor(xx, yy, acq.reshape(n, n), cmap=\"Blues\")\n    fig.colorbar(c)\n    ax2.set_title(\"Acquisition function\")\n\n    X.data.plot(x=variable_names[0], y=variable_names[1],ax=ax2,style=\"oC1\")\n\n    # mark the next observation\n    next_pt = pts[torch.argmax(acq)]\n    ax2.plot(*next_pt,\"*r\",ms=10)\n\n    # mark the optimum at the max fidelity\n    best_loc = [1.0, 1.5*np.pi]\n    ax2.plot(*best_loc, \"*\",c=\"C4\")\n\n    for a in [ax0,ax1,ax2]:\n        a.set_xlabel(variable_names[0])\n        a.set_ylabel(variable_names[1])\n</pre> # augment the bounds to add the fidelity parameter bounds = X.generator.vocs.bounds[::-1]  model = X.generator.model  # create mesh n = 50 x = torch.linspace(*bounds.T[0], n) y = torch.linspace(*bounds.T[1], n) xx, yy = torch.meshgrid(x, y) pts = torch.hstack([ele.reshape(-1, 1) for ele in (xx, yy)]).double()  xx, yy = xx.numpy(), yy.numpy()  acq_func = X.generator.get_acquisition(model)  variable_names = X.generator.vocs.variable_names with torch.no_grad():     print(pts.shape)     # get the model posterior     post = model.posterior(pts.unsqueeze(-2))     f_mean = post.mean[..., 0]     s_mean = post.mean[..., 1]       acq_pts = pts.unsqueeze(1)     acq = acq_func(acq_pts)      fig, ax0 = plt.subplots()     c = ax0.pcolor(xx, yy, f_mean.reshape(n, n))     fig.colorbar(c)     ax0.set_title(\"f-Mean prediction\")      fig, ax1 = plt.subplots()     c = ax1.pcolor(xx, yy, s_mean.reshape(n, n))     fig.colorbar(c)     ax1.set_title(\"s-Mean prediction\")      fig, ax2 = plt.subplots()     c = ax2.pcolor(xx, yy, acq.reshape(n, n), cmap=\"Blues\")     fig.colorbar(c)     ax2.set_title(\"Acquisition function\")      X.data.plot(x=variable_names[0], y=variable_names[1],ax=ax2,style=\"oC1\")      # mark the next observation     next_pt = pts[torch.argmax(acq)]     ax2.plot(*next_pt,\"*r\",ms=10)      # mark the optimum at the max fidelity     best_loc = [1.0, 1.5*np.pi]     ax2.plot(*best_loc, \"*\",c=\"C4\")      for a in [ax0,ax1,ax2]:         a.set_xlabel(variable_names[0])         a.set_ylabel(variable_names[1])  <pre>torch.Size([2500, 2])\n</pre> <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/torch/functional.py:504: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at /home/conda/feedstock_root/build_artifacts/pytorch-recipe_1694493735498/work/aten/src/ATen/native/TensorShape.cpp:3483.)\n  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/linear_operator/utils/cholesky.py:40: NumericalWarning: A not p.d., added jitter of 1.0e-08 to the diagonal\n  warnings.warn(\n</pre> In\u00a0[9]: Copied! <pre>X.data.plot(x=\"f\", y=\"s\", style=\"o-\")\n</pre> X.data.plot(x=\"f\", y=\"s\", style=\"o-\") Out[9]: <pre>&lt;Axes: xlabel='f'&gt;</pre> In\u00a0[10]: Copied! <pre>X.data\n</pre> X.data Out[10]: x s f xopt_runtime xopt_error 0 0.785398 0.000000 1.610902e+00 0.000020 False 1 1.570796 0.250000 1.064601e+00 0.000003 False 2 3.141593 0.000000 -1.387351e+00 0.000003 False 4 2.210171 0.366655 4.030945e-01 0.000018 False 5 1.648344 0.519838 1.078704e+00 0.000019 False 6 1.134972 0.717239 1.138396e+00 0.000018 False 7 0.508818 0.957069 5.355503e-01 0.000019 False 8 0.000000 1.000000 0.000000e+00 0.000017 False 9 6.283185 1.000000 -2.449294e-16 0.000017 False 10 4.240903 1.000000 -8.908944e-01 0.000018 False 11 2.440856 1.000000 6.447812e-01 0.000017 False 12 4.574912 0.009000 -1.078892e+00 0.000018 False 13 3.726954 0.197185 -1.469084e+00 0.000017 False 14 4.012537 0.440159 -1.310078e+00 0.000019 False 15 4.170895 0.678342 -1.146218e+00 0.000018 False 16 5.110722 1.000000 -9.217087e-01 0.000019 False In\u00a0[11]: Copied! <pre># get optimal value at max fidelity, note that the actual maximum is 4.71\nX.generator.get_optimum().to_dict()\n</pre> # get optimal value at max fidelity, note that the actual maximum is 4.71 X.generator.get_optimum().to_dict() Out[11]: <pre>{'x': {0: 4.308110636064192}, 's': {0: 1.0}}</pre>"},{"location":"examples/single_objective_bayes_opt/multi_fidelity_simple/#multi-fidelity-bo","title":"Multi-fidelity BO\u00b6","text":"<p>Here we demonstrate how Multi-Fidelity Bayesian Optimization can be used to reduce the computational cost of optimization by using lower fidelity surrogate models. The goal is to learn functional dependance of the objective on input variables at low fidelities (which are cheap to compute) and use that information to quickly find the best objective value at higher fidelities (which are more expensive to compute). This assumes that there is some learnable correlation between the objective values at different fidelities.</p> <p>Xopt implements the MOMF (https://botorch.org/tutorials/Multi_objective_multi_fidelity_BO) algorithm which can be used to solve both single (this notebook) and multi-objective (see multi-objective BO section) multi-fidelity problems. Under the hood this algorithm attempts to solve a multi-objective optimization problem, where one objective is the function objective and the other is a simple fidelity objective, weighted by the <code>cost_function</code> of evaluating the objective at a given fidelity.</p>"},{"location":"examples/single_objective_bayes_opt/multi_fidelity_simple/#plot-the-test-function-in-input-fidelity-space","title":"plot the test function in input + fidelity space\u00b6","text":""},{"location":"examples/single_objective_bayes_opt/multi_fidelity_simple/#plot-the-model-prediction-and-acquisition-function-inside-the-optimization-space","title":"Plot the model prediction and acquisition function inside the optimization space\u00b6","text":""},{"location":"examples/single_objective_bayes_opt/multi_fidelity_simple/#plot-the-pareto-front","title":"Plot the Pareto front\u00b6","text":""},{"location":"examples/single_objective_bayes_opt/noisy_bo_tutorial/","title":"Noisy bo tutorial","text":"In\u00a0[1]: Copied! <pre>from xopt.vocs import VOCS\nimport math\n\n# define variables and function objectives\nvocs = VOCS(\n    variables={\"x\": [0, 2 * math.pi]},\n    objectives={\"f\": \"MINIMIZE\"},\n)\n</pre> from xopt.vocs import VOCS import math  # define variables and function objectives vocs = VOCS(     variables={\"x\": [0, 2 * math.pi]},     objectives={\"f\": \"MINIMIZE\"}, ) In\u00a0[2]: Copied! <pre># define a test function to optimize\nimport numpy as np\n\ndef sin_function(input_dict):\n    # return multiple noisy measurements\n    return {\"f\": np.sin(input_dict[\"x\"]) + 0.5*np.random.randn(5),\n            \"dummy\": np.random.randn(5)}\n</pre> # define a test function to optimize import numpy as np  def sin_function(input_dict):     # return multiple noisy measurements     return {\"f\": np.sin(input_dict[\"x\"]) + 0.5*np.random.randn(5),             \"dummy\": np.random.randn(5)} In\u00a0[3]: Copied! <pre>from xopt.evaluator import Evaluator\nfrom xopt.generators.bayesian import UpperConfidenceBoundGenerator\nfrom xopt.generators.bayesian.models.standard import StandardModelConstructor\nfrom xopt import Xopt\n\nevaluator = Evaluator(function=sin_function)\ngp_constructor = StandardModelConstructor(use_low_noise_prior=False)\ngenerator = UpperConfidenceBoundGenerator(vocs=vocs, gp_constructor=gp_constructor)\nX = Xopt(evaluator=evaluator, generator=generator, vocs=vocs)\n</pre> from xopt.evaluator import Evaluator from xopt.generators.bayesian import UpperConfidenceBoundGenerator from xopt.generators.bayesian.models.standard import StandardModelConstructor from xopt import Xopt  evaluator = Evaluator(function=sin_function) gp_constructor = StandardModelConstructor(use_low_noise_prior=False) generator = UpperConfidenceBoundGenerator(vocs=vocs, gp_constructor=gp_constructor) X = Xopt(evaluator=evaluator, generator=generator, vocs=vocs) <pre>Verifying model name='standard' use_low_noise_prior=False covar_modules={} mean_modules={} trainable_mean_keys=[]\n</pre> In\u00a0[4]: Copied! <pre># call X.random_evaluate() to generate + evaluate 3 initial points\nX.random_evaluate(2)\n\n# inspect the gathered data\nX.data\n</pre> # call X.random_evaluate() to generate + evaluate 3 initial points X.random_evaluate(2)  # inspect the gathered data X.data Out[4]: x f dummy xopt_runtime xopt_error 0 0.214451 1.626849 0.304271 0.000066 False 1 0.214451 0.449698 -0.564899 0.000066 False 2 0.214451 -0.383451 0.695176 0.000066 False 3 0.214451 0.106787 1.210012 0.000066 False 4 0.214451 -0.373498 0.32631 0.000066 False 5 5.308046 -1.247189 -0.476822 0.000011 False 6 5.308046 -0.292566 -0.257179 0.000011 False 7 5.308046 -0.746116 3.039478 0.000011 False 8 5.308046 -1.830322 1.213876 0.000011 False 9 5.308046 -1.602915 0.084273 0.000011 False In\u00a0[5]: Copied! <pre>import torch\nimport matplotlib.pyplot as plt\n\nn_steps = 5\n\n# test points for plotting\ntest_x = torch.linspace(*X.vocs.bounds.flatten(), 50).double()\n\nfor i in range(n_steps):\n    # get the Gaussian process model from the generator\n    model = X.generator.train_model()\n\n    # get acquisition function from generator\n    acq = X.generator.get_acquisition(model)\n\n    # calculate model posterior and acquisition function at each test point\n    # NOTE: need to add a dimension to the input tensor for evaluating the\n    # posterior and another for the acquisition function, see\n    # https://botorch.org/docs/batching for details\n    # NOTE: we use the `torch.no_grad()` environment to speed up computation by\n    # skipping calculations for backpropagation\n    with torch.no_grad():\n        posterior = model.posterior(test_x.unsqueeze(1))\n        acq_val = acq(test_x.reshape(-1, 1, 1))\n\n    # get mean function and confidence regions\n    mean = posterior.mean\n    l,u = posterior.mvn.confidence_region()\n\n    # plot model and acquisition function\n    fig,ax = plt.subplots(2, 1, sharex=\"all\")\n\n    # plot model posterior\n    ax[0].plot(test_x, mean, label=\"Posterior mean\")\n    ax[0].fill_between(test_x, l, u, alpha=0.25, label=\"Posterior confidence region\")\n\n    # add data to model plot\n    ax[0].plot(X.data[\"x\"], X.data[\"f\"], \"C1+\", label=\"Training data\")\n\n    # plot true function\n    true_f = np.sin(test_x)\n    ax[0].plot(test_x, true_f,'--', label=\"Ground truth\")\n\n    # add legend\n    ax[0].legend()\n\n    # plot acquisition function\n    ax[1].plot(test_x, acq_val.flatten())\n\n    ax[0].set_ylabel(\"f\")\n    ax[1].set_ylabel(r\"$\\alpha(x)$\")\n    ax[1].set_xlabel(\"x\")\n\n    # do the optimization step\n    X.step()\n</pre> import torch import matplotlib.pyplot as plt  n_steps = 5  # test points for plotting test_x = torch.linspace(*X.vocs.bounds.flatten(), 50).double()  for i in range(n_steps):     # get the Gaussian process model from the generator     model = X.generator.train_model()      # get acquisition function from generator     acq = X.generator.get_acquisition(model)      # calculate model posterior and acquisition function at each test point     # NOTE: need to add a dimension to the input tensor for evaluating the     # posterior and another for the acquisition function, see     # https://botorch.org/docs/batching for details     # NOTE: we use the `torch.no_grad()` environment to speed up computation by     # skipping calculations for backpropagation     with torch.no_grad():         posterior = model.posterior(test_x.unsqueeze(1))         acq_val = acq(test_x.reshape(-1, 1, 1))      # get mean function and confidence regions     mean = posterior.mean     l,u = posterior.mvn.confidence_region()      # plot model and acquisition function     fig,ax = plt.subplots(2, 1, sharex=\"all\")      # plot model posterior     ax[0].plot(test_x, mean, label=\"Posterior mean\")     ax[0].fill_between(test_x, l, u, alpha=0.25, label=\"Posterior confidence region\")      # add data to model plot     ax[0].plot(X.data[\"x\"], X.data[\"f\"], \"C1+\", label=\"Training data\")      # plot true function     true_f = np.sin(test_x)     ax[0].plot(test_x, true_f,'--', label=\"Ground truth\")      # add legend     ax[0].legend()      # plot acquisition function     ax[1].plot(test_x, acq_val.flatten())      ax[0].set_ylabel(\"f\")     ax[1].set_ylabel(r\"$\\alpha(x)$\")     ax[1].set_xlabel(\"x\")      # do the optimization step     X.step()  <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> In\u00a0[6]: Copied! <pre># access the collected data\nX.data\n</pre> # access the collected data X.data Out[6]: x f dummy xopt_runtime xopt_error 0 0.214451 1.626849 0.304271 0.000066 False 1 0.214451 0.449698 -0.564899 0.000066 False 2 0.214451 -0.383451 0.695176 0.000066 False 3 0.214451 0.106787 1.210012 0.000066 False 4 0.214451 -0.373498 0.32631 0.000066 False 5 5.308046 -1.247189 -0.476822 0.000011 False 6 5.308046 -0.292566 -0.257179 0.000011 False 7 5.308046 -0.746116 3.039478 0.000011 False 8 5.308046 -1.830322 1.213876 0.000011 False 9 5.308046 -1.602915 0.084273 0.000011 False 11 3.502271 -1.084783 -1.414529 0.000043 False 12 3.502271 -0.70691 -0.371005 0.000043 False 13 3.502271 -0.581137 0.232023 0.000043 False 14 3.502271 -1.330341 -1.271764 0.000043 False 15 3.502271 0.230377 -1.202457 0.000043 False 16 6.283185 0.519817 0.668782 0.000041 False 17 6.283185 -0.606982 1.633106 0.000041 False 18 6.283185 0.02995 -0.225167 0.000041 False 19 6.283185 0.77698 -0.54787 0.000041 False 20 6.283185 0.754514 -0.155157 0.000041 False 21 4.562728 -2.256562 1.705263 0.000041 False 22 4.562728 -1.115614 -0.033446 0.000041 False 23 4.562728 -1.668108 1.143643 0.000041 False 24 4.562728 -1.242323 0.248919 0.000041 False 25 4.562728 -0.866277 -0.53839 0.000041 False 26 4.595410 -0.960578 -0.399143 0.000041 False 27 4.595410 -0.315808 -0.310185 0.000041 False 28 4.595410 -0.2281 -0.977929 0.000041 False 29 4.595410 -0.62124 -1.886638 0.000041 False 30 4.595410 -1.024264 -0.726572 0.000041 False 31 4.826758 -2.078185 -0.370576 0.000043 False 32 4.826758 -0.86396 -0.609736 0.000043 False 33 4.826758 -1.044811 -1.435681 0.000043 False 34 4.826758 -0.616066 0.569688 0.000043 False 35 4.826758 -1.379245 -1.17626 0.000043 False In\u00a0[7]: Copied! <pre>X.generator.get_optimum()\n</pre> X.generator.get_optimum() Out[7]: x 0 4.74055 In\u00a0[8]: Copied! <pre>X.generator.dict()\n</pre> X.generator.dict() <pre>/tmp/ipykernel_3207/1542263183.py:1: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.4/migration/\n  X.generator.dict()\n</pre> Out[8]: <pre>{'model': ModelListGP(\n   (models): ModuleList(\n     (0): SingleTaskGP(\n       (likelihood): GaussianLikelihood(\n         (noise_covar): HomoskedasticNoise(\n           (noise_prior): GammaPrior()\n           (raw_noise_constraint): GreaterThan(1.000E-04)\n         )\n       )\n       (mean_module): ConstantMean()\n       (covar_module): ScaleKernel(\n         (base_kernel): MaternKernel(\n           (lengthscale_prior): GammaPrior()\n           (raw_lengthscale_constraint): Positive()\n         )\n         (outputscale_prior): GammaPrior()\n         (raw_outputscale_constraint): Positive()\n       )\n       (outcome_transform): Standardize()\n       (input_transform): Normalize()\n     )\n   )\n   (likelihood): LikelihoodList(\n     (likelihoods): ModuleList(\n       (0): GaussianLikelihood(\n         (noise_covar): HomoskedasticNoise(\n           (noise_prior): GammaPrior()\n           (raw_noise_constraint): GreaterThan(1.000E-04)\n         )\n       )\n     )\n   )\n ),\n 'n_monte_carlo_samples': 128,\n 'turbo_controller': None,\n 'use_cuda': False,\n 'gp_constructor': {'name': 'standard',\n  'use_low_noise_prior': False,\n  'covar_modules': {},\n  'mean_modules': {},\n  'trainable_mean_keys': []},\n 'numerical_optimizer': {'name': 'LBFGS',\n  'n_raw_samples': 20,\n  'n_restarts': 20,\n  'max_iter': 2000},\n 'max_travel_distances': None,\n 'fixed_features': None,\n 'computation_time':    training  acquisition_optimization\n 0  0.067107                  0.032729\n 1  0.056073                  0.030736\n 2  0.066011                  0.038877\n 3  0.092558                  0.050290\n 4  0.071575                  0.060418,\n 'n_candidates': 1,\n 'beta': 2.0}</pre> In\u00a0[8]: Copied! <pre>\n</pre>"},{"location":"examples/single_objective_bayes_opt/noisy_bo_tutorial/#basic-bayesian-optimization","title":"Basic Bayesian Optimization\u00b6","text":"<p>In this tutorial we demonstrate the use of Xopt to preform Bayesian Optimization on a simple test problem.</p>"},{"location":"examples/single_objective_bayes_opt/noisy_bo_tutorial/#define-the-test-problem","title":"Define the test problem\u00b6","text":"<p>Here we define a simple optimization problem, where we attempt to minimize the sin function in the domian [0,2*pi]. Note that the function used to evaluate the objective function takes a dictionary as input and returns a dictionary as the output.</p>"},{"location":"examples/single_objective_bayes_opt/noisy_bo_tutorial/#create-xopt-objects","title":"Create Xopt objects\u00b6","text":"<p>Create the evaluator to evaluate our test function and create a generator that uses the Upper Confidence Bound acquisition function to perform Bayesian Optimization.</p>"},{"location":"examples/single_objective_bayes_opt/noisy_bo_tutorial/#generate-and-evaluate-initial-points","title":"Generate and evaluate initial points\u00b6","text":"<p>To begin optimization, we must generate some random initial data points. The first call to <code>X.step()</code> will generate and evaluate a number of randomly points specified by the generator. Note that if we add data to xopt before calling <code>X.step()</code> by assigning the data to <code>X.data</code>, calls to <code>X.step()</code> will ignore the random generation and proceed to generating points via Bayesian optimization.</p>"},{"location":"examples/single_objective_bayes_opt/noisy_bo_tutorial/#do-bayesian-optimization-steps","title":"Do bayesian optimization steps\u00b6","text":"<p>To perform optimization we simply call <code>X.step()</code> in a loop. This allows us to do intermediate tasks in between optimization steps, such as examining the model and acquisition function at each step (as we demonstrate here).</p>"},{"location":"examples/single_objective_bayes_opt/noisy_bo_tutorial/#getting-the-optimization-result","title":"Getting the optimization result\u00b6","text":"<p>To get the best point (without evaluating it) we ask the generator to predict the optimum based on the posterior mean.</p>"},{"location":"examples/single_objective_bayes_opt/noisy_bo_tutorial/#customizing-optimization","title":"Customizing optimization\u00b6","text":"<p>Each generator has a set of options that can be modified to effect optimization behavior</p>"},{"location":"examples/single_objective_bayes_opt/time_dependent_bo/","title":"Time dependent upper confidence bound","text":"In\u00a0[1]: Copied! <pre># set values if testing\nimport os\nSMOKE_TEST = os.environ.get(\"SMOKE_TEST\")\nN_MC_SAMPLES = 1 if SMOKE_TEST else 128\nNUM_RESTARTS = 1 if SMOKE_TEST else 20\n\nfrom xopt.generators.bayesian.upper_confidence_bound import TDUpperConfidenceBoundGenerator\nfrom xopt.vocs import VOCS\nfrom xopt.evaluator import Evaluator\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</pre> # set values if testing import os SMOKE_TEST = os.environ.get(\"SMOKE_TEST\") N_MC_SAMPLES = 1 if SMOKE_TEST else 128 NUM_RESTARTS = 1 if SMOKE_TEST else 20  from xopt.generators.bayesian.upper_confidence_bound import TDUpperConfidenceBoundGenerator from xopt.vocs import VOCS from xopt.evaluator import Evaluator import warnings warnings.filterwarnings(\"ignore\") In\u00a0[2]: Copied! <pre># test evaluate function and vocs\nimport time\nfrom xopt import Xopt\n\nstart_time = time.time()\ndef f(inputs):\n    x_ = inputs[\"x\"]\n    current_time = time.time()\n    t_ = current_time - start_time\n    y_ = 5*(x_ - t_*1e-2)**2\n    return {\"y\":y_, \"time\":current_time}\n\nvariables = {\"x\":[-1,1]}\nobjectives = {\"y\": \"MINIMIZE\"}\n\nvocs = VOCS(variables=variables, objectives=objectives)\nprint(vocs)\n\nevaluator = Evaluator(function=f)\ngenerator = TDUpperConfidenceBoundGenerator(vocs=vocs)\ngenerator.added_time=1.0\ngenerator.beta = 2.0\ngenerator.n_monte_carlo_samples = N_MC_SAMPLES\ngenerator.numerical_optimizer.n_restarts = NUM_RESTARTS\n\nX = Xopt(evaluator=evaluator, generator=generator, vocs=vocs)\nX\n</pre> # test evaluate function and vocs import time from xopt import Xopt  start_time = time.time() def f(inputs):     x_ = inputs[\"x\"]     current_time = time.time()     t_ = current_time - start_time     y_ = 5*(x_ - t_*1e-2)**2     return {\"y\":y_, \"time\":current_time}  variables = {\"x\":[-1,1]} objectives = {\"y\": \"MINIMIZE\"}  vocs = VOCS(variables=variables, objectives=objectives) print(vocs)  evaluator = Evaluator(function=f) generator = TDUpperConfidenceBoundGenerator(vocs=vocs) generator.added_time=1.0 generator.beta = 2.0 generator.n_monte_carlo_samples = N_MC_SAMPLES generator.numerical_optimizer.n_restarts = NUM_RESTARTS  X = Xopt(evaluator=evaluator, generator=generator, vocs=vocs) X <pre>variables={'x': [-1.0, 1.0]} constraints={} objectives={'y': 'MINIMIZE'} constants={} observables=[]\n</pre> Out[2]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: __main__.f\n  function_kwargs: {}\n  max_workers: 1\n  vectorized: false\ngenerator:\n  added_time: 1.0\n  beta: 2.0\n  computation_time: null\n  fixed_features: null\n  gp_constructor:\n    covar_modules: {}\n    mean_modules: {}\n    name: time_dependent\n    trainable_mean_keys: []\n    use_low_noise_prior: true\n  max_travel_distances: null\n  model: null\n  n_candidates: 1\n  n_monte_carlo_samples: 128\n  name: time_dependent_upper_confidence_bound\n  numerical_optimizer:\n    max_iter: 2000\n    n_raw_samples: 20\n    n_restarts: 20\n    name: LBFGS\n  target_prediction_time: null\n  turbo_controller: null\n  use_cuda: false\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants: {}\n  constraints: {}\n  objectives:\n    y: MINIMIZE\n  observables: []\n  variables:\n    x:\n    - -1.0\n    - 1.0\n</pre> In\u00a0[3]: Copied! <pre>X.random_evaluate(1)\n\nfor _ in range(20):\n    # note that in this example we can ignore warnings if computation time is greater\n    # than added time\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=RuntimeWarning)\n        X.step()\n        time.sleep(0.1)\n\nprint(X.generator.generate(1))\n</pre> X.random_evaluate(1)  for _ in range(20):     # note that in this example we can ignore warnings if computation time is greater     # than added time     with warnings.catch_warnings():         warnings.filterwarnings(\"ignore\", category=RuntimeWarning)         X.step()         time.sleep(0.1)  print(X.generator.generate(1)) <pre>[{'x': 0.27534447622956354}]\n</pre> In\u00a0[4]: Copied! <pre>X.data\n</pre> X.data Out[4]: x y time xopt_runtime xopt_error 0 -0.4918 1.213218 1.695831e+09 0.000029 False 2 1.0 4.891907 1.695831e+09 0.000008 False 3 -1.0 5.221673 1.695831e+09 0.000008 False 4 -0.096906 0.084351 1.695831e+09 0.000008 False 5 -0.333149 0.711314 1.695831e+09 0.000009 False 6 0.150857 0.045864 1.695831e+09 0.000008 False 7 -0.033764 0.049908 1.695831e+09 0.000009 False 8 0.202509 0.078495 1.695831e+09 0.000007 False 9 0.075079 0.00087 1.695831e+09 0.000007 False 10 0.142245 0.00921 1.695831e+09 0.000007 False 11 0.038911 0.02554 1.695831e+09 0.000008 False 12 0.16503 0.009499 1.695831e+09 0.000008 False 13 0.106978 0.003256 1.695831e+09 0.000007 False 14 0.195373 0.013426 1.695831e+09 0.000008 False 15 0.123236 0.004921 1.695831e+09 0.000007 False 16 0.186864 0.002248 1.695831e+09 0.000007 False 17 0.146433 0.004585 1.695831e+09 0.000008 False 18 0.236725 0.011985 1.695831e+09 0.000008 False 19 0.177489 0.002275 1.695831e+09 0.000009 False 20 0.218536 0.000375 1.695831e+09 0.000008 False 21 0.196186 0.003062 1.695831e+09 0.000008 False In\u00a0[5]: Copied! <pre># plot model\nimport torch\nfrom matplotlib import pyplot as plt  # plot model predictions\ndata = X.data\n\nxbounds = generator.vocs.bounds\ntbounds = [data[\"time\"].min(), data[\"time\"].max()]\n\ndef gt(inpts):\n    return 5*(inpts[:,1] - (inpts[:,0] - start_time)*1e-2)**2\n\nmodel = X.generator.model\nn = 200\nt = torch.linspace(*tbounds, n, dtype=torch.double)\nx = torch.linspace(*xbounds.flatten(), n, dtype=torch.double)\ntt, xx = torch.meshgrid(t, x)\npts = torch.hstack([ele.reshape(-1, 1) for ele in (tt, xx)]).double()\n\ntt, xx = tt.numpy(), xx.numpy()\n\n#NOTE: the model inputs are such that t is the last dimension\ngp_pts = torch.flip(pts, dims=[-1])\n\ngt_vals = gt(pts)\n\nwith torch.no_grad():\n    post = model.posterior(gp_pts)\n\n    mean = post.mean\n    std = torch.sqrt(post.variance)\n\n    fig, ax = plt.subplots()\n    ax.set_title(\"model mean\")\n    ax.set_xlabel(\"unix time\")\n    ax.set_ylabel(\"x\")\n    c = ax.pcolor(tt, xx, mean.reshape(n,n))\n    fig.colorbar(c)\n\n    fig2, ax2 = plt.subplots()\n    ax2.set_title(\"model uncertainty\")\n    ax2.set_xlabel(\"unix time\")\n    ax2.set_ylabel(\"x\")\n    c = ax2.pcolor(tt, xx, std.reshape(n,n))\n    fig2.colorbar(c)\n\n    ax.plot(data[\"time\"].to_numpy(), data[\"x\"].to_numpy(),\"oC1\")\n    ax2.plot(data[\"time\"].to_numpy(), data[\"x\"].to_numpy(),\"oC1\")\n\n    fig3, ax3 = plt.subplots()\n    ax3.set_title(\"ground truth value\")\n    ax3.set_xlabel(\"unix time\")\n    ax3.set_ylabel(\"x\")\n    c = ax3.pcolor(tt, xx, gt_vals.reshape(n,n))\n    fig3.colorbar(c)\n</pre> # plot model import torch from matplotlib import pyplot as plt  # plot model predictions data = X.data  xbounds = generator.vocs.bounds tbounds = [data[\"time\"].min(), data[\"time\"].max()]  def gt(inpts):     return 5*(inpts[:,1] - (inpts[:,0] - start_time)*1e-2)**2  model = X.generator.model n = 200 t = torch.linspace(*tbounds, n, dtype=torch.double) x = torch.linspace(*xbounds.flatten(), n, dtype=torch.double) tt, xx = torch.meshgrid(t, x) pts = torch.hstack([ele.reshape(-1, 1) for ele in (tt, xx)]).double()  tt, xx = tt.numpy(), xx.numpy()  #NOTE: the model inputs are such that t is the last dimension gp_pts = torch.flip(pts, dims=[-1])  gt_vals = gt(pts)  with torch.no_grad():     post = model.posterior(gp_pts)      mean = post.mean     std = torch.sqrt(post.variance)      fig, ax = plt.subplots()     ax.set_title(\"model mean\")     ax.set_xlabel(\"unix time\")     ax.set_ylabel(\"x\")     c = ax.pcolor(tt, xx, mean.reshape(n,n))     fig.colorbar(c)      fig2, ax2 = plt.subplots()     ax2.set_title(\"model uncertainty\")     ax2.set_xlabel(\"unix time\")     ax2.set_ylabel(\"x\")     c = ax2.pcolor(tt, xx, std.reshape(n,n))     fig2.colorbar(c)      ax.plot(data[\"time\"].to_numpy(), data[\"x\"].to_numpy(),\"oC1\")     ax2.plot(data[\"time\"].to_numpy(), data[\"x\"].to_numpy(),\"oC1\")      fig3, ax3 = plt.subplots()     ax3.set_title(\"ground truth value\")     ax3.set_xlabel(\"unix time\")     ax3.set_ylabel(\"x\")     c = ax3.pcolor(tt, xx, gt_vals.reshape(n,n))     fig3.colorbar(c) In\u00a0[6]: Copied! <pre>list(model.named_parameters())\n</pre> list(model.named_parameters()) Out[6]: <pre>[('models.0.likelihood.noise_covar.raw_noise',\n  Parameter containing:\n  tensor([-20.6934], dtype=torch.float64, requires_grad=True)),\n ('models.0.mean_module.raw_constant',\n  Parameter containing:\n  tensor(2.6284, dtype=torch.float64, requires_grad=True)),\n ('models.0.covar_module.raw_outputscale',\n  Parameter containing:\n  tensor(3.0761, dtype=torch.float64, requires_grad=True)),\n ('models.0.covar_module.base_kernel.raw_lengthscale',\n  Parameter containing:\n  tensor([[-0.4226,  1.2917]], dtype=torch.float64, requires_grad=True))]</pre> In\u00a0[7]: Copied! <pre># plot the acquisition function\n# note that target time is only updated during the generate call\ntarget_time = X.generator.target_prediction_time\nprint(target_time-start_time)\nmy_acq_func = X.generator.get_acquisition(model)\n\nwith torch.no_grad():\n    acq_pts = x.unsqueeze(-1).unsqueeze(-1)\n    full_acq = my_acq_func.acq_func(gp_pts.unsqueeze(1))\n    fixed_acq = my_acq_func(acq_pts)\n\n    fig, ax = plt.subplots()\n    c = ax.pcolor(tt, xx, full_acq.reshape(n,n))\n    fig.colorbar(c)\n\n    fi2, ax2 = plt.subplots()\n    ax2.plot(x.flatten(), fixed_acq.flatten())\n</pre> # plot the acquisition function # note that target time is only updated during the generate call target_time = X.generator.target_prediction_time print(target_time-start_time) my_acq_func = X.generator.get_acquisition(model)  with torch.no_grad():     acq_pts = x.unsqueeze(-1).unsqueeze(-1)     full_acq = my_acq_func.acq_func(gp_pts.unsqueeze(1))     fixed_acq = my_acq_func(acq_pts)      fig, ax = plt.subplots()     c = ax.pcolor(tt, xx, full_acq.reshape(n,n))     fig.colorbar(c)      fi2, ax2 = plt.subplots()     ax2.plot(x.flatten(), fixed_acq.flatten()) <pre>23.195855379104614\n</pre> In\u00a0[7]: Copied! <pre>\n</pre>"},{"location":"examples/single_objective_bayes_opt/time_dependent_bo/#time-dependent-bayesian-optimization","title":"Time dependent Bayesian Optimization\u00b6","text":"<p>In this example we demonstrate time dependent optimization. In this case we are not only interested in finding an optimum point in input space, but also maintain the ideal point over time.</p>"},{"location":"examples/single_objective_bayes_opt/time_dependent_bo/#time-dependent-test-problem","title":"Time dependent test problem\u00b6","text":"<p>Optimization is carried out over a single variable <code>x</code>. The test function is a simple quadratic, with a minimum location that drifts in the positive <code>x</code> direction over (real) time.</p>"},{"location":"examples/single_objective_bayes_opt/turbo_tutorial/","title":"TuRBO Bayesian Optimization","text":"In\u00a0[1]: Copied! <pre>from xopt.vocs import VOCS\nimport math\n\n# define variables and function objectives\nvocs = VOCS(\n    variables={\"x\": [0, 2 * math.pi]},\n    objectives={\"f\": \"MINIMIZE\"},\n)\n</pre> from xopt.vocs import VOCS import math  # define variables and function objectives vocs = VOCS(     variables={\"x\": [0, 2 * math.pi]},     objectives={\"f\": \"MINIMIZE\"}, ) In\u00a0[2]: Copied! <pre># define a test function to optimize\nimport numpy as np\n\ndef sin_function(input_dict):\n    x = input_dict[\"x\"]\n    return {\"f\": -10*np.exp(-(x - np.pi)**2 / 0.01) + 0.5*np.sin(5*x)}\n</pre> # define a test function to optimize import numpy as np  def sin_function(input_dict):     x = input_dict[\"x\"]     return {\"f\": -10*np.exp(-(x - np.pi)**2 / 0.01) + 0.5*np.sin(5*x)} In\u00a0[3]: Copied! <pre>from xopt.evaluator import Evaluator\nfrom xopt.generators.bayesian import UpperConfidenceBoundGenerator\nfrom xopt import Xopt\n\n\nevaluator = Evaluator(function=sin_function)\ngenerator = UpperConfidenceBoundGenerator(\n    vocs=vocs, turbo_controller=\"optimize\"\n)\nX = Xopt(evaluator=evaluator, generator=generator, vocs=vocs)\n</pre> from xopt.evaluator import Evaluator from xopt.generators.bayesian import UpperConfidenceBoundGenerator from xopt import Xopt   evaluator = Evaluator(function=sin_function) generator = UpperConfidenceBoundGenerator(     vocs=vocs, turbo_controller=\"optimize\" ) X = Xopt(evaluator=evaluator, generator=generator, vocs=vocs) In\u00a0[4]: Copied! <pre>X\n</pre> X Out[4]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: __main__.sin_function\n  function_kwargs: {}\n  max_workers: 1\n  vectorized: false\ngenerator:\n  beta: 2.0\n  computation_time: null\n  fixed_features: null\n  gp_constructor:\n    covar_modules: {}\n    mean_modules: {}\n    name: standard\n    trainable_mean_keys: []\n    use_low_noise_prior: true\n  max_travel_distances: null\n  model: null\n  n_candidates: 1\n  n_monte_carlo_samples: 128\n  name: upper_confidence_bound\n  numerical_optimizer:\n    max_iter: 2000\n    n_raw_samples: 20\n    n_restarts: 20\n    name: LBFGS\n  turbo_controller:\n    batch_size: 1\n    best_value: null\n    center_x: null\n    dim: 1\n    failure_counter: 0\n    failure_tolerance: 2\n    length: 0.25\n    length_max: 2.0\n    length_min: 0.0078125\n    scale_factor: 2.0\n    success_counter: 0\n    success_tolerance: 2\n    tkwargs:\n      dtype: torch.float64\n  use_cuda: false\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants: {}\n  constraints: {}\n  objectives:\n    f: MINIMIZE\n  observables: []\n  variables:\n    x:\n    - 0.0\n    - 6.283185307179586\n</pre> In\u00a0[5]: Copied! <pre>import pandas as pd\nX.evaluate_data(pd.DataFrame({\"x\":[3.0, 1.75, 2.0]}))\n\n# inspect the gathered data\nX.data\n</pre> import pandas as pd X.evaluate_data(pd.DataFrame({\"x\":[3.0, 1.75, 2.0]}))  # inspect the gathered data X.data Out[5]: x f xopt_runtime xopt_error 0 3.00 -1.021664 0.000035 False 1 1.75 0.312362 0.000006 False 2 2.00 -0.272011 0.000004 False In\u00a0[6]: Copied! <pre># determine trust region from gathered data\nX.generator.train_model()\nX.generator.turbo_controller.update_state(X.generator.data)\nX.generator.turbo_controller.get_trust_region(X.generator.model)\n</pre> # determine trust region from gathered data X.generator.train_model() X.generator.turbo_controller.update_state(X.generator.data) X.generator.turbo_controller.get_trust_region(X.generator.model) <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> Out[6]: <pre>tensor([[2.2146],\n        [3.7854]], dtype=torch.float64)</pre> In\u00a0[7]: Copied! <pre>import torch\nimport matplotlib.pyplot as plt\n\n# test points for plotting\ntest_x = torch.linspace(*X.vocs.bounds.flatten(),500).double()\n\nfor i in range(10):\n\n    # get the Gaussian process model from the generator\n    model = X.generator.train_model()\n\n    # get trust region\n    trust_region = X.generator.turbo_controller.get_trust_region(model)\\\n        .squeeze()\n    scale_factor = X.generator.turbo_controller.length\n    region_width = trust_region[1] - trust_region[0]\n    best_value = X.generator.turbo_controller.best_value\n\n    # get number of successes and failures\n    n_successes = X.generator.turbo_controller.success_counter\n    n_failures = X.generator.turbo_controller.failure_counter\n\n    # get acquisition function from generator\n    acq = X.generator.get_acquisition(model)\n\n    # calculate model posterior and acquisition function at each test point\n    # NOTE: need to add a dimension to the input tensor for evaluating the\n    # posterior and another for the acquisition function, see\n    # https://botorch.org/docs/batching for details\n    # NOTE: we use the `torch.no_grad()` environment to speed up computation by\n    # skipping calculations for backpropagation\n    with torch.no_grad():\n        posterior = model.posterior(test_x.unsqueeze(1))\n        acq_val = acq(test_x.reshape(-1,1,1))\n\n    # get mean function and confidence regions\n    mean = posterior.mean\n    l,u = posterior.mvn.confidence_region()\n\n    # plot model and acquisition function\n    fig,ax = plt.subplots(2,1,sharex=\"all\")\n\n    # add title for successes and failures\n    ax[0].set_title(f\"n_successes: {n_successes}, n_failures: {n_failures}, \"\n                    f\"scale_factor: {scale_factor}, region_width: {region_width:.2}, \"\n                    f\"best_value: {best_value:.4}\")\n\n    # plot model posterior\n    ax[0].plot(test_x, mean, label=\"Posterior mean\")\n    ax[0].fill_between(test_x, l, u,alpha=0.25, label=\"Confidence region\")\n\n    # add data to model plot\n    ax[0].plot(X.data[\"x\"],X.data[\"f\"],\"C1o\", label=\"Training data\")\n\n    # plot true function\n    true_f = sin_function({\"x\": test_x})[\"f\"]\n    ax[0].plot(test_x, true_f,'--', label=\"Ground truth\")\n\n    # add legend\n    ax[0].legend(fontsize=\"x-small\")\n\n    # plot acquisition function\n    ax[1].plot(test_x, acq_val.flatten())\n\n    ax[0].set_ylabel(\"f\")\n    ax[0].set_ylim(-12,10)\n    ax[1].set_ylabel(r\"$\\alpha(x)$\")\n    ax[1].set_xlabel(\"x\")\n\n    # plot trust region\n    for a in ax:\n        a.axvline(trust_region[0],c=\"r\")\n        a.axvline(trust_region[1],c=\"r\")\n\n    fig.tight_layout()\n    X.step()\n</pre> import torch import matplotlib.pyplot as plt  # test points for plotting test_x = torch.linspace(*X.vocs.bounds.flatten(),500).double()  for i in range(10):      # get the Gaussian process model from the generator     model = X.generator.train_model()      # get trust region     trust_region = X.generator.turbo_controller.get_trust_region(model)\\         .squeeze()     scale_factor = X.generator.turbo_controller.length     region_width = trust_region[1] - trust_region[0]     best_value = X.generator.turbo_controller.best_value      # get number of successes and failures     n_successes = X.generator.turbo_controller.success_counter     n_failures = X.generator.turbo_controller.failure_counter      # get acquisition function from generator     acq = X.generator.get_acquisition(model)      # calculate model posterior and acquisition function at each test point     # NOTE: need to add a dimension to the input tensor for evaluating the     # posterior and another for the acquisition function, see     # https://botorch.org/docs/batching for details     # NOTE: we use the `torch.no_grad()` environment to speed up computation by     # skipping calculations for backpropagation     with torch.no_grad():         posterior = model.posterior(test_x.unsqueeze(1))         acq_val = acq(test_x.reshape(-1,1,1))      # get mean function and confidence regions     mean = posterior.mean     l,u = posterior.mvn.confidence_region()      # plot model and acquisition function     fig,ax = plt.subplots(2,1,sharex=\"all\")      # add title for successes and failures     ax[0].set_title(f\"n_successes: {n_successes}, n_failures: {n_failures}, \"                     f\"scale_factor: {scale_factor}, region_width: {region_width:.2}, \"                     f\"best_value: {best_value:.4}\")      # plot model posterior     ax[0].plot(test_x, mean, label=\"Posterior mean\")     ax[0].fill_between(test_x, l, u,alpha=0.25, label=\"Confidence region\")      # add data to model plot     ax[0].plot(X.data[\"x\"],X.data[\"f\"],\"C1o\", label=\"Training data\")      # plot true function     true_f = sin_function({\"x\": test_x})[\"f\"]     ax[0].plot(test_x, true_f,'--', label=\"Ground truth\")      # add legend     ax[0].legend(fontsize=\"x-small\")      # plot acquisition function     ax[1].plot(test_x, acq_val.flatten())      ax[0].set_ylabel(\"f\")     ax[0].set_ylim(-12,10)     ax[1].set_ylabel(r\"$\\alpha(x)$\")     ax[1].set_xlabel(\"x\")      # plot trust region     for a in ax:         a.axvline(trust_region[0],c=\"r\")         a.axvline(trust_region[1],c=\"r\")      fig.tight_layout()     X.step()  <pre>/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n/usr/share/miniconda3/envs/xopt-dev/lib/python3.9/site-packages/xopt/generators/bayesian/models/standard.py:95: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  pd.options.mode.use_inf_as_na = True\n</pre> In\u00a0[8]: Copied! <pre># access the collected data\nX.generator.turbo_controller\n</pre> # access the collected data X.generator.turbo_controller Out[8]: <pre>OptimizeTurboController(vocs=VOCS(variables={'x': [0.0, 6.283185307179586]}, constraints={}, objectives={'f': 'MINIMIZE'}, constants={}, observables=[]), dim=1, batch_size=1, length=0.0625, length_min=0.0078125, length_max=2.0, failure_counter=0, failure_tolerance=2, success_counter=1, success_tolerance=2, center_x={'x': 3.1421060866297044}, scale_factor=2.0, tkwargs={'dtype': torch.float64}, best_value=-10.001019971178005)</pre> In\u00a0[9]: Copied! <pre>X.data\n</pre> X.data Out[9]: x f xopt_runtime xopt_error 0 3.000000 -1.021664 0.000035 False 1 1.750000 0.312362 0.000006 False 2 2.000000 -0.272011 0.000004 False 4 3.392699 -0.493621 0.000021 False 5 2.628506 0.272404 0.000022 False 6 3.141807 -10.000490 0.000022 False 7 3.205877 -6.772979 0.000020 False 8 3.114312 -9.214820 0.000022 False 9 3.149691 -9.954866 0.000021 False 10 3.140919 -9.997863 0.000022 False 11 3.141708 -10.000276 0.000021 False 12 3.142106 -10.001020 0.000021 False 13 3.142392 -10.001360 0.000020 False In\u00a0[10]: Copied! <pre>list(model.named_parameters())\n</pre> list(model.named_parameters()) Out[10]: <pre>[('models.0.likelihood.noise_covar.raw_noise',\n  Parameter containing:\n  tensor([-24.6482], dtype=torch.float64, requires_grad=True)),\n ('models.0.mean_module.raw_constant',\n  Parameter containing:\n  tensor(0.9514, dtype=torch.float64, requires_grad=True)),\n ('models.0.covar_module.raw_outputscale',\n  Parameter containing:\n  tensor(0.5314, dtype=torch.float64, requires_grad=True)),\n ('models.0.covar_module.base_kernel.raw_lengthscale',\n  Parameter containing:\n  tensor([[-3.7730]], dtype=torch.float64, requires_grad=True))]</pre>"},{"location":"examples/single_objective_bayes_opt/turbo_tutorial/#turbo-bayesian-optimization","title":"TuRBO Bayesian Optimization\u00b6","text":"<p>In this tutorial we demonstrate the use of Xopt to preform Trust Region Bayesian Optimization (TuRBO) on a simple test problem. During optimization of high dimensional input spaces off the shelf BO tends to over-emphasize exploration which severely degrades optimization performance. TuRBO attempts to prevent this by maintaining a surrogate model over a local (trust) region centered on the best observation so far and restricting optimization inside that local region. The trust region is expanded and contracted based on the number of <code>successful</code> (observations that improve over the best observed point) or <code>unsuccessful</code> (no improvement) observations in a row. See https://botorch.org/tutorials/turbo_1 for details.</p>"},{"location":"examples/single_objective_bayes_opt/turbo_tutorial/#define-the-test-problem","title":"Define the test problem\u00b6","text":"<p>Here we define a simple optimization problem, where we attempt to minimize a function in the domian [0,2*pi]. Note that the function used to evaluate the objective function takes a dictionary as input and returns a dictionary as the output.</p>"},{"location":"examples/single_objective_bayes_opt/turbo_tutorial/#create-xopt-objects","title":"Create Xopt objects\u00b6","text":"<p>Create the evaluator to evaluate our test function and create a generator that uses the Upper Confidence Bound acquisition function to perform Bayesian Optimization.</p>"},{"location":"examples/single_objective_bayes_opt/turbo_tutorial/#generate-and-evaluate-initial-points","title":"Generate and evaluate initial points\u00b6","text":"<p>To begin optimization, we must generate some random initial data points. The first call to <code>X.step()</code> will generate and evaluate a number of randomly points specified by the generator. Note that if we add data to xopt before calling <code>X.step()</code> by assigning the data to <code>X.data</code>, calls to <code>X.step()</code> will ignore the random generation and proceed to generating points via Bayesian optimization.</p>"},{"location":"examples/single_objective_bayes_opt/turbo_tutorial/#do-bayesian-optimization-steps","title":"Do bayesian optimization steps\u00b6","text":"<p>Notice that when the number of successive successes or failures reaches 2 the trust region expands or contracts and counters are reset to zero. Counters are also reset to zero during alternate successes/failures. Finally, the model is most accurate inside the trust region, which supports our goal of local optimization.</p>"},{"location":"examples/single_objective_bayes_opt/upper_confidence_bound/","title":"Upper Confidence Bound BO","text":"In\u00a0[1]: Copied! <pre># Ignore all warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport torch\n\n\nimport matplotlib.pyplot as plt\nfrom xopt import Xopt\n</pre> # Ignore all warnings import warnings warnings.filterwarnings(\"ignore\")  import torch   import matplotlib.pyplot as plt from xopt import Xopt <p>The <code>Xopt</code> object can be instantiated from a JSON or YAML file, or a dict, with the proper structure.</p> <p>Here we will make one</p> In\u00a0[2]: Copied! <pre># Make a proper input file.\nYAML = \"\"\"\ngenerator:\n  name: upper_confidence_bound\n  beta: 0.1\n\nevaluator:\n  function: xopt.resources.test_functions.sinusoid_1d.evaluate_sinusoid\n\nvocs:\n  variables:\n    x1: [0, 6.28]\n  objectives:\n    y1: 'MINIMIZE'\n\"\"\"\n</pre> # Make a proper input file. YAML = \"\"\" generator:   name: upper_confidence_bound   beta: 0.1  evaluator:   function: xopt.resources.test_functions.sinusoid_1d.evaluate_sinusoid  vocs:   variables:     x1: [0, 6.28]   objectives:     y1: 'MINIMIZE' \"\"\" In\u00a0[3]: Copied! <pre>X = Xopt.from_yaml(YAML)\nX\n</pre> X = Xopt.from_yaml(YAML) X Out[3]: <pre>\n            Xopt\n________________________________\nVersion: 0+untagged.1.gef8e27a\nData size: 0\nConfig as YAML:\ndump_file: null\nevaluator:\n  function: xopt.resources.test_functions.sinusoid_1d.evaluate_sinusoid\n  function_kwargs: {}\n  max_workers: 1\n  vectorized: false\ngenerator:\n  beta: 0.1\n  computation_time: null\n  fixed_features: null\n  gp_constructor:\n    covar_modules: {}\n    mean_modules: {}\n    name: standard\n    trainable_mean_keys: []\n    use_low_noise_prior: true\n  max_travel_distances: null\n  model: null\n  n_candidates: 1\n  n_monte_carlo_samples: 128\n  name: upper_confidence_bound\n  numerical_optimizer:\n    max_iter: 2000\n    n_raw_samples: 20\n    n_restarts: 20\n    name: LBFGS\n  turbo_controller: null\n  use_cuda: false\nmax_evaluations: null\nserialize_inline: false\nserialize_torch: false\nstrict: true\nvocs:\n  constants: {}\n  constraints: {}\n  objectives:\n    y1: MINIMIZE\n  observables: []\n  variables:\n    x1:\n    - 0.0\n    - 6.28\n</pre> In\u00a0[4]: Copied! <pre>X.random_evaluate(3)\nfor i in range(5):\n    print(i)\n    X.step()\n</pre> X.random_evaluate(3) for i in range(5):     print(i)     X.step() <pre>0\n1\n2\n3\n4\n</pre> In\u00a0[5]: Copied! <pre>X.data\n</pre> X.data Out[5]: x1 y1 c1 xopt_runtime xopt_error 0 5.192444 -0.886969 -19.345852 0.000031 False 1 6.137097 -0.145570 -11.809172 0.000005 False 2 4.559331 -0.988309 -18.904205 0.000004 False 4 4.752188 -0.999208 -18.530638 0.000017 False 5 4.726310 -0.999903 -18.503775 0.000017 False 6 4.726147 -0.999905 -18.503688 0.000017 False 7 4.726075 -0.999906 -18.503649 0.000017 False 8 4.726013 -0.999907 -18.503616 0.000017 False In\u00a0[6]: Copied! <pre>model = X.generator.model\nbounds = X.vocs.bounds\n\ntest_x = torch.linspace(*bounds.flatten(), 100).double()\n\ntrain_x = torch.tensor(X.data[\"x1\"].to_numpy())\ntrain_y = torch.tensor(X.data[\"y1\"].to_numpy())\n\nfig, ax = plt.subplots()\nwith torch.no_grad():\n    post = model.models[0].posterior(test_x.reshape(-1,1,1))\n    mean = post.mean.flatten()\n    std = post.variance.sqrt().flatten()\n\n    lower = mean - std\n    upper = mean + std\n\nax.plot(test_x, mean)\nax.fill_between(test_x, lower, upper, alpha=0.5)\nax.plot(\n    train_x.flatten(),\n    train_y.flatten(),\n    \"+\"\n)\nax.set_xlabel(\"x1\")\nax.set_ylabel(\"y1\")\n</pre> model = X.generator.model bounds = X.vocs.bounds  test_x = torch.linspace(*bounds.flatten(), 100).double()  train_x = torch.tensor(X.data[\"x1\"].to_numpy()) train_y = torch.tensor(X.data[\"y1\"].to_numpy())  fig, ax = plt.subplots() with torch.no_grad():     post = model.models[0].posterior(test_x.reshape(-1,1,1))     mean = post.mean.flatten()     std = post.variance.sqrt().flatten()      lower = mean - std     upper = mean + std  ax.plot(test_x, mean) ax.fill_between(test_x, lower, upper, alpha=0.5) ax.plot(     train_x.flatten(),     train_y.flatten(),     \"+\" ) ax.set_xlabel(\"x1\") ax.set_ylabel(\"y1\")  Out[6]: <pre>Text(0, 0.5, 'y1')</pre> In\u00a0[7]: Copied! <pre># Cleanup\n!rm dump.yaml\n</pre> # Cleanup !rm dump.yaml <pre>rm: cannot remove 'dump.yaml': No such file or directory\r\n</pre> In\u00a0[7]: Copied! <pre>\n</pre>"},{"location":"examples/single_objective_bayes_opt/upper_confidence_bound/#upper-confidence-bound-bo","title":"Upper Confidence Bound BO\u00b6","text":""},{"location":"examples/single_objective_bayes_opt/upper_confidence_bound/#run-optimization","title":"Run Optimization\u00b6","text":""},{"location":"examples/single_objective_bayes_opt/upper_confidence_bound/#view-output-data","title":"View output data\u00b6","text":""},{"location":"examples/single_objective_bayes_opt/upper_confidence_bound/#visualize-model-used-by-upper-confidence-bound","title":"Visualize model used by upper confidence bound\u00b6","text":"<p>Models are kept in a list, in this case that list has one element, the model created for the objective <code>y1</code>.</p>"}]}